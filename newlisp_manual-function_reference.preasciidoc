4. Functions in alphabetical order
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function::![]

*syntax:* (! _str-shell-command_ [_int-flags_])

Executes the command in _str-shell-command_ by shelling out to the operating
system and executing. This function returns a different value depending
on the host operating system.

[source,newlisp]
-------------
(! "vi")
(! "ls -ltr")
-------------

Use the link:#exec[exec] function to execute a shell command and capture
the standard output or to feed standard input. The
link:#process[process] function may be used to launch a non-blocking
child process and redirect std I/O and std error to pipes.

On Ms Windows the optional _int-flags_ parameter takes process creation
flags as defined for the Windows `CreateProcessA` function to control
various parameters of process creation. The inclusion of this parameter
– which also can be `0` – forces a different creation of the process
without a command shell window. This parameter is ignored on Unix.

[source,newlisp]
------------------------------------------------------------
; on MS Windows
; close the console of the currently running newLISP process
(apply (import "kernel32" "FreeConsole"))

; start another process and wait for it to finish
(! "notepad.exe" 0)

(exit)
------------------------------------------------------------

Without the additional parameter, the `!` call would create a new
command window replacing the closed one.

Note that `!` (exclamation mark) can be also be used as a command-line
shell operator by omitting the parenthesis and space after the `!`:

[source,newlisp]
----------------------------------------------------
> !ls -ltr    ; executed in the newLISP shell window
----------------------------------------------------

Used in this way, the `!` operator is not a newLISP function at all, but
rather a special feature of the newLISP command shell. The `!` must be
entered as the first character on the command-line.

function::$[]

*syntax:* ($ _int-idx_)

The functions that use regular expressions (link:#directory[directory],
link:#ends-with[ends-with], link:#find[find], link:#parse[parse],
link:#regex[regex], link:#search[search], link:#starts-with[starts-with]
and link:#replace[replace]) all bind their results to the predefined
system variables `$0`, `$1`, `$2`–`$15` after or during the function's
execution. System variables can be treated the same as any other symbol.
As an alternative, the contents of these variables may also be accessed
by using `($ 0)`, `($ 1)`, `($ 2)`, etc. This method allows indexed
access (i.e., `($ i)`, where `i` is an integer).

[source,newlisp]
------------------------------------
(set 'str  "http://newlisp.org:80")
(find "http://(.*):(.*)" str 0)  → 0

$0  → "http://newlisp.org:80"
$1  → "newlisp.org"
$2  → "80"

($ 0)  → "http://newlisp.org:80"
($ 1)  → "newlisp.org"
($ 2)  → "80"
------------------------------------

function::+,-,*,/,%[]

*syntax:* (+ _int-1_ [_int-2_ ... ])

Returns the sum of all numbers in _int-1_ --.

*syntax:* (- _int-1_ [_int-2_ ... ])

Subtracts _int-2_ from _int-1_, then the next _int-i_ from the previous
result. If only one argument is given, its sign is reversed.

*syntax:* (* _int-1_ [_int-2_ ... ])

The product is calculated for _int-1_ to _int-i_.

*syntax:* (/ _int-1_ [_int-2_ ... ])

Each result is divided successively until the end of the list is
reached. Division by zero causes an error.

*syntax:* (% _int-1_ [_int-2_ ... ])

Each result is divided successively by the next _int_, then the rest
(modulo operation) is returned. Division by zero causes an error. For
floating point numbers, use the link:#mod[mod] function.

[source,newlisp]
------------------------------------
(+ 1 2 3 4 5)        → 15
(+ 1 2 (- 5 2) 8)    → 14
(- 10 3 2 1)         → 4
(- (* 3 4) 6 1 2)    → 3
(- 123)              → -123
(map - '(10 20 30))  → (-10 -20 -30)
(* 1 2 3)            → 6
(* 10 (- 8 2))       → 60
(/ 12 3)             → 4
(/ 120 3 20 2)       → 1
(% 10 3)             → 1
(% -10 3)            → -1
(+ 1.2 3.9)          → 4
------------------------------------

Floating point values in arguments to `+`, `-`, `*`, `/`, and `%` are
truncated to the integer value closest to `0` (zero).

Floating point values larger or smaller than the maximum
(`9,223,372,036,854,775,807`) or minimum (`-9,223,372,036,854,775,808`)
integer values are truncated to those values. This includes the values
for `+Inf` and `-Inf`.

Calculations resulting in values larger than `9,223,372,036,854,775,807`
or smaller than `-9,223,372,036,854,775,808` wrap around from positive
to negative or negative to positive.

Floating point values that evaluate to `NaN` (Not a Number), ar treated
as `0` (zero).

function::++[!]

*syntax:* (++ _place_ [_num_ ... ])

The `++` operator works like link:#inc[inc], but performs integer
arithmetic. Without the optional argument in _num_, `++` increments the
number in _place_ by `1`.

If floating point numbers are passed as arguments, their fractional part
gets truncated first.

Calculations resulting in numbers greater than 9,223,372,036,854,775,807
wrap around to negative numbers. Results smaller than
-9,223,372,036,854,775,808 wrap around to positive numbers.

_place_ is either a symbol or a place in a list structure holding a
number, or a number returned by an expression.

[source,newlisp]
--------------------------
(set 'x 1)
(++ x)        → 2
(set 'x 3.8)
(++ x)        → 4
(++ x 1.3)    → 5
(set 'lst '(1 2 3))
(++ (lst 1) 2))  → 4
lst              → (1 4 3)
--------------------------

If the symbol for _place_ contains `nil`, it is treated as if containing
`0`.

See link:#deci[--] for decrementing numbers in integer mode. See
link:#inc[inc] for incrementing numbers in floating point mode.

function::--[!]

*syntax:* (-- _place_ [_num_ ... ])

The `--` operator works like link:#inc[dec], but performs integer
arithmetic. Without the optional argument in _num-2_, `--` decrements
the number in _place_ by `1`.

If floating point numbers are passed as arguments, their fractional part
gets truncated first.

Calculations resulting in numbers greater than 9,223,372,036,854,775,807
wrap around to negative numbers. Results smaller than
-9,223,372,036,854,775,808 wrap around to positive numbers.

_place_ is either a symbol or a place in a list structure holding a
number, or a number returned by an expression.

[source,newlisp]
--------------------------
(set 'x 1)
(-- x)        → 0
(set 'x 3.8)
(-- x)        → 2
(-- x 1.3)    → 1

(set 'lst '(1 2 3))
(-- (lst 1) 2))  → 0
lst              → (1 0 3)
--------------------------

If the symbol for _place_ contains `nil`, it is treated as if containing
`0`.

See link:#inci[++] for incrementing numbers in integer mode. See
link:#dec[dec] for decrementing numbers in floating point mode.

function::<,>,=,<=,>=,!=[]

*syntax:* (< _exp-1_ [_exp-2_ ... ]) +
*syntax:* (> _exp-1_ [_exp-2_ ... ]) +
*syntax:* (= _exp-1_ [_exp-2_ ... ]) +
*syntax:* (<= _exp-1_ [_exp-2_ ... ]) +
*syntax:* (>= _exp-1_ [_exp-2_ ... ]) +
*syntax:* (!= _exp-1_ [_exp-2_ ... ])

Expressions are evaluated and the results are compared successively. As
long as the comparisons conform to the comparison operators, evaluation
and comparison will continue until all arguments are tested and the
result is `true`. As soon as one comparison fails, `nil` is returned.

If only one argument is supplied, all comparison operators assume `0`
(zero) as a second argument. This can be used to check if a numer is
negative, positive, zero or not zero.

All types of expressions can be compared: atoms, numbers, symbols, and
strings. List expressions can also be compared (list elements are
compared recursively).

When comparing lists, elements at the beginning of the list are
considered more significant than the elements following (similar to
characters in a string). When comparing lists of different lengths but
equal elements, the longer list is considered greater (see examples).

In mixed-type expressions, the types are compared from lowest to
highest. Floats and integers are compared by first converting them to
the needed type, then comparing them as numbers.

***********************************************************************
*Atoms:* nil, true, integer or float, string, symbol, primitive +
*Lists:* quoted list/expression, list/expression, lambda, lambda-macro
***********************************************************************

[source,newlisp]
----------------------------------------------------------
(< 3 5 8 9)                     → true
(> 4 2 3 6)                     → nil
(< "a" "c" "d")                 → true
(>= duba aba)                   → true
(< '(3 4) '(1 5))               → nil
(> '(1 2 3) '(1 2))             → true
(= '(5 7 8) '(5 7 8))           → true
(!= 1 4 3 7 3)                  → true
(< 1.2 6 "Hello" 'any '(1 2 3))           → true
(< nil true)                              → true
(< '(((a b))) '(((b c))))                 → true
(< '((a (b c)) '(a (b d)) '(a (b (d)))))  → true

; with single argument compares against 0

(> 1)    → true ; checks for positive
(> -1)   → nil ; checks for negative
(= 123)  → nil ; checks for zero

(map > '(1 3 -4 -3 1 2))   → (true true nil nil true true)
----------------------------------------------------------

function::<<,>>[]

*syntax:* (<< _int-1_ _int-2_ [_int-3_ ... ]) +
*syntax:* (>> _int-1_ _int-2_ [_int-3_ ... ]) +
*syntax:* (<< _int-1_) +
*syntax:* (>> _int-1_)

The number _int-1_ is arithmetically shifted to the left or right by the
number of bits given as _int-2_, then shifted by _int-3_ and so on. For
example, 64-bit integers may be shifted up to 63 positions. When
shifting right, the most significant bit is duplicated (_arithmetic
shift_):

[source,newlisp]
--------------------------------------------------------------------------
(>> 0x8000000000000000 1)  → 0xC000000000000000  ; not 0x0400000000000000!
--------------------------------------------------------------------------

[source,newlisp]
------------------
(<< 1 3)      →  8
(<< 1 2 1)    →  8
(>> 1024 10)  →  1
(>> 160 2 2)  → 10

(<< 3)        →  6
(>> 8)        →  4
------------------

When _int-1_ is the only argument `<<` and `>>` shift by one bit.

function::&[]

*syntax:* (& _int-1_ _int-2_ [_int-3_ ... ])

A bitwise `and` operation is performed on the number in _int-1_ with the
number in _int-2_, then successively with _int-3_, etc.

[source,newlisp]
---------------------------------------
(& 0xAABB 0x000F)  → 11  ; which is 0xB
---------------------------------------

function::|[]

*syntax:* (| _int-1_ _int-2_ [_int-3_ ... ])

A bitwise `or` operation is performed on the number in _int-1_ with the
number in _int-2_, then successively with _int-3_, etc.

[source,newlisp]
------------------------
(| 0x10 0x80 2 1)  → 147
------------------------

function::^[]

*syntax:* (^ _int-1_ _int-2_ [_int-3_ ... ])

A bitwise `xor` operation is performed on the number in _int-1_ with the
number in _int-2_, then successively with _int-3_, etc.

[source,newlisp]
--------------------
(^ 0xAA 0x55)  → 255
--------------------

function::~[]

*syntax:* (~ _int_)

A bitwise `not` operation is performed on the number in _int_, reversing
all of the bits.

[source,newlisp]
------------------------------------
(format "%X" (~ 0xFFFFFFAA))  → "55"
(~ 0xFFFFFFFF)                → 0
------------------------------------

function:::[]

*syntax:* (: _sym-function_ _list-object_ [ ... ])

The colon is used not only as a syntactic separator between between
namespace prefix and the term inside but also as an operator. When used
as an operator, the colon `:` constructs a context symbol from the
context name in the object list and the symbol following the colon. The
object list in _list-object_ can be followed by other parameters.

The `:` operator implements _polymorphism_ of object methods, which are
part of different object classes represented by contexts (namespaces).
In newLISP, an object is represented by a list, the first element of
which is the symbol (name) of its class context. The class context
implements the functions applicable to the object. No space is required
between the colon and the symbol following it.

[source,newlisp]
--------------------------------------------------------------------------------
(define (Rectangle:area)
    (mul (self 3) (self 4)))

(define (Circle:area)
    (mul (pow (self 3) 2) (acos 0) 2))

(define (Rectangle:move dx dy)
    (inc (self 1) dx)
    (inc (self 2) dy))

(define (Circle:move p dx dy)
    (inc (self 1) dx) (inc (self 2) dy))

(set 'myrect '(Rectangle 5 5 10 20)) ; x y width height
(set 'mycircle '(Circle 1 2 10)) ; x y radius

;; using the : (colon) operator to resolve to a specific context

(:area myrect)     → 200
(:area mycircle)   → 314.1592654

;; map class methods uses curry to enclose the colon operator and class function

(map (curry :area) (list myrect mycircle)) → (200 314.1592654)

(map (curry :area) '((Rectangle 5 5 10 20) (Circle 1 2 10))) → (200 314.1592654)

;; change object attributes using a function and re-assigning
;; to the objects name

(:move myrect 2 3)
myrect   → (Rectangle 7 8 10 20)

(:move mycircle 4 5)
mycircle → (Circle 5 7 10)
--------------------------------------------------------------------------------

Inside the FOOP methods the link:#self[self] function is used to access
the target object of the method.

function::abort[]

*syntax:* (abort _int-pid_) +
*syntax:* (abort)

In the first form, `abort` aborts a specific child process of the
current parent process giving the process id in _int-pid_. The process
must have been started using link:#spawn[spawn]. For processes started
using link:#fork[fork], use link:#destroy[destroy] instead.

The function `abort` is not available on Win32.

[source,newlisp]
--------------------
(abort 2245)  → true
--------------------

To abort all child processes spawned from the current process use
`abort` without any parameters:

[source,newlisp]
---------------------------
(abort)  → true ; abort all
---------------------------

The function `abort` is part of the Cilk API for synchronizing child
processes and process parallelization. See the reference for the
function link:#spawn[spawn] for a full discussion of the Cilk API.

function::abs[]

*syntax:* (abs _num_)

Returns the absolute value of the number in _num_.

[source,newlisp]
-----------------
(abs -3.5)  → 3.5
-----------------

function::acos[]

*syntax:* (acos _num-radians_)

The arc-cosine function is calculated from the number in _num-radians_.

[source,newlisp]
------------------
(acos 1)  → 0
(cos (acos 1)) → 1
------------------

function::acosh[]

*syntax:* (acosh _num-radians_)

Calculates the inverse hyperbolic cosine of _num-radians_, the value
whose hyperbolic cosine is _num-radians_. If _num-radians_ is less than
1, `acosh` returns `NaN`.

[source,newlisp]
------------------------
(acosh 2)  → 1.316957897
(cosh (acosh 2)) → 2
(acosh 0.5) → NaN
------------------------

function::add[]

*syntax:* (add _num-1_ [_num-2_ ... ])

All of the numbers in _num-1_, _num-2_, and on are summed. `add` accepts
float or integer operands, but it always returns a floating point
number. Any floating point calculation with `NaN` also returns `NaN`.

[source,newlisp]
------------------------
(add 2 3.25 9)   → 14.25
(add 1 2 3 4 5)  → 15
------------------------

function::address[]

*syntax:* (address _int_) +
*syntax:* (address _float_) +
*syntax:* (address _str_)

Returns the memory address of the integer in _int_, the double floating
point number in _float_, or the string in _str_. This function is used
for passing parameters to library functions that have been imported
using the link:#import[import] function.

[source,newlisp]
----------------------------------------------------------
(set 's "\001\002\003\004")

(get-char (+ (address s) 3))   → 4

(set 'x 12345) ; x is a 64-bit long int

; on a big-endian CPU, i.e. PPC or SPARC
(get-long (address x))         → 12345
; the 32-bit int is in high 32-bit part of the long int
(get-int (+ (address x) 4))    → 12345

; on a little-endian CPU, i.e. Intel i386
; the 32-bit int is in the low 32-bit part of the long int
(get-int (address x))          → 12345

; on both architectures (integers are 64 bit in newLISP)
(set 'x 1234567890)
(get-long (address x))         →  1234567890
----------------------------------------------------------

When a string is passed to C library function the address of the string
is used automatically, and it is not necessary to use the `address`
function in that case. As the example shows, `address` can be used to do
pointer arithmetic on the string's address.

`address` should only be used on persistent addresses from data objects
referred to by a variable symbol, not from volatile intermediate
expression objects.

See also the link:#get-char[get-char], link:#get-int[get-int],
link:#get-long[get-long] and link:#get-float[get-float] functions.

function::amb[]

*syntax:* (amb _exp-1_ [_exp-2_ ... ])

One of the expressions _exp-1_ ... _n_ is selected at random, and the
evaluation result is returned.

[source,newlisp]
----------------------------------------------------------
(amb 'a 'b 'c 'd 'e)  → one of: a, b, c, d, or e at random

(dotimes (x 10) (print (amb 3 5 7)))  → 35777535755
----------------------------------------------------------

Internally, newLISP uses the same function as link:#rand[rand] to pick a
random number. To generate random floating point numbers, use
link:#random[random], link:#randomize[randomize], or
link:#normal[normal]. To initialize the pseudo random number generating
process at a specific starting point, use the link:#seed[seed] function.

function::and[]

*syntax:* (and _exp-1_ [_exp-2_ ... ])

The expressions _exp-1_, _exp-2_, _etc._ are evaluated in order,
returning the result of the last expression. If any of the expressions
yield `nil` or the empty list `()`, evaluation is terminated and `nil`
or the empty list `()` is returned.

[source,newlisp]
--------------------------------------------
(set 'x 10)                       → 10
(and (< x 100) (> x 2))           → true
(and (< x 100) (> x 2) "passed")  → "passed"
(and '())                         → ()
(and true)                        → true
(and)                             → true
--------------------------------------------

function::append[]

*syntax:* (append _list-1_ [_list-2_ ... ]) +
*syntax:* (append _array-1_ [_array-2_ ... ]) +
*syntax:* (append _str-1_ [_str-2_ ... ])

In the first form, `append` works with lists, appending _list-1_ through
_list-n_ to form a new list. The original lists are left unchanged.

[source,newlisp]
--------------------------------------------------------------------
(append '(1 2 3) '(4 5 6) '(a b))  → (1 2 3 4 5 6 a b)

(set 'aList '("hello" "world"))    → ("hello" "world")

(append aList '("here" "I am"))    → ("hello" "world" "here" "I am")
--------------------------------------------------------------------

In the second form `append` works on arrays:

[source,newlisp]
------------------------------------------
(set 'A (array 3 2 (sequence 1 6)))
→ ((1 2) (3 4) (5 6))
(set 'B (array 2 2 (sequence 7 10)))
→ ((7 8) (9 10))

(append A B)
→ ((1 2) (3 4) (5 6) (7 8) (9 10))

(append B B B)
→ ((7 8) (9 10) (7 8) (9 10) (7 8) (9 10))
------------------------------------------

In the third form, `append` works on strings. The strings in _str-n_ are
concatenated into a new string and returned.

[source,newlisp]
-------------------------------------------------------------
(set 'more " how are you")       → " how are you"

(append "Hello " "world," more)  → "Hello world, how are you"
-------------------------------------------------------------

`append` is also suitable for processing binary strings containing
zeroes. The link:#string[string] function would cut of strings at zero
bytes.

Linkage characters or strings can be specified using the
link:#join[join] function. Use the link:#string[string] function to
convert arguments to strings and append in one step.

Use the functions link:#extend[extend] and link:#push[push] to append to
an existing list or string modifying the target.

function::append-file[]

*syntax:* (append-file _str-filename_ _str-buffer_)

Works similarly to link:#write-file[write-file], but the content in
_str-buffer_ is appended if the file in _str-filename_ exists. If the
file does not exist, it is created (in this case, `append-file` works
identically to link:#write-file[write-file]). This function returns the
number of bytes written.

On failure the function returns `nil`. For error information, use
link:#sys-error[sys-error] when used on files. When used on URLs
link:#net-error[net-error] gives more error information.

[source,newlisp]
------------------------------------
(write-file "myfile.txt" "ABC")
(append-file "myfile.txt" "DEF")

(read-file "myfile.txt")  → "ABCDEF"
------------------------------------

`append-file` can take a `http://` or `file://` URL in _str-file-name_.
In case of the `http://` prefix , `append-file` works exactly like
link:#put-url[put-url] with `"Pragma: append\r\n"` in the header option
and can take the same additional parameters. The `"Pragma: append\r\n"`
option is supplied automatically.

[source,newlisp]
-----------------------------------------------------------------
(append-file "http://asite.com/message.txt" "More message text.")
-----------------------------------------------------------------

The file `message.txt` is appended at a remote location
`http://asite.com` with the contents of _str-buffer_. If the file does
not yet exist, it will be created. In this mode, `append-file` can also
be used to transfer files to remote newLISP server nodes.

See also link:#read-file[read-file] and link:#write-file[write-file].

function::apply[]

*syntax:* (apply _func list_ [_int-reduce_])

Applies the contents of _func_ (primitive, user-defined function, or
lambda expression) to the arguments in _list_.

[source,newlisp]
------------------------------------------------
(apply + '(1 2 3 4))                   → 10
(set 'aList '(3 4 5))                  → (3 4 5)
(apply * aList)                        → 60
(apply sqrt '(25))                     → 5
(apply (lambda (x y) (* x y)) '(3 4))  → 12
------------------------------------------------

The _int-reduce_ parameter can optionally contain the number of
arguments taken by the function in _func_. In this case, _func_ will be
repeatedly applied using the previous result as the first argument and
taking the other arguments required successively from _list_ (in
left-associative order). For example, if `op` takes two arguments, then:

[source,newlisp]
-----------------------------------------------
(apply op '(1 2 3 4 5) 2)

;; is equivalent to

(op (op (op (op 1 2) 3) 4) 5)

;; find the greatest common divisor
;; of two or more integers
;; note that newLISP already has a gcd function

(define (gcd_ a b)
    (let (r (% b a))
        (if (= r 0) a (gcd_ r a))))

(define-macro (my-gcd)
    (apply gcd_ (args) 2))

(my-gcd 12 18 6)    → 6
(my-gcd 12 18 6 4)  → 2
-----------------------------------------------

The last example shows how `apply`'s _reduce_ functionality can be used
to convert a two-argument function into one that takes multiple
arguments. Note, that a built-in link:#gcd[gcd] is available.

`apply` should only be used on functions and operators that evaluate all
of their arguments, not on _special forms_ like link:#dotimes[dotimes]
or link:#case[case], which evaluate only some of their arguments. Doing
so will cause the function to fail.

function::args[]

*syntax:* (args) +
*syntax:* (args _int-idx-1_ [_int-idx-2_ ... ])

Accesses a list of all unbound arguments passed to the currently
evaluating link:#define[define], link:#define-macro[define-macro]
lambda, or lambda-macro expression. Only the arguments of the current
function or macro that remain after local variable binding has occurred
are available. The `args` function is useful for defining functions or
macros with a variable number of parameters.

`args` can be used to define hygienic macros that avoid the danger of
variable capture. See link:#define-macro[define-macro].

[source,newlisp]
----------------------------
(define-macro (print-line)
    (dolist (x (args))
        (print x "\n")))

(print-line "hello" "World")
----------------------------

This example prints a line-feed after each argument. The macro mimics
the effect of the built-in function link:#println[println].

In the second syntax, `args` can take one or more indices (_int-idx-n_).

[source,newlisp]
---------------------------------------
(define-macro (foo)
    (print (args 2) (args 1) (args 0)))

(foo x y z)
zyx

(define (bar)
    (args 0 2 -1))

(bar '(1 2 (3 4)))  → 4
---------------------------------------

The function `foo` prints out the arguments in reverse order. The `bar`
function shows `args` being used with multiple indices to access nested
lists.

Remember that `(args)` only contains the arguments not already bound to
local variables of the current function or macro:

[source,newlisp]
--------------------------
(define (foo a b) (args))

(foo 1 2)        → ()

(foo 1 2 3 4 5)  → (3 4 5)
--------------------------

In the first example, an empty list is returned because the arguments
are bound to the two local symbols, `a` and `b`. The second example
demonstrates that, after the first two arguments are bound (as in the
first example), three arguments remain and are then returned by `args`.

`(args)` can be used as an argument to a built-in or user-defined
function call, but it should not be used as an argument to another
macro, in which case `(args)` would not be evaluated and would therefore
have the wrong contents in the new macro environment.

function::array[]

*syntax:* (array _int-n1_ [_int-n2_ ... ] [_list-init_])

Creates an array with _int-n1_ elements, optionally initializing it with
the contents of _list-init_. Up to sixteen dimensions may be specified
for multidimensional arrays.

Internally, newLISP builds multidimensional arrays by using arrays as
the elements of an array. newLISP arrays should be used whenever random
indexing into a large list becomes too slow. Not all list functions may
be used on arrays. For a more detailed discussion, see the chapter on
link:#arrays[arrays].

[source,newlisp]
--------------------------------------------------
(array 5)                  → (nil nil nil nil nil)

(array 5 (sequence 1  5))  → (1 2 3 4 5)

(array 10 '(1 2))          → (1 2 1 2 1 2 1 2 1 2)
--------------------------------------------------

Arrays can be initialized with objects of any type. If fewer
initializers than elements are provided, the list is repeated until all
elements of the array are initialized.

[source,newlisp]
------------------------------------------
(set 'myarray (array 3 4 (sequence 1 12)))
→ ((1 2 3 4) (5 6 7 8) (9 10 11 12))
------------------------------------------

Arrays are modified and accessed using most of the same functions used
for modifying lists:

-----------------------------------------------------
(setf (myarray 2 3) 99) → 99)
myarray → ((1 2 3 4) (5 6 7 8) (9 10 11 99))

(setf (myarray 1 1) "hello")  → "hello"

myarray → ((1 2 3 4) (5 "hello" 7 8) (9 10 11 99))

(setf (myarray 1) '(a b c d)) → (a b c d)
myarray → ((1 2 3 4) (a b c d) (9 10 11 99))

(nth 1 myarray)     → (a b c d)  ; access a whole row

(myarray 0 -1)      → 4

;; use implicit indexing and slicing on arrays

(myarray 1)     → (a b c d)

(myarray 0 -1)  → 4

(2 myarray)     → (c d)

(-3 2 myarray)  → (b c)
-----------------------------------------------------

Care must be taken to use an array when replacing a whole row.

link:#array-list[array-list] can be used to convert arrays back into
lists:

[source,newlisp]
--------------------------------------------------------
(array-list myarray)  → ((1 2 3 4) (a b c d) (1 2 3 99))
--------------------------------------------------------

To convert a list back into an array, apply link:#flat[flat] to the
list:

[source,newlisp]
-------------------------------------------------------
(set 'aList '((1 2) (3 4)))             → ((1 2) (3 4))

(set 'aArray (array 2 2 (flat aList)))  → ((1 2) (3 4))
-------------------------------------------------------

The link:#arrayp[array?] function can be used to check if an expression
is an array:

[source,newlisp]
-------------------------------------
(array? myarray)               → true

(array? (array-list myarray))  → nil
-------------------------------------

When serializing arrays using the function link:#source[source] or
link:#save[save], the generated code includes the `array` statement
necessary to create them. This way, variables containing arrays are
correctly serialized when saving with link:#save[save] or creating
source strings using link:#source[source].

[source,newlisp]
------------------------------------------
(set 'myarray (array 3 4 (sequence 1 12)))

(save "array.lsp" 'myarray)

;; contents of file arraylsp ;;

(set 'myarray (array 3 4 (flat '(
  (1 2 3 4)
  (5 6 7 8)
  (9 10 11 12)))))
------------------------------------------

function::array-list[]

*syntax:* (array-list _array_)

Returns a list conversion from _array_, leaving the original array
unchanged:

[source,newlisp]
------------------------------------------
(set 'myarray (array 3 4 (sequence 1 12)))
→ ((1 2 3 4) (5 6 7 8) (9 10 11 12))

(set 'mylist (array-list myarray))
→ ((1 2 3 4) (5 6 7 8) (9 10 11 12))

(list (array? myarray) (list? mylist))
→ (true true)
------------------------------------------

function::array?[]

*syntax:* (array? _exp_)

Checks if _exp_ is an array:

[source,newlisp]
-----------------------------------
(set 'M (array 3 4 (sequence 1 4)))
→ ((1 2 3 4) (1 2 3 4) (1 2 3 4)))

(array? M)               → true

(array? (array-list M))  → nil
-----------------------------------

function::asin[]

*syntax:* (asin _num-radians_)

Calculates the arcsine function from the number in _num-radians_ and
returns the result.

[source,newlisp]
-----------------------
(asin 1)  → 1.570796327
(sin (asin 1)) → 1
-----------------------

function::asinh[]

*syntax:* (asinh _num-radians_)

Calculates the inverse hyperbolic sine of _num-radians_, the value whose
hyperbolic sine is _num-radians_.

[source,newlisp]
-------------------------------
(asinh 2)         → 1.443635475
(sinh (asinh 2))  → 2
-------------------------------

function::assoc[]

*syntax:* (assoc _exp-key_ _list-alist_) +
*syntax:* (assoc _list-exp-key_ _list-alist_)

In the first syntax the value of _exp-key_ is used to search
_list-alist_ for a _member-list_ whose first element matches the key
value. If found, the _member-list_ is returned; otherwise, the result
will be `nil`.

[source,newlisp]
------------------------------------------------------
(assoc 1 '((3 4) (1 2)))  → (1 2)

(set 'data '((apples 123) (bananas 123 45) (pears 7)))

(assoc 'bananas data)  → (bananas 123 45)
(assoc 'oranges data)  → nil
------------------------------------------------------

Together with link:#setf[setf] `assoc` can be used to change an
association.

[source,newlisp]
-------------------------------------------------
(setf (assoc 'pears data) '(pears 8))

data  → ((apples 123) (bananas 123 45) (pears 8))
-------------------------------------------------

In the second syntax more then one key expressions can be specified to
search in nested, multilevel association lists:

[source,newlisp]
------------------------------------------------------------------------------
(set 'persons '(
    (id001 (name "Anne") (address (country "USA") (city "New York")))
    (id002 (name "Jean") (address (country "France") (city "Paris")))
))

(assoc '(id001 address) persons) → (address (country "USA") (city "New York"))
(assoc '(id001 address city) persons) → (city "New York")
------------------------------------------------------------------------------

The list in _list-aList_ can be a context which will be interpreted as
its _default functor_. This way very big lists can be passed by
reference for speedier access and less memory usage:

[source,newlisp]
---------------------------------------------------------------------
(set 'persons:persons '(
    (id001 (name "Anne") (address (country "USA") (city "New York")))
    (id002 (name "Jean") (address (country "France") (city "Paris")))
))

(define (get-city db id)
    (last (assoc (list id 'address 'city) db ))
)

(get-city persons 'id001) → "New York"
---------------------------------------------------------------------

For making replacements in association lists, use the link:#setf[setf]
together with the `assoc` function. The link:#lookup[lookup] function is
used to perform association lookup and element extraction in one step.

function::atan[]

*syntax:* (atan _num-radians_)

The arctangent of _num-radians_ is calculated and returned.

[source,newlisp]
------------------------------
(atan 1)        → 0.7853981634
(tan (atan 1))  → 1
------------------------------

function::atan2[]

*syntax:* (atan2 _num-Y-radians_ _num-X-radians_)

The `atan2` function computes the principal value of the arctangent of Y
/ X in radians. It uses the signs of both arguments to determine the
quadrant of the return value. `atan2` is useful for converting Cartesian
coordinates into polar coordinates.

[source,newlisp]
------------------------------------------------
(atan2 1 1)                       → 0.7853981634
(div (acos 0) (atan2 1 1))        → 2
(atan2 0 -1)                      → 3.141592654
(= (atan2 1 2) (atan (div 1 2)))  → true
------------------------------------------------

function::atanh[]

*syntax:* (atanh _num-radians_)

Calculates the inverse hyperbolic tangent of _num-radians_, the value
whose hyperbolic tangent is _num-radians_. If the absolute value of
_num-radians_ is greater than 1, `atanh` returns `NaN`; if it is equal
to 1, `atanh` returns infinity.

[source,newlisp]
--------------------------
(atanh 0.5) → 0.5493061443
(tanh (atanh 0.5)) → 0.5
(atanh 1.1) → NaN
(atanh 1) → inf
--------------------------

function::atom?[]

*syntax:* (atom? _exp_)

Returns `true` if the value of _exp_ is an atom, otherwise `nil`. An
expression is an atom if it evaluates to nil, true, an integer, a float,
a string, a symbol or a primitive. Lists, lambda or lambda-macro
expressions, and quoted expressions are not atoms.

[source,newlisp]
----------------------------
(atom? '(1 2 3))      → nil
(and (atom? 123)
     (atom? "hello")
     (atom? 'foo))    → true
(atom? ''foo)         → nil
----------------------------

function::base64-dec[]

*syntax:* (base64-dec _str_)

The BASE64 string in _str_ is decoded. Note that _str_ is not verified
to be a valid BASE64 string. The decoded string is returned.

[source,newlisp]
------------------------------------------------
(base64-dec "SGVsbG8gV29ybGQ=")  → "Hello World"
------------------------------------------------

For encoding, use the link:#base64-enc[base64-enc] function.

newLISP's BASE64 handling is derived from routines found in the Unix
http://curl.haxx.se/[curl] utility and conforms to the RFC 4648
standard.

function::base64-enc[]

*syntax:* (base64-enc _str_ [_bool-flag_])

The string in _str_ is encoded into BASE64 format. This format encodes
groups of 3 * 8 = 24 input bits into 4 * 8 = 32 output bits, where each
8-bit output group represents 6 bits from the input string. The 6 bits
are encoded into 64 possibilities from the letters A–Z and a–z; the
numbers 0–9; and the characters + (plus sign) and / (slash). The =
(equals sign) is used as a filler in unused 3- to 4-byte translations.
This function is helpful for converting binary content into printable
characters.

Without the optional _bool-flag_ parameter the empty string `""` is
encoded into `"===="`. If _bool-flag_ evaluates to `true`, the the empty
string `""` is translated into `""`. Both translations result in `""`
when using link:base64-dec[base64-dec].

The encoded string is returned.

BASE64 encoding is used with many Internet protocols to encode binary
data for inclusion in text-based messages (e.g., XML-RPC).

[source,newlisp]
------------------------------------------------
(base64-enc "Hello World")  → "SGVsbG8gV29ybGQ="

(base64-enc "")             → "===="
(base64-enc "" true)        → ""
------------------------------------------------

Note that `base64-enc` does not insert carriage-return/line-feed pairs
in longer BASE64 sequences but instead returns a pure BASE64-encoded
string.

For decoding, use the link:#base64-dec[base64-dec] function.

newLISP's BASE64 handling is derived from routines found in the Unix
http://curl.haxx.se/[curl] utility and conforms to the RFC 4648
standard.

function::bayes-query[]

*syntax:* (bayes-query _list-L_ _context-D_ [_bool-chain_ [_bool-probs_]])

Takes a list of tokens (_list-L_) and a trained dictionary (_context-D_)
and returns a list of the combined probabilities of the tokens in one
category (_A_ or _Mc_) versus a category (_B_) against all other
categories (_Mi_). All tokens in _list-L_ should occur in _context-D_.
When using the default _R.A. Fisher Chi²_ mode, nonexistent tokens will
skew results toward equal probability in all categories.

Non-existing tokens will not have any influence on the result when using
the true _Chain Bayesian_ mode with _bool-chain_ set to `true`. The
optional last flag, _bool-probs_, indicates whether frequencies or
probability values are used in the data set. The
link:#bayes-train[bayes-train] function is typically used to generate a
data set's frequencies.

Tokens can be strings or symbols. If strings are used, they are
prepended with an underscore before being looked up in _context-D_. If
link:#bayes-train[bayes-train] was used to generate _context-D_'s
frequencies, the underscore was automatically prepended during the
learning process.

Depending on the flag specified in _bool-probs_,
link:#bayes-query[bayes-query] employs either the R. A. Fisher Chi²
method of compounding probabilities or the Chain Bayesian method. By
default, when no flag or `nil` is specified in _bool-probs_, the _Chi²_
method of compounding probabilities is used. When specifying `true` in
_bool-probs_, the Chain Bayesian method is used.

If the R.A. Fisher Chi² method is used, the total number of tokens in
the different training set's categories should be equal or similar.
Uneven frequencies in categories will skew the results.

For two categories _A_ and _B_, `bayes-query` uses the following
formula:

*_p(A|tkn) = p(tkn|A) * p(A) / p(tkn|A) * p(A) + p(tkn|B) * p(B)_*

For _N_ categories, this formula is used:

*_p(Mc|tkn) = p(tkn|Mc) * p(Mc) / sum-i-N( p(tkn|Mi) * p(Mi) )_*

The probabilities (_p(Mi)_ or _p(A)_, along with _p(B)_) represent the
_Bayesian prior probabilities_. _p(Mc|tkn)_ and _p(A|tkn)_ are the
_posterior Bayesian_ probabilities of a category or model.

Priors are handled differently, depending on whether the R.A. Fisher
Chi² or the Chain Bayesian method is used. In Chain Bayesian mode,
posteriors from one token calculation get the priors in the next
calculation. In the default R.A. Fisher method, priors are not passed on
via chaining, but probabilities are compounded using the Chi² method.

In Chain Bayes mode, tokens with zero frequency in one category will
effectively put the probability of that category to 0 (zero). This also
causes all posterior priors to be set to 0 and the category to be
completely suppressed in the result. Queries resulting in zero
probabilities for all categories yield _NaN_ values.

The default R.A. Fisher Chi² method is less sensitive about zero
frequencies and still maintains a low probability for that token. This
may be an important feature in natural language processing when using
_Bayesian statistics_. Imagine that five different language _corpus_
categories have been trained, but some words occurring in one category
are not present in another. When the pure Chain Bayesian method is used,
a sentence could never be classified into its correct category because
the zero-count of just one word token could effectively exclude it from
the category to which it belongs.

On the other hand, the Chain Bayesian method offers exact results for
specific proportions in the data. When using Chain Bayesian mode for
natural language data, all zero frequencies should be removed from the
trained dictionary first.

The return value of `bayes-query` is a list of probability values, one
for each category. Following are two examples: the first for the default
R.A. Fisher mode, the second for a data set processed with the Chain
Bayesian method.

Previous to version 10.3.0 the list of probability values returned in
Fisher Chi² mode was normalized by dividing each value by the sum of the
whole list. This normalization has been dropped in version 10.3.0.

R.A. Fisher Chi² method
^^^^^^^^^^^^^^^^^^^^^^^

In the following example, the two data sets are books from Project
Gutenberg. We assume that different authors use certain words with
different frequencies and want to determine if a sentence is more likely
to occur in one or the other author's writing. A similar method is
frequently used to differentiate between spam and legitimate email.

[source,newlisp]
-------------------------------------------------------------
;; from Project Gutenberg: http://www.gutenberg.org/catalog/
;; The Adventures of Sherlock Holmes - Sir Arthur Conan Doyle

(bayes-train (parse (lower-case (read-file "Doyle.txt"))
                    "[^a-z]+" 0) '() 'DoyleDowson)

;; A Comedy of Masks - Ernest Dowson and Arthur Moore

(bayes-train '() (parse (lower-case (read-file "Dowson.txt"))
                    "[^a-z]+" 0) 'DoyleDowson)

(save "DoyleDowson.lsp" 'DoyleDowson)
-------------------------------------------------------------

The two training sets are loaded, split into tokens, and processed by
the link:#bayes-train[bayes-train] function. In the end, the
`DoyleDowson` dictionary is saved to a file, which will be used later
with the `bayes-query` function.

The following code illustrates how `bayes-query` is used to classify a
sentence as _Doyle_ or _Dowson_:

[source,newlisp]
--------------------------------------------------------------------------------
(load "DoyleDowson.lsp")
(bayes-query (parse "he was putting the last touches to a picture")
    'DoyleDowson)
→ (0.03802079132 0.9619792087)

(bayes-query (parse "immense faculties and extraordinary powers of observation")
    'DoyleDowson)
→ (0.985108793 0.01489120699)
--------------------------------------------------------------------------------

The queries correctly identify the first sentence as a _Dowson_
sentence, and the second one as a _Doyle_ sentence.

Chain Bayesian method
^^^^^^^^^^^^^^^^^^^^^

The second example is frequently found in introductory literature on
Bayesian statistics. It shows the Chain Bayesian method of using
`bayes-query` on the data of a previously processed data set:

[source,newlisp]
---------------------------------
(set 'Data:test-positive '(8 18))
(set 'Data:test-negative '(2 72))
(set 'Data:total '(10 90))
---------------------------------

A disease occurs in 10 percent of the population. A blood test developed
to detect this disease produces a false positive rate of 20 percent in
the healthy population and a false negative rate of 20 percent in the
sick. What is the probability of a person carrying the disease after
testing positive?

[source,newlisp]
--------------------------------------------------------------------
(bayes-query '(test-positive) Data true)
→ (0.3076923077 0.6923076923)

(bayes-query '(test-positive test-positive) Data true)
→ (0.64 0.36)

(bayes-query '(test-positive test-positive test-positive) Data true)
→ (0.8767123288 0.1232876712)
--------------------------------------------------------------------

Note that the Bayesian formulas used assume statistical independence of
events for the `bayes-query` to work correctly.

The example shows that a person must test positive several times before
they can be confidently classified as sick.

Calculating the same example using the R.A. Fisher Chi² method will give
less-distinguished results.

Specifying probabilities instead of counts
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Often, data is already available as probability values and would require
additional work to reverse them into frequencies. In the last example,
the data were originally defined as percentages. The additional optional
_bool-probs_ flag allows probabilities to be entered directly and should
be used together with the Chain Bayesian mode for maximum performance:

[source,newlisp]
-------------------------------------------------------------------------
(set 'Data:test-positive '(0.8 0.2))
(set 'Data:test-negative '(0.2 0.8))
(set 'Data:total '(0.1 0.9))

(bayes-query '(test-positive) Data true true)
→ (0.3076923077 0.6923076923)

(bayes-query '(test-positive test-positive) Data true true)
→ (0.64 0.36)

(bayes-query '(test-positive test-positive test-positive) Data true true)
→ (0.8767123288 0.1232876712)
-------------------------------------------------------------------------

As expected, the results are the same for probabilities as they are for
frequencies.

function::bayes-train[]

*syntax:* (bayes-train _list-M1_ [_list-M2_ ... ] _sym-context-D_)

Takes one or more lists of tokens (_M1_, _M2—_) from a joint set of
tokens. In newLISP, tokens can be symbols or strings (other data types
are ignored). Tokens are placed in a common dictionary in
_sym-context-D_, and the frequency is counted for each token in each
category _Mi_. If the context does not yet exist, it must be quoted.

The _M_ categories represent data models for which sequences of tokens
can be classified (see link:#bayes-query[bayes-query]). Each token in
_D_ is a content-addressable symbol containing a list of the frequencies
for this token within each category. String tokens are prepended with an
`_` (underscore) before being converted into symbols. A symbol named
`total` is created containing the total of each category. The `total`
symbol cannot be part of the symbols passed as an _Mi_ category.

The function returns a list of token frequencies found in the different
categories or models.

[source,newlisp]
-----------------------------------------------------
(bayes-train '(A A B C C) '(A B B C C C) 'L)  → (5 6)

L:A      → (2 1)
L:B      → (1 2)
L:C      → (2 3)
L:total  → (5 6)

(bayes-train '("one" "two" "two" "three")
             '("three" "one" "three")
             '("one" "two" "three") 'S)
→ (4 3 3)

S:_one    → (1 1 1)
S:_two    → (2 0 1)
S:_three  → (1 2 1)
S:total   → (4 3 3)
-----------------------------------------------------

The first example shows training with two lists of symbols. The second
example illustrates how an `_` is prepended when training with strings.

`bayes-train` creates symbols from strings prepending an underscore
character. This is the same way hashes are created and contexts
populates with symbols by `bayes-train` can be used like hashes:

[source,newlisp]
--------------------------------------------------------------
; use a bayes-trained context namespace like a hash dictionary

(S "two")   → (2 0 1)
(S "three") → (1 2 1)

(S) → (("one" (1 1 1)) ("three" (1 2 1)) ("two" (2 0 1)))
--------------------------------------------------------------

Note that these examples are just for demonstration purposes. In
reality, training sets may contain thousands or millions of words,
especially when training natural language models. But small data sets
may be used when the frequency of symbols just describe already-known
proportions. In this case, it may be better to describe the model data
set explicitly, without the `bayes-train` function:

[source,newlisp]
-----------------------------------
(set 'Data:tested-positive '(8 18))
(set 'Data:tested-negative '(2 72))
(set 'Data:total '(10 90))
-----------------------------------

The last data are from a popular example used to describe the
link:#bayes-query[bayes-query] function in introductory papers and books
about _bayesian networks_.

Training can be done in different stages by using `bayes-train` on an
existing trained context with the same number of categories. The new
symbols will be added, then counts and totals will be correctly updated.

Training in multiple batches may be necessary on big text corpora or
documents that must be tokenized first. These corpora can be tokenized
in small portions, then fed into `bayes-train` in multiple stages.
Categories can also be singularly trained by specifying an empty list
for the absent corpus:

[source,newlisp]
--------------------------------------------------
(bayes-train shakespeare1 '() 'data)
(bayes-train shakespeare2 '() 'data)
(bayes-train '() hemingway1 'data)
(bayes-train '() hemingway2 'data)
(bayes-train shakepeare-rest hemingway-rest 'data)
--------------------------------------------------

`bayes-train` will correctly update word counts and totals.

Using `bayes-train` inside a context other than `MAIN` requires the
training contexts to have been created previously within the `MAIN`
context via the link:#context[context] function.

`bayes-train` is not only useful with the link:#bayes-query[bayes-query]
function, but also as a function for counting in general. For instance,
the resulting frequencies could be analyzed using
link:#prob-chi2[prob-chi2] against a _null hypothesis_ of proportional
distribution of items across categories.

function::begin[]

*syntax:* (begin _body_)

The `begin` function is used to group a block of expressions. The
expressions in _body_ are evaluated in sequence, and the value of the
last expression in _body_ is returned.

[source,newlisp]
----------------------------------------------
(begin
  (print "This is a block of 2 expressions\n")
  (print "================================"))
----------------------------------------------

Some built-in functions like link:#cond[cond], link:#define[define],
link:#doargs[doargs], link:#dolist[dolist], link:#dostring[dostring],
link:#dotimes[dotimes], link:#when[when] and link:#while[while] already
allow multiple expressions in their bodies, but `begin` is often used in
an link:#if[if] expression.

The link:#silent[silent] function works like `begin`, but suppresses
console output on return.

function::beta[]

*syntax:* (beta _cum-a_ _num-b_)

The _Beta_ function, `beta`, is derived from the _log Gamma_ `gammaln`
function as follows:

_*beta = exp(gammaln(a) + gammaln(b) - gammaln(a + b))*_

[source,newlisp]
-----------------
(beta 1 2)  → 0.5
-----------------

function::betai[]

*syntax:* (betai _num-x_ _num-a_ _num-b_)

The _Incomplete Beta_ function, `betai`, equals the cumulative
probability of the _Beta_ distribution, `betai`, at _x_ in _num-x_. The
cumulative binomial distribution is defined as the probability of an
event, _pev_, with probability _p_ to occur _k_ or more times in _N_
trials:

_*pev = Betai(p, k, N - k + 1)*_

[source,newlisp]
----------------------------
(betai 0.5 3 8)  → 0.9453125
----------------------------

The example calculates the probability for an event with a probability
of 0.5 to occur 3 or more times in 10 trials (8 = 10 - 3 + 1). The
incomplete Beta distribution can be used to derive a variety of other
functions in mathematics and statistics. See also the
link:#binomial[binomial] function.

function::bind[!]

*syntax:* (bind _list-variable-associations_ [_bool-eval_])

_list-variable-associations_ contains an association list of symbols and
their values. `bind` sets all symbols to their associated values.

The associated values are evaluated if the _bool-eval_ flag is `true`:

[source,newlisp]
-------------------------------------
(set 'lst '((a (+ 3 4)) (b "hello")))

(bind lst)         → "hello"

a    → (+ 3 4)
b    → "hello"

(bind lst true)    → "hello"

a    → 7
-------------------------------------

The return value of bind is the value of the last association.

`bind` is often used to bind association lists returned by
link:#unify[unify].

[source,newlisp]
-------------------------------------------
(bind (unify '(p X Y a) '(p Y X X)))    → a

X    → a
Y    → a
-------------------------------------------

This can be used for de-structuring:

[source,newlisp]
------------------------------------------------
(set 'structure '((one "two") 3 (four (x y z))))
(set 'pattern '((A B) C (D E)))
(bind (unify pattern structure))

A → one
B → "two"
C → 3
D → four
E → (x y z)
------------------------------------------------

link:#unify[unify] returns an association list and `bind` binds the
associations.

function::binomial[]

*syntax:* (binomial _int-n_ _int-k_ _float-p_)

The binomial distribution function is defined as the probability for an
event to occur _int-k_ times in _int-n_ trials if that event has a
probability of _float-p_ and all trials are independent of one another:

_*binomial = pow(p, k) * pow(1.0 - p, n - k) * n! / (k! * (n - k)!)*_

where _x!_ is the factorial of _x_ and _pow(x, y)_ is _x_ raised to the
power of _y_.

[source,newlisp]
--------------------------------
(binomial 10 3 0.5)  → 0.1171875
--------------------------------

The example calculates the probability for an event with a probability
of 0.5 to occur 3 times in 10 trials. For a cumulated distribution, see
the link:#betai[betai] function.

function::bits[]

*syntax:* (bits _int_ [_bool_])

Transforms a number in _int_ to a string of 1's and 0's or a list, if
_bool_ evaluates to anything not `nil`.

In string representation bits are in high to low order. In list
presentation 1's and 0's are represented as `true` and `nil` and in
order from the lowest to the highest bit. This allows direct indexing
and program control switching on the result.

[source,newlisp]
-------------------------------------------------------------------------
(bits 1234)      → "10011010010"

(int (bits 1234) 0 2) → 1234

(bits 1234 true)     → (nil true nil nil true nil true true nil nil true)

((bits 1234 true) 0) → nil ; indexing of the result
-------------------------------------------------------------------------

link:#int[int] with a base of 2 is the inverse function to `bits`.

function::callback[]

*syntax:* (callback _int-index_ _sym-function_) +
*syntax:* (callback _sym-function_ _str-return-type_ [_str_param_type_ ...]) +
*stntax:* (callback _sym-function_)

In the first *simple `callback` syntax* up to sixteen (0 to 15)
_callback_ functions for up to eight parameters can be registered with
imported libraries. The `callback` function returns a procedure address
that invokes a user-defined function in _sym-function_. The following
example shows the usage of callback functions when importing the
http://www.opengl.org[OpenGL] graphics library:

If more than sixteen callback functions are required, slots must be
reassigned to a different callback function.

[source,newlisp]
----------------------------------------------------------------
...
(define (draw)
    (glClear GL_COLOR_BUFFER_BIT )
    (glRotated rotx 0.0 1.0 0.0)
    (glRotated roty 1.0 0.0 0.0)
    (glutWireTeapot 0.5)
    (glutSwapBuffers))

(define (keyboard key x y)
    (if (= (& key 0xFF) 27) (exit)) ; exit program with ESC
    (println "key:" (& key 0xFF) " x:" x  " y:" y))

(define (mouse button state x y)
    (if (= state 0)
        (glutIdleFunc 0) ; stop rotation on button press
        (glutIdleFunc (callback 4 'rotation)))
    (println "button: " button " state:" state " x:" x " y:" y))

(glutDisplayFunc (callback 0 'draw))
(glutKeyboardFunc (callback 1 'keyboard))
(glutMouseFunc (callback 2 'mouse))
...
----------------------------------------------------------------

The address returned by `callback` is registered with the
http://www.opengl.org/documentation/specs/glut/spec3/spec3.html[Glut]
library. The above code is a snippet from the file `opengl-demo.lsp`, in
the `examples/` directory of the source distribution of newLISP.

In the second *extended `callback` syntax* type specifiers are used to
describe the functions return and parameter value types when the
function is called. An unlimited number of callback functions can be
registered with the second syntax, and return values are passed back to
the calling function. The symbol in _sym-function_ contains a newLISP
defined function used as a callback function callable from a C program.

In the third syntax `callback` returns a previously returned C-callable
address for that symbol.

While the first simple `callback` syntax only handles integers and
pointer values, `callback` in the expanded syntax can also handle simple
and double precision floationg point numbers passed in an out of the
`callback` function.

Both the simple and extended syntax can be mixed inside the same
program.

The following example shows the link:#import[import] of the `qsort` C
library function, which takes as one of it's arguments the address of a
comparison function. The comparison function in this case is written in
newLISP and called into by the imported `qsort` function:

[source,newlisp]
----------------------------------------------------------------
; C void qsort(...) takes an integer array with number and width
; of array elements and a pointer to the comparison function
(import "libc.dylib" "qsort" "void" "void*" "int" "int" "void*")

(set 'rlist '(2 3 1 2 4 4 3 3 0 3))
; pack the list into an C readable 32-bit integer array
(set 'carray (pack (dup "ld " 10) rlist))

; the comparison callback function receives pointers to integers
(define (cmp a b)
    (- (get-int a) (get-int b)))

; generate a C callable address for cmp
(set 'func (callback 'cmp "int" "void*" "void*"))

; sort the carray
(qsort carray 10 4 func)

; unpack the sorted array into a LISP list
(unpack (dup "ld" 10) carray)  →  (0 1 2 2 3 3 3 3 4 4)
----------------------------------------------------------------

As type specifiers the same string tags can be used as in the
link:#import[import] function. All pointer types are passed as numbers
in and out of the `callback` function. The functions
link:#get-char[get-char], link:#get-int[get-int],
link:#get-long[get-long] and link:#get-string[get-string] can be used to
extract numbers of different precision from parameters. Use
link:#pack[pack] and link:#unpack[unpack] to extract data from binary
buffers and structures.

Note that newLISP as already a fast built-in link:#sort[sort] function.

function::case[]

*syntax:* (case _exp-switch_ (_exp-1_ _body-1_) [(_exp-2_ _body-2_) ... ])

The result of evaluating _exp-switch_ is compared to each of the
_unevaluated_ expressions _exp-1, exp-2,_ —. If a match is found, the
corresponding expressions in _body_ are evaluated. The result of the
last body expression is returned as the result for the entire `case`
expression.

[source,newlisp]
----------------------------------------
(define (translate n)
  (case n
    (1 "one")
    (2 "two")
    (3 "three")
    (4 "four")
    (true "Can't translate this")))

(translate 3)   → "three"
(translate 10)  → "Can't translate this"
----------------------------------------

The example shows how, if no match is found, the last expression in the
body of a `case` function can be evaluated.

function::catch[]

*syntax:* (catch _exp_) +
*syntax:* (catch _exp_ _symbol_)

In the first syntax, `catch` will return the result of the evaluation of
_exp_ or the evaluated argument of a link:#throw[throw] executed during
the evaluation of _exp_:

[source,newlisp]
-----------------------------------
(catch (dotimes (x 1000)
  (if (= x 500) (throw x))))  → 500
-----------------------------------

This form is useful for breaking out of iteration loops and for forcing
an early return from a function or expression block:

[source,newlisp]
----------------------------
(define (foo x)
   …
  (if condition (throw 123))
    …
  456)

;; if condition is true

(catch (foo p))  → 123

;; if condition is not true

(catch (foo p))  → 456
----------------------------

In the second syntax, `catch` evaluates the expression _exp_, stores the
result in _symbol_, and returns `true`. If an error occurs during
evaluation, `catch` returns `nil` and stores the error message in
_symbol_. This form can be useful when errors are expected as a normal
potential outcome of a function and are dealt with during program
execution.

[source,newlisp]
--------------------------------------------------------
(catch (func 3 4) 'result)  → nil
result
→ "ERR: invalid function in function catch : (func 3 4)"

(constant 'func +)          → + <4068A6>
(catch (func 3 4) 'result)  → true
result                      → 7
--------------------------------------------------------

When a link:#throw[throw] is executed during the evaluation of _exp_,
`catch` will return `true`, and the `throw` argument will be stored in
_symbol_:

[source,newlisp]
----------------------------------------------
(catch (dotimes (x 100)
  (if (= x 50) (throw "fin")) 'result)  → true

result  → "fin"
----------------------------------------------

As well as being used for early returns from functions and for breaking
out of iteration loops (as in the first syntax), the second syntax of
`catch` can also be used to catch errors. The
link:#throw-error[throw-error] function may be used to throw
user-defined errors.

function::ceil[]

*syntax:* (ceil _number_)

Returns the next highest integer above _number_ as a floating point.

[source,newlisp]
-----------------
(ceil -1.5)  → -1
(ceil 3.4)   → 4
-----------------

See also the link:#floor[floor] function.

function::change-dir[]

*syntax:* (change-dir _str-path_)

Changes the current directory to be the one given in _str-path_. If
successful, `true` is returned; otherwise `nil` is returned.

[source,newlisp]
-------------------
(change-dir "/etc")
-------------------

Makes `/etc` the current directory.

function::char[utf8]

*syntax:* (char _str_ [_int-index_ [true]]) +
*syntax:* (char _int_)

Given a string argument, extracts the character at _int-index_ from
_str_, returning either the ASCII value of that character or the Unicode
value on UTF-8 enabled versions of newLISP.

If _int-index_ is omitted, 0 (zero) is assumed. If _int-idx_ is followed
by a boolean `true` value, than the index treats _str_ as an 8-bit byte
array instead of an array of multi-byte UTF-8 characters.

The empty string returns `nil`. Both `(char 0)` and `(char nil)` will
return `"\000"`.

See link:#indexing[Indexing elements of strings and lists].

Given an integer argument, `char` returns a string containing the ASCII
character with value _int_.

On UTF-8–enabled versions of newLISP, the value in _int_ is taken as
Unicode and a UTF-8 character is returned.

[source,newlisp]
------------------------------------------------------------
(char "ABC")          → 65  ; ASCII code for "A"
(char "ABC" 1)        → 66  ; ASCII code for "B"
(char "ABC" -1)       → 67  ; ASCII code for "C"
(char "B")            → 66  ; ASCII code for "B"
(char "Ω")            → 937 ; UTF-8 code for "Ω"
(char "Ω" 1 true)     → 169 ; byte value at offset 1

(char 65)  → "A"
(char 66)  → "B"

(char (char 65))  → 65      ; two inverse applications

(map char (sequence 1 255))  ; returns current character set

; The Zen of UTF-8
(char (& (char "生") (char "死"))) → 愛 ; by @kosh_bot
------------------------------------------------------------

function::chop[utf8]

*syntax:* (chop _str_ [_int-chars_]) +
*syntax:* (chop _list_ [_int-elements_])

If the first argument evaluates to a string, `chop` returns a copy of
_str_ with the last _int-char_ characters omitted. If the _int-char_
argument is absent, one character is omitted. `chop` does not alter
_str_.

If the first argument evaluates to a list, a copy of _list_ is returned
with _int-elements_ omitted (same as for strings).

[source,newlisp]
---------------------------------
(set 'str "newLISP")  → "newLISP"

(chop str)    → "newLIS"
(chop str 2)  → "newLI"

str  → "newLISP"

(set 'lst '(a b (c d) e))

(chop lst)    → (a b (c d))
(chop lst 2)  → (a b)

lst  → (a b (c d) e)
---------------------------------

function::clean[]

*syntax:* (clean _exp-predicate_ _list_)

The predicate _exp-predicate_ is applied to each element of _list_. In
the returned list, all elements for which _exp-predicate_ is `true` are
eliminated.

`clean` works like link:#filter[filter] with a negated predicate.

[source,newlisp]
--------------------------------------------------------------
(clean symbol? '(1 2 d 4 f g 5 h))   → (1 2 4 5)

(filter symbol? '(1 2 d 4 f g 5 h))  → (d f g h)

(define (big? x) (> x 5))        → (lambda (x) (> x 5))

(clean big? '(1 10 3 6 4 5 11))  → (1 3 4 5)

(clean <= '(3 4 -6 0 2 -3 0))  → (3 4 2)

(clean (curry match '(a *)) '((a 10) (b 5) (a 3) (c 8) (a 9)))
→  ((b 5) (c 8))
--------------------------------------------------------------

The predicate may be a built-in predicate or a user-defined function or
lambda expression.

For cleaning numbers from one list using numbers from another, use
link:#difference[difference] or link:#intersect[intersect] (with the
list mode option).

See also the related function link:#index[index], which returns the
indices of the remaining elements, and link:#filter[filter], which
returns all elements for which a predicate returns true.

function::close[]

*syntax:* (close _int-file_)

Closes the file specified by the file handle in _int-file_. The handle
would have been obtained from a previous link:#open[open] operation. If
successful, `close` returns `true`; otherwise `nil` is returned.

[source,newlisp]
------------------------
(close (device))  → true
(close 7)         → true
(close aHandle)   → true
------------------------

Note that using `close` on link:#device[device] automatically resets it
to 0 (zero, the screen device).

function::command-event[]

*syntax:* (command-event _sym-event-handler_ | _func-event-handler_)

Specifies a user defined function for pre-processing the newLISP
command-line before it gets evaluated. This can be used to write
customized interactive newLISP shells and to transform HTTP requests
when running in server mode.

`command-event` takes either a symbol of a user-defined function or a
lambda function. The event-handler function must return a string or the
command-line will be passed untranslated to newLISP.

To only force a prompt, the function should return the empty string
`""`.

The following example makes the newLISP shell work like a normal Unix
shell when the command starts with a letter. But starting the line with
an open parenthesis or a space initiates a newLISP evaluation.

[source,newlisp]
--------------------------------------------------------
(command-event (fn (s)
    (if (starts-with s "[a-zA-Z]" 0) (append "!" s) s)))
--------------------------------------------------------

See also the related link:#prompt-event[prompt-event] which can be used
for further customizing interactive mode by modifying the newLISP
prompt.

The following program can be used either stand-alone or included in
newLISP's `init.lsp` startup file:

[source,newlisp]
--------------------------------------------------------------
#!/usr/bin/newlisp

; set the prompt to the current directory name
(prompt-event (fn (ctx) (append (real-path) "> ")))

; pre-process the command-line
(command-event (fn (s)
    (if
        (starts-with s "cd")
        (string " " (true? (change-dir (last (parse s " ")))))

        (starts-with s "[a-zA-Z]" 0)
        (append "!" s)

        true s)))
--------------------------------------------------------------

In the definition of the command-line translation function the Unix
command `cd` gets a special treatment, to make sure that the directory
is changed for newLISP process too. This way when shelling out with `!`
and coming back, newLISP will maintain the changed directory.

Command lines for newLISP must start either with a space or an opening
parenthesis. Unix commands must start at the beginning of the line.

When newLISP is running in server mode either using the `-c` or `-http`
option, it receives HTTP requests similar to the following:

---------------
GET /index.html
---------------

Or if a query is involved:

-----------------------------------------
GET /index.cgi?userid=joe&password=secret
-----------------------------------------

A function specified by `command-event` could filter and transform these
request lines, e.g.: discovering all queries trying to perform CGI using
a file ending in `.exe`. Such a request would be translated into a
request for an error page:

[source,newlisp]
--------------------------------------------------------
;; httpd-conf.lsp
;;
;; filter and translate HTTP requests for newLISP
;; -c or -http server modes
;; reject query commands using CGI with .exe files

(command-event (fn (s)
    (local (request)
        (if (find "?" s) ; is this a query
            (begin
                (set 'request (first (parse s "?")))
                ; discover illegal extension in queries
                (if (ends-with request ".exe")
                    (set 'request "GET /errorpage.html")
                    (set 'request s)))
            (set 'request s))
        request)
))
--------------------------------------------------------

When starting the server mode with
`newlisp httpd-conf.lsp -c -d80 -w ./httpdoc` newLISP will load the
definition for `command-event` for filtering incoming requests, and the
query:

----------------
GET /cmd.exe?dir
----------------

Would be translated into:

-------------------
GET /errorpage.html
-------------------

The example shows a technique frequently used in the past by spammers on
Win32 based, bad configured web servers to gain control over servers.

`httpd-conf.lsp` files can easily be debugged loading the file into an
interactive newLISP session and entering the HTTP requests manually.
newLISP will translate the command line and dispatch it to the built-in
web server. The server output will appear in the shell window.

Note, that the command line length as well as the line length in HTTP
headers is limited to 512 characters for newLISP.

function::cond[]

*syntax:* (cond (_exp-condition-1_ _body-1_) [(_exp-condition-2_ _body-2_) ... ])

Like `if`, `cond` conditionally evaluates the expressions within its
body. The _exp-condition_s are evaluated in turn, until some
_exp-condition-i_ is found that evaluates to anything other than `nil`
or an empty list `()`. The result of evaluating _body-i_ is then
returned as the result of the entire _cond-expression_. If all
conditions evaluate to `nil` or an empty list, _cond_ returns the value
of the last _cond-expression_.

[source,newlisp]
----------------------------
(define (classify x)
  (cond
    ((< x 0) "negative")
    ((< x 10) "small")
    ((< x 20) "medium")
    ((>= x 30) "big")))

(classify 15)   → "medium"
(classify 22)   → "nil"
(classify 100)  → "big"
(classify -10)  → "negative"
----------------------------

When a _body-n_ is missing, the value of the last _cond-expression_
evaluated is returned. If no condition evaluates to `true`, the value of
the last conditional expression is returned (i.e., `nil` or an empty
list).

[source,newlisp]
---------------------
(cond ((+ 3 4)))  → 7
---------------------

When used with multiple arguments, the function link:#if[if] behaves
like `cond`, except it does not need extra parentheses to enclose the
condition-body pair of expressions.

function::cons[]

*syntax:* (cons _exp-1_ _exp-2_)

If _exp-2_ evaluates to a list, then a list is returned with the result
of evaluating _exp-1_ inserted as the first element. If _exp-2_evaluates
to anything other than a list, the results of evaluating _exp-1_ and
_exp-2_ are returned in a list. Note that there is no _dotted pair_ in
newLISP: _cons_ing two atoms constructs a list, not a dotted pair.

[source,newlisp]
-------------------------------------
(cons 'a 'b)            → (a b)
(cons 'a '(b c))        → (a b c)
(cons (+ 3 4) (* 5 5))  → (7 25)
(cons '(1 2) '(3 4))    → ((1 2) 3 4)
(cons nil 1)            → (nil 1)
(cons 1 nil)            → (1 nil)
(cons 1)                → (1)
(cons)          → ()
-------------------------------------

Unlike other Lisps that return `(s)` as the result of the expression
`(cons 's nil)`, newLISP's `cons` returns `(s nil)`. In newLISP, `nil`
is a Boolean value and is not equivalent to an empty list, and a newLISP
cell holds only one value.

`cons` behaves like the inverse operation of link:#first[first] and
link:#rest[rest] (or link:#first[first] and link:#last[last] if the list
is a pair):

[source,newlisp]
--------------------------------------------------
(cons (first '(a b c)) (rest '(a b c)))  → (a b c)

(cons (first '(x y)) (last '(x y)))      → (x y)
--------------------------------------------------

function::constant[!]

*syntax:* (constant _sym-1_ _exp-1_ [_sym-2_ _exp-2_] ...)

Identical to link:#set[set] in functionality, `constant` further
protects the symbols from subsequent modification. A symbol set with
`constant` can only be modified using the `constant` function again.
When an attempt is made to modify the contents of a symbol protected
with `constant`, newLISP generates an error message. Only symbols from
the current context can be used with `constant`. This prevents the
overwriting of symbols that have been protected in their home context.
The last _exp-n_ initializer is always optional.

Symbols initialized with link:#set[set], link:#define[define], or
link:#define-macro[define-macro] can still be protected by using the
`constant` function:

[source,newlisp]
----------------------------------------------
(constant 'aVar 123)  → 123
(set 'aVar 999)
ERR: symbol is protected in function set: aVar

(define (double x) (+ x x))

(constant 'double)

;; equivalent to

(constant 'double (fn (x) (+ x x)))
----------------------------------------------

The first example defines a constant, `aVar`, which can only be changed
by using another `constant` statement. The second example protects
`double` from being changed (except by `constant`). Because a function
definition in newLISP is equivalent to an assignment of a lambda
function, both steps can be collapsed into one, as shown in the last
statement line. This could be an important technique for avoiding
protection errors when a file is loaded multiple times.

The last value to be assigned can be omitted. `constant` returns the
contents of the last symbol set and protected.

Built-in functions can be assigned to symbols or to the names of other
built-in functions, effectively redefining them as different functions.
There is no performance loss when renaming functions.

[source,newlisp]
--------------------------------------------
(constant 'squareroot sqrt)  → sqrt <406C2E>
(constant '+ add)            → add <4068A6>
--------------------------------------------

`squareroot` will behave like `sqrt`. The `+` (plus sign) is redefined
to use the mixed type floating point mode of `add`. The hexadecimal
number displayed in the result is the binary address of the built-in
function and varies on different platforms and OSes.

function::context[]

*syntax:* (context [_sym-context_]) +
*syntax:* (context _sym-context_ _str | sym_ [_exp-value_])

In the first syntax, `context` is used to switch to a different context
namespace. Subsequent link:#load[load]s of newLISP source or functions
like link:#eval-string[eval-string] and link:#sym[sym] will put newly
created symbols and function definitions in the new context.

If the context still needs to be created, the symbol for the new context
should be specified. When no argument is passed to `context`, then the
symbol for the current context is returned.

Because contexts evaluate to themselves, a quote is not necessary to
switch to a different context if that context already exists.

[source,newlisp]
-----------------------------------------------------------------------
(context 'GRAPH)          ; create / switch context GRAPH

(define (foo-draw x y z)  ; function resides in GRAPH
  (…))

(set 'var 12345)
(symbols)  → (foo-draw var)  ; GRAPH has now two symbols

(context MAIN)               ; switch back to MAIN (quote not required)

(print GRAPH:var) → 12345    ; contents of symbol in GRAPH

(GRAPH:foo-draw 10 20 30)    ; execute function in GRAPH
(set 'GRAPH:var 6789)        ; assign to a symbol in GRAPH
-----------------------------------------------------------------------

If a context symbol is referred to before the context exists, the
context will be created implicitly.

[source,newlisp]
-----------------------------------------------------------------------
(set 'person:age 0)       ; no need to create context first
(set 'person:address "")  ; useful for quickly defining data structures
-----------------------------------------------------------------------

Contexts can be copied:

[source,newlisp]
---------------------------------
(new person 'JohnDoe)  →  JohnDoe

(set 'JohnDoe:age 99)
---------------------------------

Contexts can be referred to by a variable:

[source,newlisp]
------------------------------------
(set 'human JohnDoe)

human:age  → 99

(set 'human:address "1 Main Street")

JohnDoe:address  → "1 Main Street"
------------------------------------

An evaluated context (no quote) can be given as an argument:

[source,newlisp]
-----------------------
> (context 'FOO)
FOO
FOO> (context MAIN)
MAIN
> (set 'old FOO)
FOO
> (context 'BAR)
BAR
BAR> (context MAIN:old)
FOO
FOO>
-----------------------

If an identifier with the same symbol already exists, it is redefined to
be a context.

Symbols within the current context are referred to simply by their
names, as are built-in functions and special symbols like `nil` and
`true`. Symbols outside the current context are referenced by prefixing
the symbol name with the context name and a `:` (colon). To quote a
symbol in a different context, prefix the context name with a `'`
(single quote).

Within a given context, symbols may be created with the same name as
built-in functions or context symbols in MAIN. This overwrites the
symbols in MAIN when they are prefixed with a context:

[source,newlisp]
---------------------
(context 'CTX)
(define (CTX:new var)
    (…))

(context 'MAIN)
---------------------

`CTX:new` will overwrite new in MAIN.

In the second syntax, `context` can be used to create symbols in a
namespace. Note that this should not be used for creating hashes or
dictionaries. For a shorter, more convenient method to use namespaces as
hash-like dictionaries, see the chapter link:#hash[Hash functions and
dictionaries].

[source,newlisp]
---------------------------------------
;; create a symbol and store data in it
(context 'Ctx "abc" 123)   → 123
(context 'Ctx 'xyz 999)    → 999

;; retrieve contents from  symbol
(context 'Ctx "abc")       → 123
(context 'Ctx 'xyz)        → 999
Ctx:abc                    → 123
Ctx:xyz                    → 999
---------------------------------------

The first three statements create a symbol and store a value of any data
type inside. The first statement also creates the context named `Ctx`.
When a symbol is specified for the name, the name is taken from the
symbol and creates a symbol with the same name in the context `Ctx`.

Symbols can contain spaces or any other special characters not typically
allowed in newLISP symbols being used as variable names. This second
syntax of `context` only creates the new symbol and returns the value
contained in it. It does not switch to the new namespace.

function::context?[]

*syntax:* (context? _exp_) +
*syntax:* (context? _exp_ _str-sym_)

In the first syntax, _context?_ is a predicate that returns `true` only
if _exp_ evaluates to a context; otherwise, it returns `nil`.

[source,newlisp]
-------------------------------------------------------
(context? MAIN)  → true
(set 'x 123)
(context? x)     → nil

(set 'FOO:q "hola")  → "hola"
(set 'ctx FOO)
(context? ctx)       → true  ; ctx contains context foo
-------------------------------------------------------

The second syntax checks for the existence of a symbol in a context. The
symbol is specified by its name string in _str-sym_.

[source,newlisp]
--------------------------
(context? FOO "q")  → true
(context? FOO "p")  → nil
--------------------------

Use link:#context[context] to change and create namespaces and to create
hash symbols in contexts.

function::copy[]

*syntax:* (copy _exp_)

Make a copy from evaluating expression in _exp_. Some built-in functions
are link:#destructice[destructive], changing the original contents of a
list, array or string they are working on. With `copy` their behavior
can be made non-destructive.

[source,newlisp]
---------------------------------------
(set 'aList '(a b c d e f))

(replace 'c (copy aList)) → (a b d e f)

aList → (a b c d e f)

(set 'str "newLISP") → "newLISP"

(rotate (copy str)) → "PnewLIS"

str → "newLISP"
---------------------------------------

Using `copy` the functions link:#replace[replace] and
link:#rotate[rotate] are prevented from changing the data. A modified
version of the data is returned.

function::copy-file[]

*syntax:* (copy-file _str-from-name_ _str-to-name_)

Copies a file from a path-filename given in _str-from-name_ to a
path-filename given in _str-to-name_. Returns `true` if the copy was
successful or `nil`, if the copy was unsuccessful.

[source,newlisp]
-------------------------------------------------------
(copy-file "/home/me/newlisp/data.lsp" "/tmp/data.lsp")
-------------------------------------------------------

function::corr[]

*syntax:* (corr _list-vector-X_ _list-vector-Y_)

Calculates the _Pearson_ product-moment correlation coefficient as a
measure of the linear relationship between the two variables in
_list-vector-X_ and _list-vector-Y_. Both lists must be of same length.

`corr` returns a list containing the following values:

[cols="1<,10<",width="30%",options="header",]
|=======================================================
|name |description
|r |Correlation coefficient
|b0 |Regression coefficient offset
|b1 |Regression coefficient slope
|t |t - statistic for significance testing
|df |Degrees of freedom for t
|p |Two tailed probability of t under the null hyothesis
|=======================================================

[source,newlisp]
-------------------------------------------------------------------------
(set 'study-time '(90 100 130 150 180 200 220 300 350 400))
(set 'test-errors '(25 28 20 20 15 12 13 10 8 6))

(corr study-time test-errors) → (-0.926 29.241 -0.064 -6.944 8 0.0001190)
-------------------------------------------------------------------------

The negative correlation of `-0.926` between study time and test errors
is highly signficant with a two-tailed `p` of about `0.0001` under the
null hypothesis.

The regression coefficients `b0 = 29.241` and `b1 = -0.064` can be used
to estimate values of the Y variable (test errors) from values in X
(study time) using the equation `Y = b0 + b1 * X`.

function::cos[]

*syntax:* (cos _num-radians_)

Calculates the cosine of _num-radians_ and returns the result.

[source,newlisp]
------------------------------------------
(cos 1)                     → 0.5403023059
(set 'pi (mul 2 (acos 0)))  → 3.141592654
(cos pi)                    → -1
------------------------------------------

function::cosh[]

*syntax:* (cosh _num-radians_)

Calculates the hyperbolic cosine of _num-radians_. The hyperbolic cosine
is defined mathematically as: _(exp (x) + exp (-x)) / 2_. An overflow to
`inf` may occur if _num-radians_ is too large.

[source,newlisp]
---------------------------------------------------
(cosh 1)     → 1.543080635
(cosh 10)    → 11013.23292
(cosh 1000)  → inf
(= (cosh 1) (div (add (exp 1) (exp -1)) 2))  → true
---------------------------------------------------

function::count[]

*syntax:* (count _list-1_ _list-2_)

Counts elements of _list-1_ in _list-2_ and returns a list of those
counts.

[source,newlisp]
--------------------------------------------------
(count '(1 2 3) '(3 2 1 4 2 3 1 1 2 2))  → (3 4 2)
(count '(z a) '(z d z b a z y a))        → (3 2)

(set 'lst (explode (read-file "myFile.txt")))
(set 'letter-counts (count (unique lst) lst))
--------------------------------------------------

The second example counts all occurrences of different letters in
`myFile.txt`.

The first list in `count`, which specifies the items to be counted in
the second list, should be unique. For items that are not unique, only
the first instance will carry a count; all other instances will display
`0` (zero).

function::cpymem[]

*syntax:* (cpymem _int-from-address_ _int-to-address_ _int-bytes_)

Copies _int-bytes_ of memory from _int-from-address_ to
_int-to-address_. This function can be used for direct memory
writing/reading or for hacking newLISP internals (e.g., type bits in
newLISP cells, or building functions with binary executable code on the
fly).

Note that this function should only be used when familiar with newLISP
internals. `cpymem` can crash the system or make it unstable if used
incorrectly.

[source,newlisp]
-----------------------------------------------
(cpymem (pack "c c" 0 32) (last (dump 'sym)) 2)

(set 's "0123456789")

(cpymem "xxx" (+ (address s) 5) 3)

s  → "01234xxx89")
-----------------------------------------------

The first example would remove the protection bit in symbol `sym`. The
second example copies a string directly into a string variable.

The following example creates a new function from scratch, runs a piece
of binary code, and adds up two numbers. This assembly language snippet
shows the x86 (Intel CPU) code to add up two numbers and return the
result:

[source,nasm]
-------------------------------------
 55       push ebp
 8B EC    mov  ebp, esp
 8B 45 08 mov  eax, [ebp+08]
 03 45 0C add  eax, [ebp+0c]
 5D       pop  ebp
 C3       ret

 ; for Win32/stdcall change last line
 C2 08 00 ret
-------------------------------------

The binary representation is attached to a new function created in
newLISP:

[source,newlisp]
---------------------------------------------------------------------------
(set 'foo-code (append
     (pack "bbbbbbbbbb" 0x55 0x8B 0xEC 0x8B 0x45 0x08 0x03 0x45 0x0C 0x5D)
     (if (= ostype "Win32") (pack "bbb" 0xC2 0x08 0x00) (pack "b" 0xC3))))
(set 'foo print)
(cpymem (pack "ld" (if (= ostype "Win32") 2312 1288)) (first (dump foo)) 4)
(cpymem (pack "ld" (address foo-code)) (+ (first (dump foo)) 12) 4)
(set 'foo-name "foo")
(cpymem (pack "ld" foo-name) (+ (first (dump foo)) 8) 4)

(foo 3 4)  →  7
---------------------------------------------------------------------------

The last example will not work on all hardware platforms and OSs.

Use the link:#dump[dump] function to retrieve binary addresses and the
contents from newLISP cells.

function::crc32[]

*syntax:* (crc32 _str-data_)

Calculates a running 32-bit CRC (Circular Redundancy Check) sum from the
buffer in _str-data_, starting with a CRC of `0xffffffff` for the first
byte. `crc32` uses an algorithm published by
http://www.w3.org[www.w3.org].

[source,newlisp]
--------------------------------------------------
(crc32 "abcdefghijklmnopqrstuvwxyz")  → 1277644989
--------------------------------------------------

`crc32` is often used to verify data integrity in unsafe data
transmissions.

function::crit-chi2[]

*syntax:* (crit-chi2 _num-probability_ _int-df_)

Calculates the critical minimum _Chi²_ for a given confidence
probability _num-probability_ under the null hypothesis and the degrees
of freedom in _int-df_ for testing the significance of a statistical
null hypothesis.

Note that versions prior to 10.2.0 took _(1.0 - p)_ for the probability
instead of _p_.

[source,newlisp]
---------------------------------
(crit-chi2 0.01 4)  → 13.27670443
---------------------------------

See also the inverse function link:#prob-chi2[prob-chi2].

function::crit-f[]

*syntax:* (crit-f _num-probability_ _int-df1_ _int-df2_)

Calculates the critical minimum _F_ for a given confidence probability
_num-probability_ under the null hypothesis and the degrees of freedmom
given in _int-df1_ and _int-df2_ for testing the significance of a
statistical null hypothesis using the _F-test_.

[source,newlisp]
----------------------------------
(crit-f 0.05 10 12)  → 2.753386727
----------------------------------

See also the inverse function link:#prob-f[prob-f].

function::crit-t[]

*syntax:* (crit-t _num-probability_ _int-df_)

Calculates the critical minimum _Student's t_ for a given confidence
probability _num-probability_ under the null hypothesis and the degrees
of freedom in _int-df_ for testing the significance of a statistical
null hypothesis.

[source,newlisp]
-------------------------------
(crit-t 0.05 14)  → 1.761310142
-------------------------------

See also the inverse function link:#prob-t[prob-t].

function::crit-z[]

*syntax:* (crit-z _num-probability_)

Calculates the critical normal distributed Z value of a given cumulated
probability _num-probability_ for testing of statistical significance
and confidence intervals.

[source,newlisp]
-----------------------------
(crit-z 0.999)  → 3.090232372
-----------------------------

See also the inverse function link:#prob-z[prob-z].

function::current-line[]

*syntax:* (current-line)

Retrieves the contents of the last link:#read-line[read-line] operation.
`current-line`'s contents are also implicitly used when
link:#write-line[write-line] is called without a string parameter.

The following source shows the typical code pattern for creating a Unix
command-line filter:

[source,newlisp]
-----------------------------------------
#!/usr/bin/newlisp

(set 'inFile (open (main-args 2) "read"))
(while (read-line inFile)
  (if (starts-with (current-line) ";;")
    (write-line)))
(exit)
-----------------------------------------

The program is invoked:

[source,newlisp]
-------------------
./filter myfile.lsp
-------------------

This displays all comment lines starting with `;;` from a file given as
a command-line argument when invoking the script `filter`.

function::curry[]

*syntax:* (curry _func_ _exp_)

Transforms _func_ from a function _f(x, y)_ that takes two arguments
into a function _fx(y)_ that takes a single argument. `curry` works like
a macro in that it does not evaluate its arguments. Instead, they are
evaluated during the application of _func_.

[source,newlisp]
---------------------------------------------------------------
(set 'f (curry + 10))  → (lambda ($x) (+ 10 $x))

(f 7)  → 17

(filter (curry match '(a *)) '((a 10) (b 5) (a 3) (c 8) (a 9)))
→  ((a 10) (a 3) (a 9))

(clean (curry match '(a *)) '((a 10) (b 5) (a 3) (c 8) (a 9)))
→  ((b 5) (c 8))

(map (curry list 'x) (sequence 1 5))
→  ((x 1) (x 2) (x 3) (x 4) (x 5))
---------------------------------------------------------------

`curry` can be used on all functions taking two arguments.

function::date[utf8]

*syntax:* (date) +
*syntax:* (date _int-secs_ [_int-offset_]) +
*syntax:* (date _int-secs_ _int-offset_ _str-format_)

The first syntax returns the local time zone's current date and time as
a string representation. If _int-secs_ is out of range, `nil` is
returned.

In the second syntax, `date` translates the number of seconds in
_int-secs_ into its date/time string representation for the local time
zone. The number in _int-secs_ is usually retrieved from the system
using link:#date-value[date-value]. Optionally, a time-zone offset (in
minutes) can be specified in _int-offset_, which is added or subtracted
before conversion of _int-sec_ to a string. If _int-secs_ is out of
range or an invalid _str-format_ is specified, an empty string `""` is
returned.

[source,newlisp]
-----------------------------------------------------------------------
(date)                   → "Fri Oct 29 09:56:58 2004"

(date (date-value))      → "Sat May 20 11:37:15 2006"
(date (date-value) 300)  → "Sat May 20 16:37:19 2006"  ; 5 hours offset
(date 0)                 → "Wed Dec 31 16:00:00 1969"
(date 0 (now 0 -2))      → "Thu Jan  1 00:00:00 1970"  ; Unix epoch
-----------------------------------------------------------------------

The way the date and time are presented in a string depends on the
underlying operating system.

The second example would show 1-1-1970 0:0 when in the Greenwich time
zone, but it displays a time lag of 8 hours when in Pacific Standard
Time (PST). `date` assumes the _int-secs_ given are in Coordinated
Universal Time (UTC; formerly Greenwich Mean Time (GMT)) and converts it
according to the local time-zone.

The third syntax makes the date string fully customizable by using a
format specified in _str-format_. This allows the day and month names to
be translated into results appropriate for the current locale:

[source,newlisp]
---------------------------------------------------------------
(set-locale "german") → "de_DE"

; on Linux - no leading 0 on day with %-d
(date (date-value) 0 "%A %-d. %B %Y")  → "Montag  7. März 2005"

(set-locale "C")  ; default POSIX

(date (date-value) 0 "%A %B %d %Y")    → "Monday March 07 2005"

; suppressing leading 0 on Win32 using #
(date (date-value) 0 "%a %#d %b %Y")   → "Mon 7 Mar 2005"

(set-locale "german")

(date (date-value) 0 "%x") → "07.03.2005"   ; day month year

(set-locale "C")

(date (date-value) 0 "%x") → "03/07/05"     ; month day year
---------------------------------------------------------------

The following table summarizes all format specifiers available on both
Win32 and Linux/Unix platforms. More format options are available on
Linux/Unix. For details, consult the manual page for the C function
`strftime()` of the individual platform's C library.

[cols="1<,10<",width="75%",options="header",]
|=======================================================================
|format |description
|%a |abbreviated weekday name according to the current locale

|%A |full weekday name according to the current locale

|%b |abbreviated month name according to the current locale

|%B |full month name according to the current locale

|%c |preferred date and time representation for the current locale

|%d |day of the month as a decimal number (range 01–31)

|%H |hour as a decimal number using a 24-hour clock (range 00–23)

|%I |hour as a decimal number using a 12-hour clock (range 01–12)

|%j |day of the year as a decimal number (range 001–366)

|%m |month as a decimal number (range 01–12)

|%M |minute as a decimal number

|%p |either 'am' or 'pm' according to the given time value or the
corresponding strings for the current locale

|%S |second as a decimal number 0–61 (60 and 61 to account for
occasional leap seconds)

|%U |week number of the current year as a decimal number, starting with
the first Sunday as the first day of the first week

|%w |day of the week as a decimal, Sunday being 0

|%W |week number of the current year as a decimal number, starting with
the first Monday as the first day of the first week

|%x |preferred date representation for the current locale without the
time

|%X |preferred time representation for the current locale without the
date

|%y |year as a decimal number without a century (range 00–99)

|%Y |year as a decimal number including the century

|%z |time zone or name or abbreviation (same as %Z on Win32, different
on Unix)

|%Z |time zone or name or abbreviation (same as %z on Win32, different
on Unix)

|%% |a literal '%' character
|=======================================================================

Leading zeroes in the display of decimal day numbers can be suppressed
using `"%-d"` on Linux and FreeBSD and using `"%e"` on OpenBSD,
SunOS/Solaris and Mac OS X. On Win32 use `"%#d"`.

See also link:#date-value[date-value], link:#date-list[date-list],
link:#date-parse[date-parse], link:#time-of-day[time-of-day],
link:#time[time], and link:#now[now].

function::date-list[]

*syntax:* (date-list _int-seconds_ [_int-index_])

Returns a list of year, month, date, hours, minutes, seconds, day of
year and day of week from a time value given in seconds after January
1st, 1970 00:00:00. The date and time values aren given as UTC, which
may differ from the local timezone.

The week-day value ranges from 1 to 7 for Monday thru Sunday.

[source,newlisp]
---------------------------------------------------------------
(date-list 1282479244)      → (2010 8 22 12 14 4 234 1)
(date-list 1282479244 0)    → 2010 ; year
(date-list 1282479244 -2)   → 234  ; day of year

(apply date-value (date-list 1282479244)) → 1282479244

(date-list 0)   → (1970 1 1 0 0 0 1 4) ; Thursday 1st, Jan 1900
---------------------------------------------------------------

A second optional _int-index_ parameter can be used to return a specific
member of the list.

`date-list` is the inverse operation of link:#date-value[date-value].

function::date-parse[]

*syntax:* (date-parse _str-date_ _str-format_)

Parses a date from a text string in _str-date_ using a format as defined
in _str-format_, which uses the same formatting rules found in
link:#date[date]. The function `date-parse` returns the number of UTC
seconds passed since January 1st, 1970 UTC starting with 0 and up to
2147472000 for a date of January 19th, 2038. For dates before January
1st 1970, negative values are returned down to a value of -2147472000
for December 14th, 1901.

This function is not available on Win32 platforms. The function was
named `parse-date` in previous versions. The old form is deprecated.

[source,newlisp]
-------------------------------------------------------------------------
(date-parse "2007.1.3" "%Y.%m.%d")    → 1167782400
(date-parse "January 10, 07" "%B %d, %y")    → 1168387200

; output of date-parse as input value to date-list produces the same date

(date-list (date-parse "2010.10.18 7:00" "%Y.%m.%d %H:%M"))
→ (2010 10 18 7 0 0 290 1)
-------------------------------------------------------------------------

See the link:#date[date] function for all possible format descriptors.

function::date-value[]

*syntax:* (date-value _int-year_ _int-month_ _int-day_ [_int-hour_ _int-min_ _int-sec_]) +
*syntax:* (date-value)

In the first syntax, `date-value` returns the time in seconds since
1970-1-1 00:00:00 for a given date and time. The parameters for the
hour, minutes, and seconds are optional. The time is assumed to be
Coordinated Universal Time (UTC), not adjusted for the current time
zone.

In the second syntax, `date-value` returns the time value in seconds for
the current time.

[source,newlisp]
-------------------------------------------------------------
(date-value 2002 2 28)       → 1014854400
(date-value 1970 1 1 0 0 0)  → 0

(date (apply date-value (now)))  → "Wed May 24 10:02:47 2006"
(date (date-value))              → "Wed May 24 10:02:47 2006"
(date)                           → "Wed May 24 10:02:47 2006"
-------------------------------------------------------------

The function link:#date-list[date-list] can be used to transform a
`date-value` back into a list:

[source,newlisp]
------------------------------------------------------
(date-list 1014854400)  → (2002 2 28 0 0 0)
(apply date-value (date-list 1014854400)) → 1014854400
------------------------------------------------------

See also link:#date[date], link:#date-list[date-list],
link:#date-parse[date-parse], link:#time-of-day[time-of-day],
link:#time[time], and link:#now[now].

function::debug[]

*syntax:* (debug _func_)

Calls link:#trace[trace] and begins evaluating the user-defined function
in _func_. `debug` is a shortcut for executing `(trace true)`, then
entering the function to be debugged.

[source,newlisp]
--------------------------
;; instead of doing
(trace true)
(my-func a b c)
(trace nil)

;; use debug as a shortcut
(debug (my-func a b c))
--------------------------

When in `debug` or link:#trace[trace] mode, error messages will be
printed. The function causing the exception will return either `0` or
`nil` and processing will continue. This way, variables and the current
state of the program can still be inspected while debugging.

See also the link:#trace[trace] function.

function::dec[!]

*syntax:* (dec _place_ [_num_])

The number in _place_ is decremented by `1.0` or the optional number
_num_ and returned. `dec` performs float arithmetic and converts integer
numbers passed into floating point type.

_place_ is either a symbol or a place in a list structure holding a
number, or a number returned by an expression.

[source,newlisp]
--------------------
(set x 10)    → 10
(dec x)       → 9
x             → 9
(dec x 0.25)  → 8.75
x             → 8.75
--------------------

If the symbol for _place_ contains `nil`, it is treated as if containing
`0.0`:

[source,newlisp]
---------------------
z             → nil
(dec z)       → -1

(set z nil)
(dec z 0.01)  → -0.01
---------------------

Places in a list structure or a number returned by another expression
can be updated too:

[source,newlisp]
---------------------
(set 'l '(1 2 3 4))

(dec (l 3) 0.1) → 3.9

(dec (first l)) → 0

l → (0 2 3 3.9)

(dec (+ 3 4)) → 6
---------------------

Use the link:#deci[--] function to decrement in integer mode. Use the
link:#inc[inc] function to increment numbers floating point mode.

function::def-new[]

*syntax:* (def-new _sym-source_ [_sym-target_])

This function works similarly to link:#new[new], but it only creates a
copy of one symbol and its contents from the symbol in _sym-source_.
When _sym-target_ is not given, a symbol with the same name is created
in the current context. All symbols referenced inside _sym-source_ will
be translated into symbol references into the current context, which
must not be MAIN.

If an argument is present in _sym-target_, the copy will be made into a
symbol and context as referenced by the symbol in _sym-target_. In
addition to allowing renaming of the function while copying, this also
enables the copy to be placed in a different context. All symbol
references in _sym-source_ with the same context as _sym-source_ will be
translated into symbol references of the target context.

`def-new` returns the symbol created:

[source,newlisp]
-------------------------------
> (set 'foo:var '(foo:x foo:y))
(foo:x foo:y)

> (def-new 'foo:var 'ct:myvar)
ct:myvar

> ct:myvar
(ct:x ct:y)

> (context 'K)

K> (def-new 'foo:var)
var

K> var
(x y)
-------------------------------

The following example shows how a statically scoped function can be
created by moving it its own namespace:

[source,newlisp]
-----------------------------------------
> (set 'temp (lambda (x) (+ x x)))
(lambda (x) (+ x x))
> (def-new 'temp 'double:double)
double:double
> (double 10)
20
> double:double
(lambda (double:x) (+ double:x double:x))
-----------------------------------------

The following definition of `def-static` can be used to create functions
living in their own lexically protected name-space:

[source,newlisp]
--------------------------------
(define (def-static s body)
      (def-new 'body (sym s s)))

(def-static 'acc (lambda (x)
          (inc sum x)))

> (acc 1)
1
> (acc 1)
2
> (acc 8)
10
>
--------------------------------

The function `def-new` can also be used to configure contexts or context
objects in a more granular fashion than is possible with link:#new[new],
which copies a whole context.

function::default[]

*syntax:* (default _context_)

Return the contents of the default functor in _context_.

[source,newlisp]
------------------------
(define Foo:Foo 123)

(default Foo) → 123

(setf (default Foo) 456)
(set 'ctx Foo)

(default ctx) → 456
Foo:Foo       → 456
------------------------

In many situations newLISP defaults automatically to the default functor
when seeing a context name. In circumstances where this is not the case,
the `default` function can be used.

function::define[!]

*syntax:* (define (_sym-name_ [_sym-param-1_ ... ]) [_body-1_ ... ]) +
*syntax:* (define (_sym-name_ [(_sym-param-1_ _exp-default_) ... ]) [_body-1_ ... ]) +
*syntax:* (define _sym-name_ _exp_)

Defines the new function _sym-name_, with optional parameters
_sym-param-1_—. `define` is equivalent to assigning a lambda expression
to _sym-name_. When calling a defined function, all arguments are
evaluated and assigned to the variables in _sym-param-1_—, then the
_body-1—_ expressions are evaluated. When a function is defined, the
lambda expression bound to _sym-name_ is returned.

All parameters defined are optional. When a user-defined function is
called without arguments, those parameters assume the value `nil`. If
those parameters have a default value specified in _exp-default_, they
assume that value.

The return value of `define` is the assigned _lambda_ expression. When
calling a user-defined function, the return value is the last expression
evaluated in the function body.

[source,newlisp]
-----------------------------------------------------
(define (area x y) (* x y))  → (lambda (x y) (* x y))
(area 2 3)                   → 6
-----------------------------------------------------

As an alternative, `area` could be defined as a function without using
`define`.

[source,newlisp]
---------------------------------
(set 'area (lambda (x y) (* x y))
---------------------------------

_lambda_ or _fn_ expressions may be used by themselves as _anonymous_
functions without being defined as a symbol:

[source,newlisp]
----------------------------------
((lambda ( x y) (* x y)) 2 3)  → 6
((fn ( x y) (* x y)) 2 3)      → 6
----------------------------------

`fn` is just a shorter form of writing `lambda`.

Parameters can have default values specified:

[source,newlisp]
-------------------------
(define (foo (a 1) (b 2))
  (list a b))

(foo)      → (1 2)
(foo 3)    → (3 2)
(foo 3 4)  → (3 4)
-------------------------

Expressions in _exp-default_ are evaluated in the function's current
environment.

[source,newlisp]
----------------------------------
(define (foo (a 10) (b (div a 2)))
  (list a b))

(foo)      → (10 5)
(foo 30)   → (30 15)
(foo 3 4)  → (3 4)
----------------------------------

The second version of `define` works like the link:#set[set] function.

[source,newlisp]
-------------------------------------
(define x 123)  →   123
;; is equivalent to
(set 'x 123)    →   123

(define area (lambda ( x y) (* x y)))
;; is equivalent to
(set 'area (lambda ( x y) (* x y)))
;; is equivalent to
(define (area x y) (* x y))
-------------------------------------

Trying to redefine a protected symbol will cause an error message.

function::define-macro[]

*syntax:* (define-macro (_sym-name_ [_sym-param-1_ ... ]) _body_) +
*syntax:* (define-macro (_sym-name_ [(_sym-param-1_ _exp-default_) ... ]) _body_)

Functions defined using `define-macro` are called _fexpr_s in other
LISPs as they don't do variable expansion. In newLISP they are still
called macros, because they are written with the same purpose of
creating special syntax forms with non-standard evaluation patterns of
arguments. Functions created using `define-macro` can be combined with
template expansion using link:#expand[expand] or link:#letex[letex].

Defines the new fexpr _sym-name_, with optional arguments _sym-param-1_.
`define-macro` is equivalent to assigning a lambda-macro expression to a
symbol. When a `define-macro` function is called, unevaluated arguments
are assigned to the variables in _sym-param-1 ..._. Then the _body_
expressions are evaluated. When evaluating the `define-macro` function,
the lambda-macro expression is returned.

[source,newlisp]
-------------------------------------------------
(define-macro (my-setq p1 p2) (set p1 (eval p2)))
→ (lambda-macro (p1 p2) (set p1 (eval p2)))

(my-setq x 123)  → 123
x                → 123
-------------------------------------------------

New functions can be created to behave like built-in functions that
delay the evaluation of certain arguments. Because fexprs can access the
arguments inside a parameter list, they can be used to create
flow-control functions like those already built-in to newLISP.

All parameters defined are optional. When a macro is called without
arguments, those parameters assume the value `nil`. If those parameters
have a default value specified in _exp-default_, they assume that
default value.

[source,newlisp]
-------------------------------
(define-macro (foo (a 1) (b 2))
  (list a b))

(foo)      → (1 2)
(foo 3)    → (3 2)
(foo 3 4)  → (3 4)
-------------------------------

Expressions in _exp-default_ are evaluated in the function's current
environment.

[source,newlisp]
----------------------------------------
(define-macro (foo (a 10) (b (div a 2)))
  (list a b))

(foo)      → (10 5)
(foo 30)   → (30 15)
(foo 3 4)  → (3 4)
----------------------------------------

Note that in _fexprs_, the danger exists of passing a parameter with the
same variable name as used in the `define-macro` definition. In this
case, the _fexpr's_ internal variable would end up receiving `nil`
instead of the intended value:

[source,newlisp]
---------------------------------------------
;; not a good definition!

(define-macro (my-setq x y) (set x (eval y)))

;; symbol name clash for x

(my-setq x 123)  → 123
x                → nil
---------------------------------------------

There are several methods that can be used to avoid this problem, known
as _variable capture_, by writing _hygienic_ `define-macro`s:

* Put the definition into its own lexically closed namespace context. If
the function has the same name as the context, it can be called by using
the context name alone. A function with this characteristic is called a
link:#default_function[_default function_]. This is the preferred method
in newLISP to write `define-macro`s.
* Use link:#args[args] to access arguments passed by the function.

[source,newlisp]
-----------------------------------------------------
;; a define-macro as a lexically isolated function
;; avoiding variable capture in passed parameters

(context 'my-setq)

(define-macro (my-setq:my-setq x y) (set x (eval y)))

(context MAIN)

(my-setq x 123)  → 123  ; no symbol clash
-----------------------------------------------------

The definition in the example is lexically isolated, and no variable
capture can occur. Instead of the function being called using
`(my-setq:my-setq …)`, it can be called with just `(my-setq …)` because
it is a link:#default_function[_default function_].

The second possibility is to refer to passed parameters using
link:#args[args]:

[source,newlisp]
-----------------------------------------------------------
;; avoid variable capture in macros using the args function

(define-macro (my-setq) (set (args 0) (eval (args 1))))
-----------------------------------------------------------

function::delete[]

*syntax:* (delete _symbol_ [_bool_]) +
*syntax:* (delete _sym-context_ [_bool_])

Deletes a symbol _symbol_, or a context in _sym-context_ with all
contained symbols from newLISP's symbol table. References to the symbol
will be changed to `nil`.

When the expression in _bool_ evaluates to `true`, symbols are only
deleted when they are not referenced.

When the expression in _bool_ evaluates to `nil`, symbols will be
deleted without any reference checking. Note that this mode should only
be used, if no references to the symbol exist outside it's namespace. If
external references exist, this mode can lead to system crashes, as the
external reference is not set to `nil` when using this mode. This mode
can be used to delete namespace hashes and to delete namespaces in
object systems, where variables are strictly treated as private.

Protected symbols of built-in functions and special symbols like `nil`
and `true` cannot be deleted.

`delete` returns `true` if the symbol was deleted successfully or `nil`
if the symbol was not deleted.

[source,newlisp]
-----------------------------------------------------
(set 'lst '(a b aVar c d))

(delete 'aVar)  ; aVar deleted, references marked nil

lst  → (a b nil c d)

(set 'lst '(a b aVar c d))

(delete 'aVar true)
→ nil ; protect aVar if referenced

lst  → (a b aVar c d)

;; delete all symbols in a context
(set 'foo:x 123)
(set 'foo:y "hello")

(delete 'foo)  → foo:x, foo:y deleted
-----------------------------------------------------

In the last example only the symbols inside context `foo` will be
deleted but not the context symbol `foo` itself. It will be converted to
a normal unprotected symbol and contain `nil`.

Note that deleting a symbol that is part of an expression which is
currently executing can crash the system or have other unforeseen
effects.

function::delete-file[]

*syntax:* (delete-file _str-file-name_)

Deletes a file given in _str-file-name_. Returns `true` if the file was
deleted successfully.

On failure the function returns `nil`. For error information, use
link:#sys-error[sys-error] when used on files. When used on URLs
link:#net-error[net-error] gives more error information.

The file name can be given as a URL.

[source,newlisp]
---------------------------------------------
(delete-file "junk")

(delete-file "http://asite.com/example.html")

(delete-file "file://aFile.txt")
---------------------------------------------

The first example deletes the file `junk` in the current directory. The
second example shows how to use a URL to specify the file. In this form,
additional parameters can be given. See link:#delete-url[delete-url] for
details.

function::delete-url[]

*syntax:* (delete-file _str-url_)

This function deletes the file on a remote HTTP server specified in
_str-url_. The HTTP `DELETE` protocol must be enabled on the target web
server, or an error message string may be returned. The target file must
also have access permissions set accordingly. Additional parameters such
as timeout and custom headers are available exactly as in the
link:#get-url[get-url] function.

If _str-url_ starts with `file://` a file on the local file system is
deleted.

This feature is also available when the link:#delete-file[delete-file]
function is used and a URL is specified for the filename.

[source,newlisp]
--------------------------------------------------
(delete-url "http://www.aserver.com/somefile.txt")
(delete-url "http://site.org:8080/page.html" 5000)

; delete on the local file system
(delete-url "file:///home/joe/somefile.txt")
--------------------------------------------------

The second example configures a timeout option of five seconds. Other
options such as special HTTP protocol headers can be specified, as well.
See the link:#get-url[get-url] function for details.

function::destroy[]

*syntax:* (destroy _int-pid_) +
*syntax:* (destroy _int-pid_ _int-signal_)

Destroys a process with process id in _int-pid_ and returns `true` on
success or `nil` on failure. The process id is normally obtained from a
previous call to link:#fork[fork] on Mac OS X and other Unix or
link:#process[process] on all platforms. On Unix, `destroy` works like
the system utility _kill_ using the SIGKILL signal.

CAUTION! If _int-pid_ is `0` the signal is sent to all processes whose
group ID is equal to the process group ID of the sender. If _int-pid_ is
`-1` all processes with the current user id will be killed, if newLISP
is started with super user privileges, all processes except system
processes are destroyed.

When specifying _int-signal_, `destroy` works like a Unix `kill` command
sending the specified Unix signal to the process in _int-pid_. This
second syntax is not available on Win32.

[source,newlisp]
-----------------------------------------------------------
(set 'pid (process "/usr/bin/bc" bcin bcout))
(destroy pid)

(set 'pid (fork (dotimes (i 1000) (println i) (sleep 10))))
(sleep 100) (destroy pid)
-----------------------------------------------------------

function::det[]

*syntax:* (det _matrix_ [_float-pivot_])

Returns the determinant of a square matrix. A matrix can either be a
nested list or an link:#array[array].

Optionally `0.0` or a very small value can be specified in
_float-pivot_. This value substitutes pivot elements in the
LU-decomposition algorithm, which result in zero when the algorithm
deals with a singular matrix.

[source,newlisp]
--------------------------------------
(set 'A '((-1 1 1) (1 4 -5) (1 -2 0)))
(det A)  → -1

; treatment of singular matrices
(det '((2 -1) (4 -2)))        → nil
(det '((2 -1) (4 -2)) 0)      → -0
(det '((2 -1) (4 -2)) 1e-20)  → -4e-20
--------------------------------------

If the matrix is singular and _float-pivot_ is not specified, `nil` is
returned.

See also the other matrix operations link:#invert[invert],
link:#mat[mat], link:#multiply[multiply] and link:#transpose[transpose].

function::device[]

*syntax:* (device [_int-handle_])

_int-handle_ is an I/O device number, which is set to 0 (zero) for the
default STD I/O pair of handles, 0 for _stdin_ and 1 for _stdout_.
_int-handle_ may also be a file handle previously obtained using
link:#open[open]. In this case both, input and output are channeled
through this handle. When no argument is supplied, the current I/O
device number is returned.

The I/O channel specified by `device` is used internally by the
functions link:#print[print] and link:#read-line[read-line]. When the
current I/O device is 0 or 1, link:#print[print] sends output to the
console window and link:#read-line[read-line] accepts input from the
keyboard. If the current I/O device has been set by opening a file, then
link:#print[print] and link:#read-line[read-line] work on that file.

[source,newlisp]
---------------------------------------------------------
(device (open "myfile" "write"))  → 5
(print "This goes in myfile")     → "This goes in myfile"
(close (device))                  → true
---------------------------------------------------------

Note that using link:#close[close] on `device` automatically resets
`device` to 0 (zero).

function::difference[]

*syntax:* (difference _list-A_ _list-B_) +
*syntax:* (difference _list-A_ _list-B_ _bool_)

In the first syntax, `difference` returns the _set_ difference between
_list-A_ and _list-B_. The resulting list only has elements occurring in
_list-A_, but not in _list-B_. All elements in the resulting list are
unique, but _list-A_ and _list-B_ need not be unique. Elements in the
lists can be any type of Lisp expression.

[source,newlisp]
---------------------------------------------------------
(difference '(2 5 6 0 3 5 0 2) '(1 2 3 3 2 1))  → (5 6 0)
---------------------------------------------------------

In the second syntax, `difference` works in _list_ mode. _bool_
specifies `true` or an expression not evaluating to `nil`. In the
resulting list, all elements of _list-B_ are eliminated in _list-A_, but
duplicates of other elements in _list-A_ are left.

[source,newlisp]
------------------------------------------------------------------
(difference '(2 5 6 0 3 5 0 2) '(1 2 3 3 2 1) true)  → (5 6 0 5 0)
------------------------------------------------------------------

See also the set functions link:#intersect[intersect],
link:#unique[unique] and link:#union[union].

function::directory[]

*syntax:* (directory [_str-path_]) +
*syntax:* (directory _str-path_ _str-pattern_ [_int-regex-option_])

A list of directory entry names is returned for the directory path given
in _str-path_. On failure, `nil` is returned. When _str-path_ is
omitted, the list of entries in the current directory is returned.

[source,newlisp]
------------------
(directory "/bin")

(directory "c:/")
------------------

The first example returns the directory of `/bin`, the second line
returns a list of directory entries in the root directory of drive C:.
Note that on Win32 systems, a forward slash (`/`) can be included in
path names. When used, a backslash (`\`) must be preceded by a second
backslash.

In the second syntax, `directory` can take a regular expression pattern
in _str-pattern_. Only filenames matching the pattern will be returned
in the list of directory entries. In _int-regex-options_, special
regular expression options can be specified; see link:#regex[regex] for
details.

[source,newlisp]
--------------------------------------------------------------
(directory "." "\\.c")  → ("foo.c" "bar.c")
;; or using braces as string pattern delimiters
(directory "." {\.c})  → ("foo.c" "bar.c")

; show only hidden files (starting with dot)
(directory "." "^[.]")   → ("." ".." ".profile" ".rnd" ".ssh")
--------------------------------------------------------------

The regular expression forces `directory` to return only file names
containing the string `".c"`.

Other functions that use regular expressions are link:#find[find],
link:#find-all[find-all], link:#parse[parse], link:#regex[regex],
link:#replace[replace], and link:#search[search].

function::directory?[]

*syntax:* (directory? _str-path_)

Checks if _str-path_ is a directory. Returns `true` or `nil` depending
on the outcome.

[source,newlisp]
--------------------------------------
(directory? "/etc")             → true
(directory? "/usr/bin/emacs/")  → nil
--------------------------------------

function::div[]

*syntax:* (div _num-1_ _num-2_ [_num-3_ ... ]) +
*syntax:* (div _num-1_)

Successively divides _num-1_ by the number in _num-2—_. `div` can
perform mixed-type arithmetic, but it always returns floating point
numbers. Any floating point calculation with `NaN` also returns `NaN`.

[source,newlisp]
----------------------------------------
(div 10 3)                 → 3.333333333
(div 120 (sub 9.0 6) 100)  → 0.4

(div 10)                   → 0.1
----------------------------------------

When _num-1_ is the only argument, `div` calculates the inverse of
_num-1_.

function::do-until[]

*syntax:* (do-until _exp-condition_ [_body_])

The expressions in _body_ are evaluated before _exp-condition_ is
evaluated. If the evaluation of _exp-condition_ is not `nil`, then the
`do-until` expression is finished; otherwise, the expressions in _body_
get evaluated again. Note that `do-until` evaluates the conditional
expression _after_ evaluating the body expressions, whereas
link:#until[until] checks the condition _before_ evaluating the body.
The return value of the `do-until` expression is the last evaluation of
the _body_ expression. If _body_ is empty, the last result of
_exp-condition_ is returned.

`do-until` also updates the system iterator symbol `$idx`.

[source,newlisp]
--------------------------
(set 'x 1)
(do-until (> x 0) (inc x))
x  → 2

(set 'x 1)
(until (> x 0) (inc x))
x  → 1
--------------------------

While `do-until` goes through the loop at least once, link:#until[until]
never enters the loop.

See also the functions link:#while[while] and link:#do-while[do-while].

function::do-while[]

*syntax:* (do-while _exp-condition body_)

The expressions in _body_ are evaluated before _exp-condition_ is
evaluated. If the evaluation of _exp-condition_ is `nil`, then the
`do-while` expression is finished; otherwise the expressions in _body_
get evaluated again. Note that `do-while` evaluates the conditional
expression _after_ evaluating the body expressions, whereas
link:#while[while] checks the condition _before_ evaluating the body.
The return value of the `do-while` expression is the last evaluation of
the _body_ expression.

`do-while` also updates the system iterator symbol `$idx`.

[source,newlisp]
---------------------------
(set 'x 10)
(do-while (< x 10) (inc x))
x  → 11

(set 'x 10)
(while (< x 10) (inc x))
x  → 10
---------------------------

While `do-while` goes through the loop at least once, link:#while[while]
never enters the loop.

See also the functions link:#until[until] and link:#do-until[do-until].

function::doargs[]

*syntax:* (doargs (_sym_ [_exp-break_])_body_)

Iterates through all members of the argument list inside a user-defined
function or macro. This function or macro can be defined using
link:#define[define], link:#define-macro[define-macro],
link:#lambda[lambda], or link:#lambda-macro[lambda-macro]. The variable
in _sym_ is set sequentially to all members in the argument list until
the list is exhausted or an optional break expression (defined in
_exp-break_) evaluates to `true` or a logical true value. The `doargs`
expression always returns the result of the last evaluation.

`doargs` also updates the system iterator symbol `$idx`.

[source,newlisp]
-----------------------------
(define (foo)
    (doargs (i) (println i)))

> (foo 1 2 3 4)
1
2
3
4
-----------------------------

The optional break expression causes `doargs` to interrupt processing of
the arguments:

[source,newlisp]
------------------------
(define-macro (foo)
    (doargs (i (= i 'x))
        (println i)))

> (foo a b x c d e)
a
b
true
------------------------

Use the link:#args[args] function to access the entire argument list at
once.

function::dolist[]

*syntax:* (dolist (_sym_ _list_ [_exp-break_])_body_)

The expressions in _body_ are evaluated for each element in _list_. The
variable in _sym_ is set to each of the elements before evaluation of
the body expressions. The variable used as loop index is local and
behaves according to the rules of dynamic scoping.

Optionally, a condition for early loop exit may be defined in
_exp-break_. If the break expression evaluates to any non-`nil` value,
the `dolist` loop returns with the value of _exp-break_. The break
condition is tested before evaluating _body._

[source,newlisp]
-----------------------------------------------------
(set 'x 123)
(dolist (x '(a b c d e f g))  ; prints: abcdefg
    (print x))  → g          ; return value

(dolist (x '(a b c d e f g) (= x 'e))  ; prints: abcd
    (print x))

;; x is local in dolist
;; x has still its old value outside the loop

x  → 123  ; x has still its old value
-----------------------------------------------------

This example prints `abcdefg` in the console window. After the execution
of `dolist`, the value for `x` remains unchanged because the `x` in
`dolist` has local scope. The return value of `dolist` is the result of
the last evaluated expression.

The internal system variable `$idx` keeps track of the current offset
into the list passed to `dolist`, and it can be accessed during its
execution:

[source,newlisp]
----------------------------
(dolist (x '(a b d e f g))
  (println $idx ":" x))  → g

0:a
1:b
2:d
3:e
4:f
5:g
----------------------------

The console output is shown in boldface. `$idx` is protected and cannot
be changed by the user.

function::dostring[utf8]

*syntax:* (dostring (_sym_ _string_ [_exp-break_]) _body_)

The expressions in _body_ are evaluated for each character in _string_.
The variable in _sym_ is set to each ASCII or UTF-8 integer value of the
characters before evaluation of the body expressions. The variable used
as loop index is local and behaves according to the rules of dynamic
scoping.

Optionally, a condition for early loop exit may be defined in
_exp-break_. If the break expression evaluates to any non-`nil` value,
the `dolist` loop returns with the value of _exp-break_. The break
condition is tested before evaluating _body._

[source,newlisp]
-------------------------------------------------
; ASCII example
(set 'str "abcdefg")
(dostring (c str) (println c " - " (char c)))

97 - a
98 - b
99 - c
100 - d
101 - e
102 - f
103 - g

; UTF8 example
(set 'utf8str "我能吞下玻璃而不伤身体。")
(dostring (c utf8str) (println c " - " (char c)))

25105 - 我
33021 - 能
21534 - 吞
 ...
20307 - 体
12290 - 。
-------------------------------------------------

This example prints the value of each character in the console window.
In UTF-8 enabled versions of newLISP, individual characters may be
longer than one byte and the number in the loop variable may exceed 255.
The return value of `dostring` is the result of the last evaluated
expression.

The internal system variable `$idx` keeps track of the current offset
into the string passed to `dostring`, and it can be accessed during its
execution.

function::dotimes[]

*syntax:* (dotimes (_sym-var_ _int-count_ [_exp-break_]) _body_)

The expressions in _body_ are evaluated _int_ times. The variable in
_sym_ is set from 0 (zero) to (_int_ - 1) each time before evaluating
the body expression(s). The variable used as the loop index is local to
the `dotimes` expression and behaves according the rules of dynamic
scoping. The loop index is of integer type. `dotimes` returns the result
of the last expression evaluated in _body_. After evaluation of the
`dotimes` statement _sym_ assumes its previous value.

Optionally, a condition for early loop exit may be defined in
_exp-break_. If the break expression evaluates to any non-`nil` value,
the `dotimes` loop returns with the value of _exp-break_. The break
condition is tested before evaluating _body_.

[source,newlisp]
---------------------------------
(dotimes (x 10)
  (print x))  → 9  ; return value
---------------------------------

This prints `0123456789` to the console window.

function::dotree[]

*syntax:* (dotree (_sym_ _sym-context_ [_bool_]) _body_)

The expressions in _body_ are evaluated for all symbols in
_sym-context_. The symbols are accessed in a sorted order. Before each
evaluation of the body expression(s), the variable in _sym_ is set to
the next symbol from _sym-context_. The variable used as the loop index
is local to the `dotree` expression and behaves according the rules of
dynamic scoping.

When the optional _bool_ expression evaluates to not `nil`, only symbols
starting with an underscore character `_` are accessed. Symbol names
starting with an `_` underscore are used for link:#hash[hash keys] and
symbols created by link:#bayes-train[bayes-train].

`dotree` also updates the system iterator symbol `$idx`.

[source,newlisp]
--------------------------------------------
;; faster and less memory overhead
(dotree (s SomeCTX) (print s " "))

;; slower and higher memory usage
(dolist (s (symbols SomeCTX)) (print s " "))
--------------------------------------------

This example prints the names of all symbols inside SomeCTX to the
console window.

function::dump[]

*syntax:* (dump [_exp_])

Shows the binary contents of a newLISP cell. Without an argument, this
function outputs a listing of all Lisp cells to the console. When _exp_
is given, it is evaluated and the contents of a Lisp cell are returned
in a list.

[source,newlisp]
-------------------------------------------------
(dump 'a)   → (9586996 5 9578692 9578692 9759280)

(dump 999)  → (9586996 130 9578692 9578692 999)
-------------------------------------------------

The list contains the following memory addresses and information:

[cols="1<,10<",width="40%",options="header",]
|====================================================================
|offset |description
|0 |memory address of the newLISP cell
|1 |cell->type: major/minor type, see newlisp.h for details
|2 |cell->next: linked list ptr
|3 |cell->aux: +
 string length+1 or  +
 low (little endian) or high (big endian) word of 64-bit integer or +
 low word of IEEE 754 double float
|4 |cell->contents: +
 string/symbol address or +
 high (little endian) or low (big endian) word of 64-bit integer or +
 high word of IEEE 754 double float
|====================================================================

This function is valuable for changing type bits in cells or hacking
other parts of newLISP internals. See the function link:#cpymem[cpymem]
for a comprehensive example.

function::dup[]

*syntax:* (dup _exp_ _int-n_ [_bool_]) +
*syntax:* (dup _exp_)

If the expression in _exp_ evaluates to a string, it will be replicated
_int-n_ times within a string and returned. When specifying an
expression evaluating to anything other than `nil` in _bool_, the string
will not be concatenated but replicated in a list like any other data
type.

If _exp_ contains any data type other than string, the returned list
will contain _int-n_ evaluations of _exp_.

Without the repetition parameter, `dup` assumes 2.

[source,newlisp]
---------------------------------------------
(dup "A" 6)       → "AAAAAA"
(dup "A" 6 true)  → ("A" "A" "A" "A" "A" "A")
(dup "A" 0)       → ""
(dup "AB" 5)      → "ABABABABAB"
(dup 9 7)         → (9 9 9 9 9 9 9)
(dup 9 0)         → ()
(dup 'x 8)        → (x x x x x x x x)
(dup '(1 2) 3)    → ((1 2) (1 2) (1 2))
(dup "\000" 4)    → "\000\000\000\000"

(dup "*")         → "**"
---------------------------------------------

The last example shows handling of binary information, creating a string
filled with four binary zeroes.

See also the functions link:#sequence[sequence] and
link:#series[series].

function::empty?[]

*syntax:* (empty? _exp_) +
*syntax:* (empty? _str_)

_exp_ is tested for an empty list (or _str_ for an empty string).
Depending on whether the argument contains elements, `true` or `nil` is
returned.

[source,newlisp]
---------------------------
(set 'var '())
(empty? var)         → true
(empty? '(1 2 3 4))  → nil
(empty? "hello")     → nil
(empty? "")          → true
---------------------------

The first example checks a list, while the second two examples check a
string.

function::encrypt[]

*syntax:* (encrypt _str-source_ _str-pad_)

Performs a one-time–pad encryption of _str-source_ using the encryption
pad in _str-pad_. The longer _str-pad_ is and the more random the bytes
are, the safer the encryption. If the pad is as long as the source text,
is fully random, and is used only once, then one-time–pad encryption is
virtually impossible to break, since the encryption seems to contain
only random data. To retrieve the original, the same function and pad
are applied again to the encrypted text:

[source,newlisp]
------------------------------------------------------
(set 'secret
  (encrypt "A secret message" "my secret key"))
→ ",YS\022\006\017\023\017TM\014\022\n\012\030E"

(encrypt secret "my secret key")  → "A secret message"
------------------------------------------------------

The second example encrypts a whole file:

[source,newlisp]
-------------------------------------------
(write-file "myfile.enc"
  (encrypt (read-file "myfile") "29kH67*"))
-------------------------------------------

function::ends-with[]

*syntax:* (ends-with _str-data_ _str-key_ [_num-option_]) +
*syntax:* (ends-with _list_ _exp_)

In the first syntax, `ends-with` tests the string in _str-data_ to see
if it ends with the string specified in _str-key_. It returns `true` or
`nil` depending on the outcome.

If a regular expression _option_ number is specified, _str-key_ contains
a regular expression pattern. See link:#regex[regex] for valid numbers
for _option_.

[source,newlisp]
-------------------------------------------
(ends-with "newLISP" "LISP")         → true
(ends-with "newLISP" "lisp")         → nil
;; use regular expressions
(ends-with "newLISP" "lisp|york" 1)  → true
-------------------------------------------

In the second syntax, `ends-with` checks if a list ends with the list
element in _exp_. `true` or `nil` is returned depending on outcome.

[source,newlisp]
---------------------------------------------
(ends-with '(1 2 3 4 5) 5)             → true
(ends-with '(a b c d e) 'b)            → nil
(ends-with '(a b c (+ 3 4)) '(+ 3 4))  → true
---------------------------------------------

The last example shows that _exp_ could be a list by itself.

See also the link:#starts-with[starts-with] function.

function::env[]

*syntax:* (env) +
*syntax:* (env _var-str_) +
*syntax:* (env _var-str_ _value-str_)

In the first syntax (without arguments), the operating system's
environment is retrieved as an association list in which each entry is a
key-value pair of environment variable and value.

[source,newlisp]
---------------------------------------------------------------
(env)
→ (("PATH" "/bin:/usr/bin:/sbin") ("TERM" "xterm-color") ... ))
---------------------------------------------------------------

In the second syntax, the name of an environment variable is given in
_var-str_. `env` returns the value of the variable or `nil` if the
variable does not exist in the environment.

[source,newlisp]
----------------------------------------------
(env "PATH")  → "/bin:/usr/bin:/usr/local/bin"
----------------------------------------------

The third syntax (variable name in _var-str_ and value pair in
_value-str_) sets or creates an environment variable. If _value-str_ is
the empty string `""`, then the variable is completely removed from the
environment except when running on Solaris, where the variable stays
with an empty string.

[source,newlisp]
---------------------------------------------
(env "NEWLISPBIN" "/usr/bin/")  → true
(env "NEWLISPBIN")              → "/usr/bin/"
(env "NEWLISPBIN" "")           → true
(env "NEWLISPBIN")              → nil
---------------------------------------------

function::erf[]

*syntax:* (erf _num_)

`erf` calculates the error function of a number in _num_. The error
function is defined as:

*_erf (x) = 2/sqrt(pi) * integral from 0 to x of exp(-t^2) dt_*

[source,newlisp]
-----------------------------------------------------------------
(map erf (sequence 0.0 6.0 0.5))
→
(0 0.5204998778 0.8427007929 0.9661051465 0.995322265 0.999593048
 0.9999779095 0.9999992569 0.9999999846 0.9999999998 1 1 1)
-----------------------------------------------------------------

function::error-event[]

*syntax:* (error-event _sym-event-handler | func-event-handler_)

_sym-event-handler_ contains a user-defined function for handling
errors. Whenever an error occurs, the system performs a
link:#reset[reset] and executes the user-defined error handler. The
error handler can use the built-in function link:#last-error[last-error]
to retrieve the number and text of the error. The event handler is
specified as either a quoted symbol or a lambda function.

[source,newlisp]
--------------------------------------------------------------------
(define (my-handler)
  (print "error # " (first (last-error)) " has occurred\n") )

(error-event 'my-handler)  → my-handler

;; specify a function directly

(error-event my-handler)  → $error-event

(error-event
  (fn () (print "error # " (first (last-error)) " has occurred\n")))

(error-event exit)  → $error-event
--------------------------------------------------------------------

For a different way of handling errors, see the link:#catch[catch]
function. Use link:#throw-error[throw-error] to throw user-defined
errors.

function::eval[]

*syntax:* (eval _exp_)

_eval_ evaluates the result of evaluating _exp_ in the current variable
environment.

[source,newlisp]
-------------------------------
(set 'expr '(+ 3 4))  → (+ 3 4)
(eval expr)           → 7
(eval (list + 3 4))   → 7
(eval ''x)            → x
(set 'y 123)
(set 'x 'y)
x            → y
(eval x)     → 123
-------------------------------

As usual, evaluation of variables happens in the current variable
environment:

[source,newlisp]
-----------------------------------------------------
; eval in global (top level) environment
(set 'x 3 'y 4)
(eval '(+ x y))          → 7

; eval in local environment
(let ( (x 33) (y 44) )
    (eval '(+ x y)))     → 77

; old environment after leaving local let environment
(eval '(+ x y))          → 7
-----------------------------------------------------

newLISP passes all arguments by value. Using a quoted symbol,
expressions can be passed by reference through the symbol. `eval` can be
used to access the original contents of the symbol:

[source,newlisp]
----------------------------------------------------
(define (change-list aList) (push 999 (eval aList)))

(set 'data '(1 2 3 4 5))

(change-list 'data)  → (999 1 2 3 4 5)
----------------------------------------------------

In the example, the parameter `'data ` is quoted, so `push` can work on
the original list.

There is a safer method to pass arguments by reference in newLISP by
enclosing the data inside context objects. See the chapter
link:#pass_big[Passing data by reference]. Passing references into user
defined function using namespace ids avoids _variable capture_ of the
passed symbol, in case the symbol passed is the same used as a parameter
in the function.

function::eval-string[]

*syntax:* (eval-string _str-source_ [_sym-context_ [_exp-error_ [_int-offset_]]])

The string in _str-source_ is compiled into newLISP's internal format
and then evaluated. The evaluation result is returned. If the string
contains more than one expression, the result of the last evaluation is
returned.

An optional second argument can be used to specify the context to which
the string should be parsed and translated.

If an error occurs while parsing and evaluating _str-source_ then
_exp-error_ will be evaluated and the result returned.

_int-offset_ specifies an optional offset into _str-source_, where to
start evaluation.

[source,newlisp]
---------------------------------------------------------------
(eval-string "(+ 3 4)")  → 7
(set 'X 123)             → 123
(eval-string "X")        → 123

(define (repl) ; read print eval loop
  (while true
    (println "=> " (eval-string (read-line) MAIN (last-error)))
  )
)

(set 'a 10)
(set 'b 20)
(set 'foo:a 11)
(set 'foo:b 22)

(eval-string "(+ a b)")       → 30
(eval-string "(+ a b)" 'foo)  → 33
---------------------------------------------------------------

The second example shows a simple newLISP interpreter eval loop.

The last example shows how to specify a target context for translation.
The symbols `a` and `b` now refer to symbols and their values in context
`foo` instead of `MAIN`.

See also the function link:#read-expr[read-expr] which translates a
string without evaluating it.

function::even?[]

*syntax:* (even? _int-number_)

Checks if an integer number is _even divisable_ by `2`, without
remainder. When a floating point number is passed for _int-number_, it
will be converted to an integer by cutting off its fractional part.

[source,newlisp]
-------------------
(even? 123)  → nil
(even? 8)    → true
(even? 8.7)  → true
-------------------

Use link:#oddp[odd?] to check if an integer is not divisable by `2`.

function::exec[]

*syntax:* (exec _str-process_) +
*syntax:* (exec _str-process_ [_str-stdin_])

In the first form, `exec` launches a process described in _str-process_
and returns all standard output as a list of strings (one for each line
in standard out (STDOUT)). `exec` returns `nil` if the process could not
be launched. If the process could be launched but only returns and error
and no valid output, the empty list will be returned.

[source,newlisp]
----------------------------------------------------------
(exec "ls *.c")  → ("newlisp.c" "nl-math.c" "nl-string.c")
----------------------------------------------------------

The example starts a process and performs the shell command `ls`,
capturing the output in an array of strings.

In the second form, `exec` creates a process pipe, starts the process in
_str-process_, and receives from _str-stdin_ standard input for this
process. The return value is `true` if the process was successfully
launched; otherwise it is `nil`.

[source,newlisp]
----------------------
(exec "cgiProc" query)
----------------------

In this example, cgiProc could be a cgi processor (e.g., Perl or
newLISP) that receives and processes standard input supplied by a string
contained in the variable query.

function::exists[]

*syntax:* (exists _func-condition_ _list_)

Successively applies _func-condition_ to the elements of _list_ and
returns the first element that meets the condition in _func-condition_.
If no element meets the condition, `nil` is returned.

[source,newlisp]
---------------------------------------------------------------------
(exists string? '(2 3 4 6 "hello" 7))       → "hello"

(exists string? '(3 4 2 -7 3 0))            → nil

(exists zero? '(3 4 2 -7 3 0))              → 0 ; check for 0 or 0.0

(exists < '(3 4 2 -7 3 0))                  → -7 ; check for negative

(exists (fn (x) (> x 3)) '(3 4 2 -7 3 0))   → 4

(exists (fn (x) (= x 10)) '(3 4 2 -7 3 0))  → nil
---------------------------------------------------------------------

If _func-condition_ is `nil?`, the result `nil` is ambiguous. In this
case link:#index[index] or link:#find[find] are the better method when
looking for `nil`.

Use the link:#for-all[for-all] function to check if a condition is met
for all elements in a list.

function::exit[]

*syntax:* (exit [_int_])

Exits newLISP. An optional exit code, _int_, may be supplied. This code
can be tested by the host operating system. When newLISP is run in
link:#daemon[daemon server mode] using `-d` as a command-line option,
only the network connection is closed, while newLISP stays resident,
listening for a new connection.

[source,newlisp]
--------
(exit 5)
--------

function::exp[]

*syntax:* (exp _num_)

The expression in _num_ is evaluated, and the exponential function is
calculated based on the result. `exp` is the inverse function of
link:#log[log].

[source,newlisp]
----------------------------
(exp 1)        → 2.718281828
(exp (log 1))  → 1
----------------------------

function::expand[]

*syntax:* (expand _exp_ _sym-1_ [_sym-2_ ... ]) +
*syntax:* (expand _exp_ _list-assoc_ [_bool_]) +
*syntax:* (expand _exp_)

In the first syntax, one symbol in _sym_ (or more in _sym-2_ through
_sym-n_) is looked up in a simple or nested expression _exp_. They are
then expanded to the current binding of the symbol and the expanded
expression is returned. The original list remains unchanged.

[source,newlisp]
--------------------------------------------------
(set 'x 2 'a '(d e))
(set 'foo 'a)
(expand foo 'a)               → (d e)
(expand '(a x b) 'x)           → (a 2 b)
(expand '(a x (b c x)) 'x)     → (a 2 (b c 2))
(expand '(a x (b c x)) 'x 'a)  → ((d e) 2 (b c 2))
--------------------------------------------------

`expand` is useful when composing lambda expressions or doing variable
expansion inside macros.

[source,newlisp]
-----------------------------------------------
(define (raise-to power)
  (expand (fn (base) (pow base power)) 'power))

(define square (raise-to 2))
(define cube (raise-to 3))

(square 5)  → 25
(cube 5)    → 125
-----------------------------------------------

If more than one symbol is present, `expand` will work in an incremental
fashion:

[source,newlisp]
--------------------------------------
(set 'a '(b c))
(set 'b 1)

(expand '(a b c) 'a 'b)  → ((1 c) 1 c)
--------------------------------------

Like the link:#apply[apply] function, `expand` _reduces_ its argument
list.

*syntax:* (expand _exp_ _list-assoc_ [_bool_])

The second syntax of `expand` allows expansion bindings to be specified
on the fly, without performing a link:#set[set] on the participating
variables:

If the _bool_ evaluates to `true`, the value parts in the association
list are evaluated.

[source,newlisp]
-------------------------------------------------------------------
(expand '(a b c) '((a 1) (b 2)))                → (1 2 c)
(expand '(a b c) '((a 1) (b 2) (c (x y z))))    → (1 2 (x y z))
(expand '(a b) '((a (+ 1 2)) (b (+ 3 4))))      → ((+ 1 2) (+ 3 4))
(expand '(a b) '((a (+ 1 2)) (b (+ 3 4))) true) → (3 7)
-------------------------------------------------------------------

Note that the contents of the variables in the association list will not
change. This is different from the link:#letex[letex] function, where
variables are set by evaluating and assigning their association parts.

This form of `expand` is frequently used in logic programming, together
with the link:#unify[unify] function.

*syntax:* (expand _exp_)

A third syntax is used to expand only the contents of variables starting
with an uppercase character. This PROLOG mode may also be used in the
context of logic programming. As in the first syntax of `expand`,
symbols must be preset. Only uppercase variables and those bound to
anything other than `nil` will be expanded:

[source,newlisp]
-----------------------------------------------
(set 'A 1 'Bvar 2 'C nil 'd 5 'e 6)
(expand '(A (Bvar) C d e f))  → (1 (2) C d e f)
-----------------------------------------------

Only the symbols `A` and `Bvar` are expanded because they have
capitalized names and non-`nil` contents.

The _currying_ function in the example demonstrating the first syntax of
`expand` can now be written even more simply using an uppercase
variable:

[source,newlisp]
----------------------------------------
(define (raise-to Power)
  (expand (fn (base) (pow base Power))))

> (define cube (raise-to 3))
(lambda (base) (pow base 3))

> (cube 4)
64

> _
----------------------------------------

See the link:#letex[letex] function, which also provides an expansion
mechanism, and the function link:#unify[unify], which is frequently used
together with `expand`.

function::explode[utf8]

*syntax:* (explode _str_ [_int-chunk_ [_bool_]]) +
*syntax:* (explode _list_ [_int-chunk_ [_bool_]])

In the first syntax, `explode` transforms the string (_str_) into a list
of single-character strings. Optionally, a chunk size can be specified
in _int-chunk_ to break the string into multi-character chunks. When
specifying a value for _bool_ other than `nil`, the last chunk will be
omitted if it does not have the full length specified in _int-chunk_.

[source,newlisp]
---------------------------------------------------------
(explode "newLISP")  → ("n" "e" "w" "L" "I" "S" "P")

(join (explode "keep it together"))  → "keep it together"

(explode "newLISP" 2)    → ("ne" "wL" "IS" "P")

(explode "newLISP" 3)    → ("new" "LIS" "P")

; omit last chunk if too short
(explode "newLISP" 3 true)    → ("new" "LIS")
---------------------------------------------------------

Only on non UTF8– enabled versions, `explode` also works on binary
content:

[source,newlisp]
-------------------------------
(explode "\000\001\002\003")
→ ("\000" "\001" "\002" "\003")
-------------------------------

When called in UTF-8–enabled versions of newLISP, `explode` will work on
character boundaries rather than byte boundaries. In UTF-8–encoded
strings, characters may contain more than one byte. Processing will stop
when a zero byte character is found.

To explode binary contents on UTF-8–enabled versions of newLISP use
link:#unpack[unpack] as shown in the following example:

[source,newlisp]
-------------------------------------------------------------------
(set 'str "\001\002\003\004") → "\001\002\003\004"

(unpack (dup "c" (length str)) str) → (1 2 3 4)
(unpack (dup "s" (length str)) str) → ("\001" "\002" "\003" "\004")
-------------------------------------------------------------------

In the second syntax, `explode` explodes a list (_list_) into sublists
of chunk size _int-chunk_, which is 1 (one) by default.

The following shows an example of the last chunk being omitted when the
value for _bool_ is other than `nil`, and the chunk does not have the
full length specified in _int-chunk_.

[source,newlisp]
-------------------------------------------------------------------
(explode '(a b c d e f g h))    → ((a) (b) (c) (d) (e) (f) (g) (h))
(explode '(a b c d e f g) 2)  → ((a b) (c d) (e f) (g))

; omit last chunk if too short
(explode '(a b c d e f g) 2 true)  → ((a b) (c d) (e f))

(transpose (explode '(a b c d e f g h) 2))
→ ((a c e g) (b d f h))
-------------------------------------------------------------------

The link:#join[join] and link:#append[append] functions are inverse
operations of `explode`.

function::extend[!]

*syntax:* (extend _list-1_ [_list-2_ ... ]) +
*syntax:* (extend _string-1_ [_string-2_ ... ])

The list in _list-1_ is extended by appending _list-2_. More than one
list may be appended.

The string in _string-1_ is extended by appending _string-2_. More than
one string may be appended. The string can contain binary `0` (zero)
characters.

The first parameter can be an un-initialized variable.

The extended list or string is returned.

[source,newlisp]
--------------------------------------
; extending lists

(extend lst '(a b) '(c d)) → (a b c d)
(extend lst '(e f g)) → (a b c d e f)
lst → (a b c d e f g)

; extending strings

(extend str "ab" "cd") → "abcd"
(extend str "efg") → "abcdefg"
str → "abcdefg"

; extending in place

(set 'L '(a b "CD" (e f)))
(extend (L 2) "E")
L → (a b "CDE" (e f))

(extend (L 3) '(g))
L → (a b "CDE" (e f g))
--------------------------------------

For a non-destructive list or string extension see link:#append[append].

function::factor[]

*syntax:* (factor _int_)

Factors the number in _int_ into its prime components. When floating
point numbers are passed, they are truncated to their integer part
first.

[source,newlisp]
---------------------------------------------------------------
(factor 123456789123456789)  → (3 3 7 11 13 19 3607 3803 52579)

;; check correctness of factoring
(= (apply * (factor 123456789123456789)) 123456789123456789)
→ true

;; factor the biggest integer
(factor 9223372036854775807)  → (7 7 73 127 337 92737 649657)

;; primes.lsp - return all primes in a list, up to n

(define (primes n , p)
  (dotimes (e n)
    (if (= (length (factor e)) 1)
      (push e p -1))) p)

(primes 20)  → (2 3 5 7 11 13 17 19)
---------------------------------------------------------------

`factor` returns `nil` for numbers smaller than `2`. For numbers larger
than 9,223,372,036,854,775,807 (the largest 64-bit integer) converted
from floating point numbers, the largest integer is factored.

function::fft[]

*syntax:* (fft _list-num_)

Calculates the discrete Fourier transform on the list of complex numbers
in _list-num_ using the FFT method (Fast Fourier Transform). Each
complex number is specified by its real part followed by its imaginary
part. If only real numbers are used, the imaginary part is set to `0.0`
(zero). When the number of elements in _list-num_ is not a power of 2,
`fft` increases the number of elements by padding the list with zeroes.
When the imaginary part of a complex number is `0`, simple numbers can
be used instead.

[source,newlisp]
------------------------------------------------------
(ifft (fft '((1 0) (2 0) (3 0) (4 0))))
→ ((1 0) (2 0) (3 0) (4 0))

;; when imaginary part is 0, plain numbers work, too
;; complex numbers can be intermixed

(fft '(1 2 3 4))      → ((10 0) (-2 -2) (-2 0) (-2 2))
(fft '(1 2 (3 0) 4))  → ((10 0) (-2 -2) (-2 0) (-2 2))
------------------------------------------------------

The inverse operation of `fft` is the link:#ifft[ifft] function.

function::file-info[]

*syntax:* (file-info _str-name_ [_int-index_ [_bool-flag_]])

Returns a list of information about the file or directory in _str_name_.
The optional index specifies the list member to return. When no
_bool-flag_ is specified or when _bool-flag_ evaluates to `nil`
information about the link is returned if the file is a link to an
original file. If _bool-flag_ evaluates to anything else than `nil`,
information about the original file referenced by the link is returned.

[cols="1<,4<",width="25%",options="header",]
|==================================
|offset |contents
|0 |size
|1 |mode (differs with `true` flag)
|2 |device mode
|3 |user ID
|4 |group ID
|5 |access time
|6 |modification time
|7 |status change time
|==================================

Depending on _bool-flag_ set, the function reports on either the link
(no flag or `nil` flag) or on the original linked file (`true` flag).

[source,newlisp]
---------------------------------------------------------
(file-info ".bashrc")
→ (124 33188 0 500 0 920951022 920951022 920953074)

(file-info ".bashrc" 0)  → 124

(date (file-info "/etc" -1))  → "Mon Mar 8 18:23:17 2005"
---------------------------------------------------------

In the second example, the last status change date for the directory
_/etc_ is retrieved.

`file-info` gives file statistics (size) for a linked file, not the
link, except for the _mode_ field.

function::file?[]

*syntax:* (file? _str-path-name_ [_bool_])

Checks for the existence of a file in _str-name_. Returns `true` if the
file exists; otherwise, it returns `nil`. This function will also return
`true` for directories. If the optional _bool_ value is `true`,
_str-path-name_ is returned. The existence of a file does not imply
anything about its read or write permissions. A file may exist while not
having the permissions to read from or write to it by the current user.

[source,newlisp]
--------------------------------------------------------
(if (file? "afile") (set 'fileNo (open "afile" "read")))

(file? "/usr/bin/newlisp" true) → "/usr/bin/newlisp"
(file? "/usr/bin/foo" true)     → nil
--------------------------------------------------------

function::filter[]

*syntax:* (filter _exp-predicate_ _exp-list_)

The predicate _exp-predicate_ is applied to each element of the list
_exp-list_. A list is returned containing the elements for which
_exp-predicate_ is true. `filter` works like link:#clean[clean], but
with a negated predicate.

[source,newlisp]
--------------------------------------------------------------
(filter symbol? '(1 2 d 4 f g 5 h))  → (d f g h)

(define (big? x) (> x 5))  → (lambda (x) (> x 5))

(filter big? '(1 10 3 6 4 5 11))  → (10 6 11)

; filter with comparison functor
(set 'L '((a 10 2 7) (b 5) (a 8 3) (c 8) (a 9)))

(filter (curry match '(a *)) L)   → ((a 10 2 7) (a 8 3) (a 9))

(filter (curry match '(? ?)) L)   → ((b 5) (c 8) (a 9))

(filter (curry match '(* 8 *)) L) → ((a 8 3) (c 8))
--------------------------------------------------------------

The predicate may be a built-in predicate, a user-defined function, or a
lambda expression.

For filtering a list of elements with the elements from another list,
use the link:#difference[difference] function or
link:#intersect[intersect] (with the _list_ option).

See also the related function link:#index[index], which returns the
indices of the filtered elements and link:#clean[clean], which returns
all elements of a list for which a predicate is false.

function::find[]

*syntax:* (find _exp-key_ _list_ [_func-compare_ | _int-regex-option_]) +
*syntax:* (find _str-key_ _str-data_ [_int-regex-option_ [_int-offset_]])

Find an expression in a list
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If the second argument evaluates to a _list_, then `find` returns the
index position (offset) of the element derived from evaluating
_exp-key_.

Optionally, an operator or user-defined function can be specified in
_func-compare_. If the _exp-key_ is a string, a regular expression
option can be specified with the _int-regex-option_ parameter.

When using regular expressions or comparison functors the system
variable `$0` is set to the last element found.

[source,newlisp]
------------------------------------------------------------
; find an expression in a list
(find '(1 2) '((1 4) 5 6 (1 2) (8 9)))  → 3

(find "world" '("hello" "world"))       → 1
(find "hi" '("hello" "world"))          → nil

(find "newlisp" '("Perl" "Python" "newLISP") 1)  → 2

; use the comparison functor
(find 3 '(8 4 3  7 2 6) >)  → 4
$0 → 2

(find "newlisp" '("Perl" "Python" "newLISP")
                 (fn (x y) (regex x y 1))) → 2
$0 → "newLISP"

(find 5 '((l 3) (k 5) (a 10) (z 22))
         (fn (x y) (= x (last y))))  → 1
$0 → (k 5)

(find '(a ?) '((l 3) (k 5) (a 10) (z 22)) match)  → 2
$0 → (a 10)

(find '(X X) '((a b) (c d) (e e) (f g)) unify)  → 2
$0 → (e e)

; define the comparison functor first for better readability
(define (has-it-as-last x y) (= x (last y)))

(find 22 '((l 3) (k 5) (a 10) (z 22)) has-it-as-last)  → 3
$0 → (z 22)
------------------------------------------------------------

Using link:#match[match] and link:#unify[unify], list searches can be
formulated which are as powerful as regular expression searches are for
strings.

Find a string in a string
^^^^^^^^^^^^^^^^^^^^^^^^^

If the second argument, _str-data_, evaluates to a string, then the
offset position of the string _str-key_ (found in the first argument,
_str-data_) is returned. In this case, `find` also works on binary
_str-data_. The offset position returned is always based on counting
single byte characters even when running the UTF-8 enabled version of
newLISP.

The presence of a third parameter specifies a search using the regular
expression pattern specified in _str-pattern_, as well as an option
number specified in _int-regex-option_ (i.e., 1 (one) for
case-insensitive search or `0` (zero) for no special options). If
_int-regex-option_ is specified an optional _int-offset_ argument can be
specified too to start the search not at the beginning but at the offset
given. In any case the position returned by `find` is calculated
relative to the beginning of the string.

To specify _int-offset_ in a simple string search without regular
expressions, specify `nil` for _int-regex-option_.

In newLISP, regular expressions are standard Perl Compatible Regular
Expression (PCRE) searches. Found expressions or subexpressions are
returned in the system variables `$0`, `$1`, `$2`, etc., which can be
used like any other symbol. As an alternative, the contents of these
variables can also be accessed by using `($ 0)`, `($ 1)`, `($ 2)`, etc.
This method allows indexed access (i.e., `($ i)`, where `i` is an
integer).

See link:#regex[regex] for the meaning of the option numbers and more
information on regular expression searching.

[source,newlisp]
----------------------------------------------------------
; simple string search
(find "world" "Hello world")  → 6
(find "WORLD" "Hello woRLd")  → nil

; case-insensitive regex

(find "WorlD" "Hello woRLd" 1)  → 6

(find "hi" "hello world")       → nil
(find "Hello" "Hello world")    → 0

; regex with default options

(find "cat|dog" "I have a cat" 0)  → 9
$0                                 → "cat"
(find "cat|dog" "my dog" 0)        → 3
$0                                 → "dog"
(find "cat|dog" "MY DOG" 1)        → 3
$0                                 → "DOG"

; use an optional offset
(find "cat|dog" "I have a cat and a dog" 0)    → 9
(find "cat|dog" "I have a cat and a dog" 0 12) → 19

;; find with subexpressions in regular expression
;; and access with system variables

(set 'str  "http://nuevatec.com:80")

(find "http://(.*):(.*)" str 0)  → 0

$0  → "http://nuevatec.com:80"
$1  → "nuevatec.com"
$2  → "80"

;; system variables as an indexed expression (since 8.0.5)
($ 0)  → "http://nuevatec.com:80"
($ 1)  → "nuevatec.com"
($ 2)  → "80"
----------------------------------------------------------

For other functions using regular expressions, see
link:#directory[directory], link:#find-all[find-all],
link:#parse[parse], link:#regex[regex], link:#replace[replace], and
link:#search[search].

To find expressions in nested or multidimensional lists, use the
link:#ref[ref] and link:#ref-all[ref-all] functions.

function::find-all[]

*syntax:* (find-all _str-regex-pattern_ _str-text_ [_exp_ [_int-regex-option_]]) +
*syntax:* (find-all _list-match-pattern_ _list-lists_ [_exp_]) +
*syntax:* (find-all _exp-key_ _list_ _exp_ _func-compare_)

In the first syntax, `find-all` finds all occurrences of
_str-regex-pattern_ in the text _str-text_, returning a list containing
all matching strings. The empty list `()` is returned if no matches are
found.

Optionally, an expression can be specified to process the found string
or regular subexpressions before placing them into the returned list. An
additional option, _int-option_, specifies special regular expression
options (see link:#regex[regex] for further details).

[source,newlisp]
-----------------------------------------------------------------
(find-all {\d+} "lkjhkljh34ghfdhgfd678gfdhfgd9")
→ ("34" "678" "9")

(find-all {(new)(lisp)} "newLISPisNEWLISP" (append $2 $1) 1)
→ ("LISPnew" "LISPNEW")

(unique (sort
    (find-all {[a-zA-Z]+}
        (replace "<[^>]+>" (get-url "http://newlisp.org") "" 0) )
))
→ ("A" "ACC" "AI" "API" "About" "All" "Amazing" "Apps"
...
"where" "whole" "width" "wiki" "will" "with" "work" "written")
-----------------------------------------------------------------

The first example discovers all numbers in a text. The second example
shows how an optional expression in _exp_ can work on subexpressions
found by the regular expression pattern in _str-pattern_. The last
example retrieves a web page, cleans out all HTML tags, and then
collects all words into a unique and sorted list.

Note that `find-all` with strings always performs a regular expression
search, even if the option in _int-option_ is omitted.

In the second syntax, `find-all` searches for all list
link:#match[match] patterns _list-match-pattern_ in _list-lists_. As in
`find-all` for strings, an expression can be specified in _exp_ to
process further the matched sublist:

[source,newlisp]
----------------------------------------------------------------
(find-all '(? 2) '((a 1) (b 2) (a 2) (c 4))) → ((b 2) (a 2))

(find-all '(? 2) '((a 1) (b 2) (a 2) (c 4)) (first $it)) → (b a)
----------------------------------------------------------------

`find-all` for list matches always uses link:#match[match] to compare
when searching for sublists and always needs a list for the pattern
expression.

In the third syntax, `find-all` can specify a built-in or user-defined
function used for comparing list elements with the key expression in
_exp-key_:

[source,newlisp]
-------------------------------------------------------------------------------------
(find-all 5 '(2 7 4 5 9 2 4 9 7 4 8) $it <) → (7 9 9 7 8)

; process the found element available in $it

(find-all 5 '(2 7 4 5 9 2 4 9 7 4 8) (* 3 $it) <) → (21 27 27 21 24)
; same as
(find-all 5 '(2 7 4 5 9 2 4 9 7 4 8) (* 3 $it) (fn (x y) (< x y))) → (21 27 27 21 24)

(find-all 5 '(2 7 4 5 9 2 4 9 7 4 8) ("abcdefghijk" $it) <) → ("h" "j" "j" "h" "i")
-------------------------------------------------------------------------------------

Any type of expression can be searched for or can be contained in the
list. `find-all` in this syntax works similar to link:#filter[filter]
but with the added benefit of being able to define a processing
expression for the found element.

function::first[utf8]

*syntax:* (first _list_) +
*syntax:* (first _array_) +
*syntax:* (first _str_)

Returns the first element of a list or the first character of a string.
The operand is not changed. This function is equivalent to _car_ or
_head_ in other Lisp dialects.

[source,newlisp]
-----------------------------------------------
(first '(1 2 3 4 5))       → 1
(first '((a b) c d))       → (a b)
(set 'aList '(a b c d e))  → (a b c d e)
(first aList)              → a
aList                      → (a b c d e)
(set 'A (array 3 2 (sequence 1 6)))
→  ((1 2) (3 4) (5 6))
(first A)                  → (1 2)

(first '())                → ERR: list is empty
-----------------------------------------------

In the third syntax, the first character is returned from the string in
_str_ as a string.

[source,newlisp]
-------------------------------
(first "newLISP")         → "n"
(first (rest "newLISP"))  → "e"
-------------------------------

Note that link:#first[first] works on character boundaries rather than
byte boundaries when the UTF-8–enabled version of newLISP is used. See
also the functions link:#last[last] and link:#rest[rest].

function::flat[]

*syntax:* (flat _list_)

Returns a flattened list from a list:

[source,newlisp]
-------------------------------------
(set 'lst '(a (b (c d))))
(flat lst)  → (a b c d)

(map (fn (x) (ref x lst)) (flat lst))
→ ((0) (1 0) (1 1 0) (1 1 1))
-------------------------------------

`flat` can be used to iterate through nested lists.

function::float[]

*syntax:* (float _exp_ [_exp-default_])

If the expression in _exp_ evaluates to a number or a string, the
argument is converted to a float and returned. If _exp_ cannot be
converted to a float then `nil` or, if specified, the evaluation of
_exp-default_ will be returned. This function is mostly used to convert
strings from user input or when reading and parsing text. The string
must start with a digit or the `+` (plus sign), `-` (minus sign), or `.`
(period). If _exp_ is invalid, `float` returns `nil` as a default value.

Floats with exponents larger than 1e308 or smaller than -1e308 are
converted to +INF or -INF, respectively. The display of +INF and -INF
differs on different platforms and compilers.

[source,newlisp]
----------------------------------------------
(float "1.23")       → 1.23
(float " 1.23")      → 1.23
(float ".5")         → 0.50
(float "-1.23")      → -1.23
(float "-.5")        → nil
(float "#1.23")      → nil
(float "#1.23" 0.0)  → 0

(float? 123)          → nil
(float? (float 123))  → true

(float '(a b c))    → nil
(float '(a b c) 0)  → 0
(float nil 0)       → 0

(float "abc" "not a number")  → "not a number"
(float "1e500")               → inf
(float "-1e500")              → -inf

(print "Enter a float num:")
(set 'f-num (float (read-line)))
----------------------------------------------

Use the link:#int[int] function to parse integer numbers.

function::float?[]

*syntax:* (float? _exp_)

`true` is returned only if _exp_ evaluates to a floating point number;
otherwise, `nil` is returned.

[source,newlisp]
--------------------
(set 'num 1.23)
(float? num)  → true
--------------------

function::floor[]

*syntax:* (floor _number_)

Returns the next lowest integer below _number_ as a floating point.

[source,newlisp]
------------------
(floor -1.5)  → -2
(floor 3.4)   → 3
------------------

See also the link:#ceil[ceil] function.

function::flt[]

*syntax:* (flt _number_)

Converts _number_ to a 32-bit float represented by an integer. This
function is used when passing 32-bit floats to library routines. newLISP
floating point numbers are 64-bit and are passed as 64-bit floats when
calling imported C library routines.

[source,newlisp]
------------------------------------------------------
(flt 1.23)  → 1067282596

;; pass 32-bit float to C-function: foo(float value)
(import "mylib.so" "foo")
(foo (flt 1.23))

(get-int (pack "f" 1.23))  → 1067282596

(unpack "f" (pack "ld" (flt 1.2345)))  → (1.234500051)
------------------------------------------------------

The last two statements illustrate the inner workings of `flt`.

Use the link:#import[import] function to import libraries.

function::fn[]

*syntax:* (fn (_list-parameters_) _exp-body_)

`fn` is used to define anonymous functions, which are frequently used in
link:#map[map], link:#sort[sort], and many other functions where
functions can be used as arguments.

Using an anonymous function eliminates the need to define a new function
with link:#define[define]. Instead, a function is defined on the fly:

[source,newlisp]
---------------------------------------------------------------------
(map (fn (x) (+ x x)) '(1 2 3 4 5)) → (2 4 6 8 10)

(sort '(".." "..." "." ".....") (fn (x y) (> (length x) (length y))))
→ ("....." "..." ".." ".")
---------------------------------------------------------------------

The example defines the function _fn(x)_, which takes an integer (_x_)
and doubles it. The function is _mapped_ onto a list of arguments using
link:#map[map]. The second example shows strings being sorted by length.

The link:#lambda[lambda] function (the longer, traditional form) can be
used in place of `fn`.

function::for[]

*syntax:* (for (_sym_ _num-from_ _num-to_ [_num-step_ [_exp-break_]]) _body_)

Repeatedly evaluates the expressions in _body_ for a range of values
specified in _num-from_ and _num-to_, inclusive. A step size may be
specified with _num-step_. If no step size is specified, `1` is assumed.

Optionally, a condition for early loop exit may be defined in
_exp-break_. If the break expression evaluates to any non-`nil` value,
the `for` loop returns with the value of _exp-break_. The break
condition is tested before evaluating _body_. If a break condition is
defined, _num-step_ must be defined, too.

The symbol _sym_ is local in dynamic scope to the `for` expression. It
takes on each value successively in the specified range as an integer
value if no step size is specified, or as a floating point value when a
step size is present. After evaluation of the `for` statement _sym_
assumes its previous value.

[source,newlisp]
----------------------------------------------
> (for (x 1 10 2) (println x))
1
3
5
7
9

> (for (x 8 6 0.5) (println x))
8
7.5
7
6.5
6

> (for (x 1 100 2 (> (* x x) 30)) (println x))
1
3
5
true
> _
----------------------------------------------

The second example uses a range of numbers from highest to lowest. Note
that the step size is always a positive number. In the third example, a
break condition is tested.

Use the link:#sequence[sequence] function to make a sequence of numbers.

function::for-all[]

*syntax:* (for-all _func-condition_ _list_)

Applies the function in _func-condition_ to all elements in _list_. If
all elements meet the condition in _func-condition_, the result is
`true`; otherwise, `nil` is returned.

[source,newlisp]
-----------------------------------------------------
(for-all number? '(2 3 4 6 7))                 → true

(for-all number? '(2 3 4 6 "hello" 7))         → nil

(for-all (fn (x) (= x 10)) '(10 10 10 10 10))  → true
-----------------------------------------------------

Use the link:#exists[exists] function to check if at least one element
in a list meets a condition.

function::fork[]

*syntax:* (fork _exp_)

The expression in _exp_ is launched as a newLISP child process-thread of
the platforms OS. The new process inherits the entire address space, but
runs independently so symbol or variable contents changed in the child
process will not affect the parent process or vice versa. The child
process ends when the evaluation of _exp_ finishes.

On success, `fork` returns with the child process ID; on failure, `nil`
is returned. See also the link:#wait-pid[wait-pid] function, which waits
for a child process to finish.

This function is only available on Linux/Unix versions of newLISP and is
based on the `fork()` implementation of the underlying OS.

A much simpler automated method to launch processes and collect results
is available with link:#spawn[spawn] and the link:#cilk[Cilk API].

[source,newlisp]
--------------------------------------------------------
> (set 'x 0)
0
> (fork (while (< x 20) (println (inc x)) (sleep 1000)))
176

> 1
2
3
4
5
6
--------------------------------------------------------

The example illustrates how the child process-thread inherits the symbol
space and how it is independent of the parent process. The `fork`
statement returns immediately with the process ID `176`. The child
process increments the variable `x` by one each second and prints it to
standard out (boldface). In the parent process, commands can still be
entered. Type `x` to see that the symbol `x` still has the value `0`
(zero) in the parent process. Although statements entered will mix with
the display of the child process output, they will be correctly input to
the parent process.

The second example illustrates how link:#pipe[pipe] can be used to
communicate between processes.

[source,newlisp]
-------------------------------------------------------
#!/usr/bin/newlisp

(define (count-down-proc x channel)
  (while (!= x 0)
      (write-line channel (string x))
      (dec x)))

(define (observer-proc channel)
  (do-until (= i "1")
    (println "process " (setq i (read-line channel)))))

(map set '(in out) (pipe))
(set 'observer (fork (observer-proc in)))
(set 'counter (fork (count-down-proc 5 out)))

; avoid zombies
(wait-pid observer)
(wait-pid counter)

(exit)
-------------------------------------------------------

The following output is generated by observer-proc

---------
process 5
process 4
process 3
process 2
process 1
---------

The `count-down-proc` writes numbers to the communication pipe, where
they are picked up by the `observer-process` and displayed.

A forked process can either exit by itself or it can be destroyed using
the link:#destroy[destroy] function.

[source,newlisp]
---------------------------------------------------------------
(define (fork-destroy-demo)
    (set 'pid (fork (dotimes (i 1000) (println i) (sleep 10))))
    (sleep 50)
    (destroy pid)
)

> (fork-destroy-demo)
0
1
2
3
4
true
>
---------------------------------------------------------------

The process started by `fork-destroy-demo` will not finish but is
destroyed 50 milli-seconds after start by a call to
link:#destroy[destroy].

Use the link:#semaphore[semaphore] function for synchronizing processes
and link:#share[share] for sharing memory between processes.

See link:#spawn[spawn] for a much simpler and automated way to
synchronize processes and collect results.

function::format[]

*syntax:* (format _str-format exp-data-1_ [_exp-data-2_ ... ]) +
*syntax:* (format _str-format_ _list-data_)

Constructs a formatted string from _exp-data-1_ using the format
specified in the evaluation of _str-format_. The format specified is
identical to the format used for the `printf()` function in the ANSI C
language. Two or more _exp-data_ arguments can be specified for more
than one format specifier in _str-format_.

In an alternative syntax, the data to be formatted can be passed inside
a list in _list-data_.

`format` checks for a valid format string, matching data type, and the
correct number of arguments. Wrong formats or data types result in error
messages. link:#int[int], link:#float[float], or link:#string[string]
can be used to ensure correct data types and to avoid error messages.

The format string has the following general format:

*"%w.pf"*

The `%` (percent sign) starts a format specification. To display a `%`
inside a format string, double it: `%%`

The `w` represents the width field. Data is right-aligned, except when
preceded by a minus sign, in which case it is left-aligned. If preceded
by a `+` (plus sign), positive numbers are displayed with a `+`. When
preceded by a `0` (zero), the unused space is filled with leading
zeroes. The width field is optional and serves all data types.

The `p` represents the precision number of decimals (floating point
only) or strings and is separated from the width field by a period.
Precision is optional. When using the precision field on strings, the
number of characters displayed is limited to the number in `p`.

The `f` represents a type flag and is essential; it cannot be omitted.

Below are the types in `f`:

[cols="1<,10<",width="30%",options="header",]
|===================================================
|format |description
|s |text string
|c |character (value 1 - 255)
|d |decimal (32-bit)
|u |unsigned decimal (32-bit)
|x |hexadecimal lowercase
|X |hexadecimal uppercase
|o |octal (32-bits) (not supported on all compilers)
|f |floating point
|e |scientific floating point
|E |scientific floating point
|g |general floating point
|===================================================

Formatting 64-bit numbers using 32-bit format specifiers will truncate
and format the lower 32 bits of the number.

For 64-bit numbers use the following format strings on Unix-like
operating systems:

[cols="1<,10<",width="20%",options="header",]
|==================================
|format |description
|lld |decimal (64-bit)
|llu |unsigned decimal (64-bit)
|llx |hexadecimal (64-bit)
|llX |hexadecimal uppercase(64-bit)
|==================================

For 64-bit numbers (since version 8.9.7) use the following format
strings on Tru64 Unix:

[cols="1<,10<",width="20%",options="header",]
|=================================
|format |description
|ld |decimal (64-bit)
|lu |unsigned decimal (64-bit)
|lx |hexadecimal (64-bit)
|lX |hexadecimal uppercase(64-bit)
|=================================

On Win32 platforms the following characters apply for 64 bit numbers:

[cols="1<,10<",width="20%",options="header",]
|===================================
|format |description
|I64d |decimal (64-bit)
|I64u |unsigned decimal (64-bit)
|I64x |hexadecimal (64-bit)
|I64X |hexadecimal uppercase(64-bit)
|===================================

Other text may occur between, before, or after the format specs.

Note that on Tru64 Unix the format character `i` can be used instead of
`d`.

[source,newlisp]
--------------------------------------------------------
(format ">>>%6.2f<<<" 1.2345)     → ">>>  1.23<<<"
(format ">>>%-6.2f<<<" 1.2345)    → ">>>1.23  <<<"
(format ">>>%+6.2f<<<" 1.2345)    → ">>> +1.23<<<"
(format ">>>%+6.2f<<<" -1.2345)   → ">>> -1.23<<<"
(format ">>>%-+6.2f<<<" -1.2345)  → ">>>-1.23 <<<"

(format "%e" 123456789)        → "1.234568e+08"
(format "%12.10E" 123456789)   → "1.2345678900E+08"

(format "%10g" 1.23)   → "      1.23"
(format "%10g" 1.234)  → "     1.234"

(format "Result = %05d" 2)  → "Result = 00002"

(format "%-15s" "hello")        → "hello          "
(format "%15s %d" "hello" 123)  → "          hello 123"
(format "%5.2s" "hello")        → "   he"
(format "%-5.2s" "hello")       → "he   "

(format "%o" 80)    → "120"

(format "%x %X" -1 -1)  → "ffffffff FFFFFFFF"

; 64 bit numbers on Windows
(format "%I64X" 123456789012345678)  → "1B69B4BA630F34E"

; 64 bit numbers on Unix (except TRU64)
(format "%llX" 123456789012345678)   → "1B69B4BA630F34E"

(format "%c" 65)  → "A"
--------------------------------------------------------

The data to be formatted can be passed inside a list:

[source,newlisp]
---------------------------------------------
(set 'L '("hello" 123))
(format "%15s %d" L)  → "          hello 123"
---------------------------------------------

If the format string requires it, newLISP's `format` will automatically
convert integers into floating points or floating points into integers:

[source,newlisp]
-----------------------------------
(format "%f" 123)      → 123.000000

(format "%d" 123.456)  → 123
-----------------------------------

function::fv[]

*syntax:* (fv _num-rate_ _num-nper_ _num-pmt_ _num-pv_ [_int-type_])

Calculates the future value of a loan with constant payment _num-pmt_
and constant interest rate _num-rate_ after _num-nper_ period of time
and a beginning principal value of _num-pv_. If payment is at the end of
the period, _int-type_ is `0` (zero) or _int-type_ is omitted; for
payment at the beginning of each period, _int-type_ is 1.

[source,newlisp]
------------------------------------------------------
(fv (div 0.07 12) 240 775.30 -100000)  → -0.5544645052
------------------------------------------------------

The example illustrates how a loan of $100,000 is paid down to a
residual of $0.55 after 240 monthly payments at a yearly interest rate
of 7 percent.

See also the functions link:#irr[irr], link:#nper[nper], link:#npv[npv],
link:#pmt[pmt], and link:#pv[pv].

function::gammai[]

*syntax:* (gammai _num-a_ _num-b_)

Calculates the incomplete Gamma function of values _a_ and _b_ in
_num-a_ and _num-b_, respectively.

[source,newlisp]
----------------------------
(gammai 4 5)  → 0.7349740847
----------------------------

The incomplete Gamma function is used to derive the probability of Chi²
to exceed a given value for a degree of freedom, df, as follows:

_______________________________________________________
_*Q(Chi²|df) = Q(df/2, Chi²/2) = gammai(df/2, Chi²/2)*_
_______________________________________________________

See also the link:#prob-chi2[prob-chi2] function.

function::gammaln[]

*syntax:* (gammaln _num-x_)

Calculates the log Gamma function of the value _x_ in _num-x_.

[source,newlisp]
------------------------
(exp (gammaln 6))  → 120
------------------------

The example uses the equality of _n! = gamma(n + 1)_ to calculate the
factorial value of 5.

The log Gamma function is also related to the Beta function, which can
be derived from it:

___________________________________________________________
_*Beta(z,w) = Exp(Gammaln(z) + Gammaln(w) - Gammaln(z+w))*_
___________________________________________________________

function::gcd[]

*syntax:* (gcd _int-1_ [_int-2_ ... ])

Calculates the greatest common divisor of a group of integers. The
greatest common divisor of two integers that are not both zero is the
largest integer that divides both numbers. `gcd` will calculate the
greatest common divisor for the first two integers in _int-i_ and then
further reduce the argument list by calculating the greatest common
divisor of the result and the next argument in the parameter list.

[source,newlisp]
-------------------
(gcd 0)        → 0
(gcd 0 0)      → 0
(gcd 10)       → 10
(gcd 12 36)    → 12
(gcd 15 36 6)  → 3
-------------------

See http://en.wikipedia.org/wiki/Greatest_common_divisor[Wikipedia] for
details and theory about gcd numbers in mathematics.

function::get-char[]

*syntax:* (get-char _int-address_)

Gets an 8-bit character from an address specified in _int-address_. This
function is useful when using imported shared library functions with
link:#import[import].

[source,c]
---------------------------
char * foo(void)
        {
        char * result;
        result = "ABCDEFG";
        return(result);
        }
---------------------------

Consider the above C function from a shared library, which returns a
character pointer (address to a string).

[source,newlisp]
-------------------------------------------------
(import "mylib.so" "foo")
(print (get-char (foo) ))       →  65 ; ASCII "A"
(print (get-char (+ (foo) 1)))  →  66 ; ASCII "B"
-------------------------------------------------

Note that it is unsafe to use the `get-char` function with an incorrect
address in _int-address_. Doing so could result in the system crashing
or becoming unstable.

See also the link:#address[address], link:#get-int[get-int],
link:#get-long[get-long], link:#get-float[get-float],
link:#get-string[get-string], link:#pack[pack], and link:#unpack[unpack]
functions.

function::get-float[]

*syntax:* (get-float _int-address_)

Gets a 64-bit double float from an address specified in _int-address_.
This function is helpful when using imported shared library functions
(with `import`) that return an address pointer to a double float or a
pointer to a structure containing double floats.

[source,c]
------------------------------
double float * foo(void)
        {
        double float * result;
        …
        *result = 123.456;
        return(result);
        }
------------------------------

The previous C function is compiled into a shared library.

[source,newlisp]
----------------------------
(import "mylib.so" "foo")
(get-float (foo))  → 123.456
----------------------------

`foo` is imported and returns a pointer to a double float when called.
Note that `get-float` is unsafe when used with an incorrect address in
_int-address_ and may result in the system crashing or becoming
unstable.

See also the link:#address[address], link:#get-int[get-int],
link:#get-long[get-long], link:#get-char[get-char],
link:#get-string[get-string], link:#pack[pack], and link:#unpack[unpack]
functions.

function::get-int[]

*syntax:* (get-int _int-address_)

Gets a 32-bit integer from the address specified in _int-address_. This
function is handy when using imported shared library functions with
`import`, a function returning an address pointer to an integer, or a
pointer to a structure containing integers.

[source,c]
-----------------------
int * foo(void)
        {
        int * result;
        …
        *result = 123;
        return(result);
        }

int foo-b(void)
        {
        int result;
        …
        result = 456;
        return(result);
        }
-----------------------

Consider the C function `foo` (from a shared library), which returns an
integer pointer (address of an integer).

[source,newlisp]
-------------------------
(import "mylib.so" "foo")
(get-int (foo))  → 123
(foo-b)          → 456
-------------------------

Note that using `get-int` with an incorrect address in _int-address_ is
unsafe and could result in the system crashing or becoming unstable.

See also the link:#address[address], link:#get-char[get-char],
link:#get-float[get-float], link:#get-long[get-long],
link:#get-string[get-string], link:#pack[pack], and link:#unpack[unpack]
functions.

function::get-long[]

*syntax:* (get-long _int-address_)

Gets a 64-bit integer from the address specified in _int-address_. This
function is handy when using `import` to import shared library
functions, a function returning an address pointer to a long integer, or
a pointer to a structure containing long integers.

[source,c]
-------------------------
long long int * foo(void)
        {
        int * result;
        …
        *result = 123;
        return(result);
        }

long long int foo-b(void)
        {
        int result;
        …
        result = 456;
        return(result);
        }
-------------------------

Consider the C function `foo` (from a shared library), which returns an
integer pointer (address of an integer).

[source,newlisp]
-------------------------
(import "mylib.so" "foo")
(get-int (foo))  → 123
(foo-b)          → 456
-------------------------

Note that using `get-long` with an incorrect address in _int-address_ is
unsafe and could result in the system crashing or becoming unstable.

See also the link:#address[address], link:#get-char[get-char],
link:#get-float[get-float], link:#get-int[get-int],
link:#get-string[get-string], link:#pack[pack], and link:#unpack[unpack]
functions.

function::get-string[]

*syntax:* (get-string _int-address_)

Gets a character string from the address specified in _int-address_.
This function is helpful when using imported shared library functions
with link:#import[import].

[source,c]
---------------------------
char * foo(void)
        {
        char * result;
        result = "ABCDEFG";
        return(result);
        }
---------------------------

Consider the above C function from a shared library, which returns a
character pointer (address to a string).

[source,newlisp]
---------------------------------------
(import "mylib.so" "foo")
(print (get-string (foo)))  → "ABCDEFG"
---------------------------------------

When a string is passed as an argument, `get-string` will take its
address as the argument. Because `get-string` always breaks off at the
first first `\000` (null character) it encounters, it can be used to
retrieve a string from a buffer:

[source,newlisp]
--------------------------------------------------------
(set 'buff "ABC\000\000\000DEF")  → "ABC\000\000\000DEF"

(length buff)  → 9

(get-string buff)  → "ABC"

(length (get-string buff))  → 3

; get a string from offset into a buffer
(get-string (+ (address buff) 6)) → "DEF"

; use unpack to get the whole buffer
(unpack "s9" buff)  → ("ABC\000\000\000DEF")
--------------------------------------------------------

See also the link:#get-char[get-char], link:#get-int[get-int],
link:#get-float[get-float], link:#pack[pack], and link:#unpack[unpack]
functions.

Note that `get-string` can crash the system or make it unstable if the
wrong address is specified.

function::get-url[]

*syntax:* (get-url _str-url_ [_str-option_] [_int-timeout_ [_str-header_]])

Reads a web page or file specified by the URL in _str-url_ using the
HTTP GET protocol. Both `http://` and `file://` URLs are handled.
`"header"` can be specified in the optional argument _str-option_ to
retrieve only the header. The option `"list"` causes header and page
information to be returned as separate strings in a list.

A `"debug"` option can be specified either alone or after the `"header"`
or `"list"` option separated by one character, i.e. `"header debug"` or
`"list debug"`. Including "debug" outputs all outgoing information to
the console window.

The optional argument _int-timeout_ can specify a value in milliseconds.
If no data is available from the host after the specified timeout,
`get-url` returns the string `ERR: timeout`. When other error conditions
occur, `get-url` returns a string starting with `ERR:` and the
description of the error.

`get-url` handles redirection if it detects a `Location:` spec in the
received header and automatically does a second request. `get-url` also
understands the `Transfer-Encoding: chunked` format and will unpack data
into an unchunked format.

`get-url` requests are also understood by newLISP server nodes.

[source,newlisp]
---------------------------------------------------------------
(get-url "http://www.nuevatec.com")
(get-url "http://www.nuevatec.com" 3000)
(get-url "http://www.nuevatec.com" "header")
(get-url "http://www.nuevatec.com" "header" 5000)
(get-url "http://www.nuevatec.com" "list")

(get-url "file:///home/db/data.txt") ; access local file system

(env "HTTP_PROXY" "http://ourproxy:8080")
(get-url "http://www.nuevatec.com/newlisp/")
---------------------------------------------------------------

The index page from the site specified in _str-url_ is returned as a
string. In the third line, only the HTTP header is returned in a string.
Lines 2 and 4 show a timeout value being used.

The second example shows usage of a `file://` URL to access
`/home/db/data.txt` on the local file system.

The third example illustrates the use of a proxy server. The proxy
server's URL must be in the operating system's environment. As shown in
the example, this can be added using the link:#env[env] function.

The _int-timeout_ can be followed by an optional custom header in
_str-header_:

Custom header
^^^^^^^^^^^^^

The custom header may contain options for browser cookies or other
directives to the server. When no _str-header_ is specified, newLISP
sends certain header information by default. After the following
request:

[source,newlisp]
------------------------------------
(get-url "http://somehost.com" 5000)
------------------------------------

newLISP will configure and send the request and header below:

-------------------------
GET / HTTP/1.1
Host: somehost.com
User-Agent: newLISP v8800
Connection: close
-------------------------

As an alternative, the _str-header_ option could be used:

[source,newlisp]
-------------------------------------------------------
(get-url "http://somehost.com" 5000
    "User-Agent: Mozilla/4.0\r\nCookie: name=fred\r\n")
-------------------------------------------------------

newLISP will now send the following request and header:

-----------------------
GET / HTTP/1.1
Host: somehost.com
User-Agent: Mozilla/4.o
Cookie: name=fred
Connection: close
-----------------------

Note that when using a custom header, newLISP will only supply the `GET`
request line, as well as the `Host:` and `Connection:` header entries.
newLISP inserts all other entries supplied in the custom header between
the `Host:` and `Connection:` entries. Each entry must end with a
carriage return line-feed pair: `\r\n`.

See an HTTP transactions reference for valid header entries.

Custom headers can also be used in the link:#put-url[put-url] and
link:#post-url[post-url] functions.

function::global[]

*syntax:* (global _sym-1_ [_sym-2_ ... ])

One or more symbols in _sym-1_ [_sym-2_ ... ] can be made globally
accessible from contexts other than MAIN. The statement has to be
executed in the MAIN context, and only symbols belonging to MAIN can be
made global. `global` returns the last symbol made global.

[source,newlisp]
----------------------------
(global 'aVar 'x 'y 'z)  → z

(define (foo x)
  (…))

(constant (global 'foo))
----------------------------

The second example shows how link:#constant[constant] and `global` can
be combined into one statement, protecting and making a previous
function definition global.

function::global?[]

*syntax:* (global? _sym_)

Checks if symbol in _sym_ is global. Built-in functions, context
symbols, and all symbols made global using the function
link:#global[global] are global:

[source,newlisp]
------------------------
global? 'print)   → true
(global 'var)     → var
(global? 'var)    → true

(constant (global 'foo))

(global? 'foo)    → true
------------------------

function::if[]

*syntax:* (if _exp-condition_ _exp-1_ [_exp-2_]) +
*syntax:* (if _exp-cond-1_ _exp-1_ _exp-cond-2_ _exp-2_ [ ... ])

If the value of _exp-condition_ is neither `nil` nor an empty list, the
result of evaluating _exp-1_ is returned; otherwise, the value of
_exp-2_ is returned. If _exp-2_ is absent, the value of _exp-condition_
is returned.

[source,newlisp]
---------------------------------------
(set 'x 50)                   → 50
(if (< x 100) "small" "big")  → "small"
(set 'x 1000)                 → 1000
(if (< x 100) "small" "big")  → "big"
(if (> x 2000) "big")         → nil
---------------------------------------

The second form of `if` works similarly to link:#cond[cond], except it
does not take parentheses around the condition-body pair of expressions.
In this form, `if` can have an unlimited number of arguments.

[source,newlisp]
----------------------------
(define (classify x)
    (if
        (< x 0) "negative"
        (< x 10) "small"
        (< x 20) "medium"
        (>= x 30) "big"
        "n/a"))

(classify 15)   → "medium"
(classify 100)  → "big"
(classify 22)   → "n/a"
(classify -10)  → "negative"
----------------------------

The last expression, `"n/a"`, is optional. When this option is omitted,
the evaluation of `(>= x 30)` is returned, behaving exactly like a
traditional link:#cond[cond] but without requiring parentheses around
the condition-expression pairs.

In any case, the whole `if` expression always returns the last
expression or condition evaluated.

See also the link:#unless[unless] function.

function::ifft[]

*syntax:* (ifft _list-num_)

Calculates the inverse discrete Fourier transform on a list of complex
numbers in _list-num_ using the FFT method (Fast Fourier Transform).
Each complex number is specified by its real part, followed by its
imaginary part. In case only real numbers are used, the imaginary part
is set to `0.0` (zero). When the number of elements in _list-num_ is not
an integer power of 2, `ifft` increases the number of elements by
padding the list with zeroes. When complex numbers are `0` in the
imaginary part, simple numbers can be used.

[source,newlisp]
---------------------------------------------------
(ifft (fft '((1 0) (2 0) (3 0) (4 0))))
→ ((1 0) (2 0) (3 0) (4 0))

;; when imaginary part is 0, plain numbers work too

(ifft (fft '(1 2 3 4)))
→ ((1 0) (2 0) (3 0) (4 0))
---------------------------------------------------

The inverse operation of `ifft` is the link:#fft[fft] function.

function::import[]

*syntax:* (import _str-lib-name_ _str-function-name_ ["cdecl"]) +
*syntax:* (import _str-lib-name_ _str-function-name_ _str-return-type_ [_str-param-type_ . . .]) +
*syntax:* (import _str-lib-name_)

Imports the function specified in _str-function-name_ from a shared
library named in _str-lib-name_. Depending on the syntax used, string
labels for return and parameter types can be specified

If the libary in _str-lib-name_ is not in the system's library path, the
full path name should be specified.

A function can be imported only once. A repeated import of the same
function will simply return the same - already allocated - function
address.

On _libffi_ enabled versions - capable of the second extended syntax -
imported symbols are protected against change and can only be modified
using link:#constant[constant].

The third syntax - on OSX, Linux and other Unix only - allows loading
libraries without importing functions. This is necessary when other
libraries need access to functions they need internally.

The simple `import` syntax
^^^^^^^^^^^^^^^^^^^^^^^^^^

Most library functions can be imported using the simpler first syntax.
The API expects all function arguments to be passed on the stack in
either _cdecl_ or _stdcall_ conventions. On 32-bit platforms, integers,
pointers to strings and buffers sometimes floating point values can be
passed as parameters. On 64-bit platforms only integers can be passed
but no floating point values. As return values only 32-bit or 64-bit
values and pointers are allowed. No floating point numbers can be
returned. Strings must be retrieved with the
link:#get-string[get-string] helper function. Regardless of these
limitations, most modules included in the distribution use this simple
import API.

If pointers are returned to strings or structures the following helper
functions can be used extract data: link:#get-char[get-char],
link:#get-int[get-int], link:#get-float[get-float],
link:#get-string[get-string], link:#unpack[unpack]

To pass pointers for data structures the following functions help to
pack data and calculate addresses: link:#address[address],
link:#pack[pack].

To transform newLISP data types into the data types needed by the
imported function, use the functions link:#float[float] for 64-bit
double floats, link:#flt[flt] for 32-bit floats, and link:#int[int] for
32-bit integers. By default, newLISP passes floating point numbers as
64-bit double floats, integers as 32-bit integers, and strings as 32-bit
integers for string addresses (pointers in C). Floats can only be used
with 32-bit versions of newLISP and libraries. To use floating point
numbers in a 64-bit environment use the link:#extended_import[extended
`import` syntax].

[source,newlisp]
------------------------------------------------------
;; define LIBC platform independent

(define LIBC (lookup ostype '(
    ("Win32" "msvcrt.dll")
    ("OSX" "libc.dylib")

(printf "%g %s %d %c\n" 1.23 "hello" 999 65)
1.23 hello 999 A
→ 17 ; return value

;; import Win32 DLLs in Win32 versions

(import "kernel32.dll" "GetTickCount")  → GetTickCount
(import "user32.dll" "MessageBoxA")     → MessageBoxA
(GetTickCount)                          → 3328896
------------------------------------------------------

In the first example, the string "1.23 hello 999 A" is printed as a side
effect, and the value 17 (number of characters printed) is returned. Any
C function can be imported from any shared library in this way.

The message box example pops up a Windows dialog box, which may be
hidden behind the console window. The console prompt does not return
until the 'OK' button is pressed in the message box.

[source,newlisp]
----------------------------------------------
;;this pops up a message box

(MessageBoxA 0 "This is the body" "Caption" 1)
----------------------------------------------

The other examples show several imports of Win32 DLL functions and the
details of passing values _by value_ or _by reference_. Whenever strings
or numbers are passed by reference, space must be reserved beforehand.

[source,newlisp]
----------------------------------------------------------
(import "kernel32.dll" "GetWindowsDirectoryA")

;; allocating space for a string return value
(set 'str (dup "\000" 64))  ; reserve space and initialize

(GetWindowsDirectoryA str (length str))

str  → "C:\\WINDOWS\000\000\000 ... "

;; use trim or get-string to cut of binary zeros
(get-string str)  → "C:\\WINDOWS"
(trim str)        → "C:\\WINDOWS"

(import "kernel32.dll" "GetComputerNameA")

;; allocate memory and initialize to zeros
(set 'str (dup "\000" 64))
(set 'len (length str)

;; call the function
;; the length of the string is passed as address reference
;; string str is automatically past by address (C pointer)
(GetComputerNameA str (address len))

str  → "LUTZ-PC\000\000 ... "

(trim str)  → "LUTZ-PC"
----------------------------------------------------------

`import` returns the address of the function, which can be used to
assign a different name to the imported function.

[source,newlisp]
--------------------------------------------
(set 'imprime (import "libc.so.6" "printf"))
→ printf@400862A0

(imprime "%s %d" "hola" 123)
→ "hola 123"
--------------------------------------------

The Win32 and Cygwin versions of newLISP uses standard call _stdcall_
conventions to call DLL library routines by default. This is necessary
for calling DLLs that belong to the Win32 operating system. Most
third-party DLLs are compiled for C declaration _cdecl_ calling
conventions and may need to specify the string `"cdecl"` as an
additional last argument when importing functions. newLISP compiled for
Mac OS X, Linux and other Unix systems uses the _cdecl_ calling
conventions by default and ignores any additional string.

[source,newlisp]
---------------------------------------------------------------------
;; force cdecl calling conventions on Win32
(import "sqlite.dll" "sqlite_open" "cdecl")  → sqlite_open <673D4888>
---------------------------------------------------------------------

Imported functions may take up to fourteen arguments. Note that floating
point arguments take up two spaces each (e.g., passing five floats takes
up ten of the fourteen parameters).

The extended `import` syntax
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The extended import API works with the second syntax. It is based on the
popular `libffi` library and is pre-installed on most OS platforms. The
API works with all atomic C data types for passed parameters and return
values. The extended API requires that parameter types are specified in
the `import` statement as string type labels. Programs written with
extended import API will run without change on 32-bit and 64-bit newLISP
and libraries. Integers, floating point values and strings can be
returned without using helper functions.

The following types can be specified for the return value in
_str-return-type_ and for function parameters in _str-param-type_:

[cols="1<,3<,3<",width="75%",options="header",]
|=======================================================================
|label |C type for return value and arguments |newLISP return and
argument type
|"void" |void (only as return type) |`nil` is returned

|"byte" |byte unsigned 8 bit |integer

|"char" |char signed 8 bit |integer

|"unsigned short int" |unsigned short int 16 bit |integer

|"short int" |short int signed 16 bit |integer

|"unsigned int" |unsigned int 32 bit |integer

|"int" |int signed 32 bit |integer

|"long" |long signed 32 or 64 bit depending on platform |integer

|"long long" |long long signed 64 bit |integer

|"float" |float 32 bit |IEEE-754 64 bit float cut to 32-bit precision

|"double" |double 64 bit |IEEE-754 64 bit float

|"char*" |char* 32 or 64 bit ptr depending on platform |displayable
string return (zero terminated) +
string buffer arg (no addr. since 10.4.2)

|"void*" |void* 32 or 64 bit ptr depending on platform |integer address
return +
either string buffer or integer address arg
|=======================================================================

The types `"char*"` and `"void*` can be interchanged and are treated
identical inside `libffi`. Depending on the type of arguments passed and
the type of return values, one or the other is used.

Aggregate types can be composed using the link:#struct[struct] function.

The following examples show how the extended `import` syntax can handle
return values of floating point values and strings:

[source,newlisp]
-----------------------------------------------------
;; return a float value, LIBC was defined earlier
;             name   return   arg
(import LIBC "atof" "double" "char*")
(atof "3.141") → 3.141

;; return a copied string
;             name     return  arg-1   arg-2
(import LIBC "strcpy" "char*" "char*" "char*")
(set 'from "Hello World")

(set 'to (dup "\000" (length from))) ; reserve memory
(strcpy to from) → "Hello World"
-----------------------------------------------------

The `char*` type takes a string buffer only. The `"void*` type can take
either a string buffer or a memory address number as input. When using
`"void*"` as a return type the address number of the result bufffer will
be returned. This is useful when returning pointers to data structures.
These pointers can then be used with link:#unpack[unpack] and
link:#struct[struct] for destructuring. In the following example the
return type is changed to `void*`:

[source,newlisp]
----------------------------------------------
(import LIBC "strcpy" "void*" "char*" "char*")
(set 'from "Hello World")
(set 'to (dup "\000" (length from)))

(strcpy to from)       → 2449424
(address to)           → 2449424
(unpack "s11" 2449424) → "Hello World"
(get-string 2449424)   → "Hello World"
to                     → "Hello World"
----------------------------------------------

A newLISP string is always passed by it's address reference.

For a more complex example see this
http://www.newlisp.org/syntax.cgi?code/opengl-demo-ffi-lsp.txt[OpenGL
demo].

Memory management
^^^^^^^^^^^^^^^^^

Any allocation performed by imported foreign functions has to be
de-allocated manually if there's no call in the imported API to do so.
See the http://www.newlisp.org/CodePatterns.html[Code Patterns in
newLISP] document for an example.

In case of calling foreign functions with passing by reference, memory
for variables needs to be allocated beforehand by newLISP — see import
of `GetWindowsDirectoryA` above — and hence, memory needs not be
deallocated manually, because it is managed automatically by newLISP.

function::inc[!]

*syntax:* (inc _place_ [_num_])

Increments the number in _place_ by `1.0` or by the optional number
_num_ and returns the result. `inc` performs float arithmetic and
converts integer numbers passed into floating point type.

_place_ is either a symbol or a place in a list structure holding a
number, or a number returned by an expression.

[source,newlisp]
--------------------
(set 'x 0)    → 0
(inc x)       → 1
x             → 1
(inc x 0.25)  → 1.25
x             → 1.25
(inc x)       → 2.25
--------------------

If a symbol for _place_ contains `nil`, it is treated as if containing
`0.0`:

[source,newlisp]
--------------------
z             → nil
(inc z)       → 1

(set 'z nil)
(inc z 0.01)  → 0.01
--------------------

Places in a list structure or a number returned by another expression
can be updated too:

[source,newlisp]
---------------------
(set 'l '(1 2 3 4))

(inc (l 3) 0.1) → 4.1

(inc (first l)) → 2

l → (2 2 3 4.1)

(inc (+ 3 4)) → 8
---------------------

Use the link:#inci[++] function for incrementing numbers in integer
mode. Use link:#dec[dec] to decrement numbers in floating point mode.

function::index[]

*syntax:* (index _exp-predicate_ _exp-list_)

Applies the predicate _exp-predicate_ to each element of the list
_exp-list_ and returns a list containing the indices of the elements for
which _exp-predicate_ is true.

[source,newlisp]
-------------------------------------------------
(index symbol? '(1 2 d 4 f g 5 h))  → (2 4 5 7)

(define (big? x) (> x 5))  → (lambda (x) (> x 5))

(index big? '(1 10 3 6 4 5 11))  → (1 3 6)

(select '(1 10 3 6 4 5 11) '(1 3 6)) → (1 3 6)
-------------------------------------------------

The predicate may be a built-in predicate, a user-defined function, or a
lambda expression.

Use the link:#filter[filter] function to return the elements themselves.

function::inf?[]

*syntax:* (inf? _float_)

If the value in _float_ is infinite the function returns `true` else
`nil`.

[source,newlisp]
-----------------------
(inf? (div 1 0)) → true

(div 0 0) → NaN
-----------------------

Note that an integer division by zero e.g. `(/ 1 0)` will throw an
"division by zero" error and not yield infinity. See also
link:#NaNp[NaN?] to check if a floating point number is valid.

function::int[]

*syntax:* (int _exp_ [_exp-default_ [_int-base_]])

If the expression in _exp_ evaluates to a number or a string, the result
is converted to an integer and returned. If _exp_ cannot be converted to
an integer, then `nil` or the evaluation of _exp-default_ will be
returned. This function is mostly used when translating strings from
user input or from parsing text. If _exp_ evaluates to a string, the
string must start with a digit; one or more spaces; or the `+` or `-`
sign. The string must begin with '`0x`' for hexadecimal strings or '`0`'
(zero) for octal strings. If _exp_ is invalid, `int` returns `nil` as a
default value if not otherwise specified.

A second optional parameter can be used to force the number base of
conversion to a specific value.

Integers larger than 9,223,372,036,854,775,807 are truncated to
9,223,372,036,854,775,807. Integers smaller than
-9,223,372,036,854,775,808 are truncated to -9,223,372,036,854,775,808.

When converting from a float (as in the second form of `int`), floating
point values larger or smaller than the integer maximum or minimum are
also truncated. A floating point expression evaluating to `NaN` is
converted to `0` (zero).

[source,newlisp]
---------------------------------------------
(int "123")          → 123
(int " 123")         → 123
(int "a123" 0)       → 0
(int (trim " 123"))  → 123
(int "0xFF")         → 255
(int "055")          → 45
(int "1.567")        → 1
(int 1.567)          → 1

(integer? 1.00)        → nil
(integer? (int 1.00))  → true

(int "1111" 0 2)  → 15   ; base 2 conversion
(int "0FF" 0 16)  → 255  ; base 16 conversion

(int 'xyz)     → nil
(int 'xyz 0)   → 0
(int nil 123)  → 123

(int "abc" (throw-error "not a number"))
→ ERR: user error : not a number

(print "Enter a num:")
(set 'num (int (read-line)))

(int (bits 12345) 0 2) → 12345
---------------------------------------------

The inverse function to `int` with base `2` is link:#bits[bits].

Use the link:#float[float] function to convert arguments to floating
point numbers.

function::integer?[]

*syntax:* (integer? _exp_)

Returns `true` only if the value of _exp_ is an integer; otherwise, it
returns `nil`.

[source,newlisp]
----------------------
(set 'num 123)  → 123
(integer? num)  → true
----------------------

function::intersect[]

*syntax:* (intersect _list-A_ _list-B_) +
*syntax:* (intersect _list-A_ _list-B_ _bool_)

In the first syntax, `intersect` returns a list containing one copy of
each element found both in _list-A_ and _list-B_.

[source,newlisp]
-------------------------------------------
(intersect '(3 0 1 3 2 3 4 2 1) '(1 4 2 5))
→ (2 4 1)
-------------------------------------------

In the second syntax, `intersect` returns a list of all elements in
_list-A_ that are also in _list-B_, without eliminating duplicates in
_list-A_. _bool_ is an expression evaluating to `true` or any other
value not `nil`.

[source,newlisp]
------------------------------------------------
(intersect '(3 0 1 3 2 3 4 2 1) '(1 4 2 5) true)
→ (1 2 4 2 1)
------------------------------------------------

See also the set functions link:#difference[difference],
link:#unique[unique] and link:#union[union].

function::invert[]

*syntax:* (invert _matrix_ [_float-pivot_])

Returns the inversion of a two-dimensional matrix in _matrix_. The
matrix must be square, with the same number of rows and columns, and
_non-singular_ (invertible). Matrix inversion can be used to solve
systems of linear equations (e.g., multiple regression in statistics).
newLISP uses LU-decomposition of the matrix to find the inverse.

Optionally `0.0` or a very small value can be specified in
_float-pivot_. This value substitutes pivot elements in the
LU-decomposition algorithm, which result in zero when the algorithm
deals with a singular matrix.

The dimensions of a matrix are defined by the number of rows times the
number of elements in the first row. For missing elements in
non-rectangular matrices, `0.0` (zero) is assumed. A matrix can either
be a nested list or an link:#array[array].

[source,newlisp]
--------------------------------------------------------------------
(set 'A '((-1 1 1) (1 4 -5) (1 -2 0)))
(invert A)  → ((10 2 9) (5 1 4) (6 1 5))
(invert (invert A)) → ((-1 1 1) (1 4 -5) (1 -2 0))

; solve Ax = b for x
(multiply (invert A) '((1) (2) (3))) → ((41) (19) (23))

; treatment of singular matrices
(invert '((2 -1) (4 -2)))        → nil
(invert '((2 -1) (4 -2)) 0.0)    → ((inf -inf) (inf -inf))
(invert '((2 -1) (4 -2)) 1e-20)  → ((5e+19 -2.5e+19) (1e+20 -5e+19))
--------------------------------------------------------------------

`invert` will return `nil` if the matrix is _singular_ and cannot be
inverted, and _float-pivot_ is not specified.

All operations shown here on lists can be performed on arrays, as well.

See also the matrix functions link:#det[det], link:#mat[mat],
link:#multiply[multiply] and link:#transpose[transpose].

function::irr[]

*syntax:* (irr _list-amounts_ [_list-times_ [_num-guess_]])

Calculates the internal rate of return of a cash flow per time period.
The internal rate of return is the interest rate that makes the present
value of a cash flow equal to `0.0` (zero). In-flowing (negative values)
and out-flowing (positive values) amounts are specified in
_list-amounts_. If no time periods are specified in _list-times_,
amounts in _list-amounts_ correspond to consecutive time periods
increasing by 1 (1, 2, 3—). The algorithm used is iterative, with an
initial guess of 0.5 (50 percent). Optionally, a different initial guess
can be specified. The algorithm returns when a precision of 0.000001
(0.0001 percent) is reached. `nil` is returned if the algorithm cannot
converge after 50 iterations.

_irr_ is often used to decide between different types of investments.

[source,newlisp]
-------------------------------------------------
(irr '(-1000 500 400 300 200 100))
→ 0.2027

(npv 0.2027 '(500 400 300 200 100))
→ 1000.033848 ; ~ 1000

(irr '(-1000 500 400 300 200 100) '(0 3 4 5 6 7))
→ 0.0998

(irr '(-5000 -2000 5000 6000) '(0 3 12 18))
→ 0.0321
-------------------------------------------------

If an initial investment of 1,000 yields 500 after the first year, 400
after two years, and so on, finally reaching `0.0` (zero) after five
years, then that corresponds to a yearly return of about 20.2 percent.
The next line demonstrates the relation between `irr` and
link:#npv[npv]. Only 9.9 percent returns are necessary when making the
first withdrawal after three years.

In the last example, securities were initially purchased for 5,000, then
for another 2,000 three months later. After a year, securities for 5,000
are sold. Selling the remaining securities after 18 months renders
6,000. The internal rate of return is 3.2 percent per month, or about 57
percent in 18 months.

See also the link:#fv[fv], link:#nper[nper], link:#npv[npv],
link:#pmt[pmt], and link:#pv[pv] functions.

function::join[]

*syntax:* (join _list-of-strings_ [_str-joint_ [_bool-trail-joint_]])

Concatenates the given list of strings in _list-of-strings_. If
_str-joint_ is present, it is inserted between each string in the join.
If _bool-trail-joint_ is `true` then a joint string is also appended to
the last string.

[source,newlisp]
---------------------------------------------------------
(set 'lst '("this" "is" "a" "sentence"))

(join lst " ")  → "this is a sentence"

(join (map string (slice (now) 0 3)) "-")  → "2003-11-26"

(join (explode "keep it together"))  → "keep it together"

(join '("A" "B" "C") "-")         → "A-B-C"
(join '("A" "B" "C") "-" true)    → "A-B-C-"
---------------------------------------------------------

See also the link:#append[append], link:#string[string], and
link:#explode[explode] functions, which are the inverse of the `join`
operation.

function::lambda[]

See the description of link:#fn[fn], which is a shorter form of writing
`lambda`.

function::lambda-macro[]

See the description of link:#define-macro[define-macro].

function::lambda?[]

*syntax:* (lambda? _exp_)

Returns `true` only if the value of _exp_ is a lambda expression;
otherwise, returns `nil`.

[source,newlisp]
--------------------------------------------------
(define (square x) (* x x)) → (lambda (x) (* x x))

square → (lambda (x) (* x x))

(lambda? square)  → true
--------------------------------------------------

See link:#define[define] and link:#define-macro[define-macro] for more
information about _lambda_ expressions.

function::last[utf8]

*syntax:* (last _list_) +
*syntax:* (last _array_) +
*syntax:* (last _str_)

Returns the last element of a list or a string.

[source,newlisp]
-----------------------------------------
(last '(1 2 3 4 5))  → 5
(last '(a b (c d)))  → (c d)

(set 'A (array 3 2 (sequence 1 6)))
→ ((1 2) (3 4) (5 6))
(last A)             → (5 6)

(last '())           → ERR: list is empty
-----------------------------------------

In the second version the last character in the string _str_ is returned
as a string.

[source,newlisp]
-----------------------
(last "newLISP")  → "P"
-----------------------

Note that link:#last[last] works on character boundaries rather than
byte boundaries when the UTF-8–enabled version of newLISP is used. See
also link:#first[first], link:#rest[rest] and link:#nth[nth].

function::last-error[]

*syntax:* (last-error) +
*syntax:* (last-error _int-error_)

Reports the last error generated by newLISP due to syntax errors or
exhaustion of some resource. For a summary of all possible errors see
the chapter link:#error_codes[Error codes] in the appendix.

If no error has occurred since the newLISP session was started, `nil` is
returned.

When _int-error_ is specified, a list of the number and the error text
is returned.

[source,newlisp]
---------------------------------------------------
(last-error)  → nil

(abc)

ERR: invalid function : (abc)

(last-error) → (24 "ERR: invalid function : (abc)")

(last-error 24) → (24 "invalid function")
(last-error 1) → (1 "not enough memory")
(last-error 12345) → (12345 "Unknown error")
---------------------------------------------------

For error numbers out of range the string `"Unknown error"` is given for
the error text.

Errors can be trapped by link:#error-event[error-event] and userdefined
error handlers.

See also link:#net-error[net-error] for errors generated by networking
conditions and link:#sys-error[sys-error] for errors generated by the
operating system.

function::legal?[]

*syntax:* (legal? _str_)

The token in _str_ is verified as a legal newLISP symbol. Non-legal
symbols can be created using the link:#sym[sym] function (e.g. symbols
containing spaces, quotes, or other characters not normally allowed).
Non-legal symbols are created frequently when using them for associative
data access:

[source,newlisp]
----------------------------------------------------
(symbol? (sym "one two"))  → true

(legal? "one two")         → nil  ; contains a space

(set (sym "one two") 123)  → 123

(eval (sym "one two"))     → 123
----------------------------------------------------

The example shows that the string `"one two"` does not contain a legal
symbol although a symbol can be created from this string and treated
like a variable.

function::length[]

*syntax:* (length _exp_)

Returns the number of elements in a list, the number of rows in an
array, or the number of bytes in a string.

`length` applied to a symbol returns the length of the symbol name.
Applied to a number, `length` returns the number of bytes needed in
memory to store that number: 4 or 8 for integers and 8 for floating
point numbers.

[source,newlisp]
----------------------------------------------------
(length '(a b (c d) e))         → 4
(length '())                    → 0
(set 'someList '(q w e r t y))  → (q w e r t y)
(length someList)               → 6

(set 'ary (array 2 4 '(0)))  → ((1 2 3 4) (5 6 7 8))
(length ary)                 → 2

(length "Hello World")  → 11
(length "")             → 0

(length 'someVar)  → 7
(length 123)       → 8
(length 1.23)      → 8

(length (get-int "\000\000\000\001")) → 4
----------------------------------------------------

Use link:#utf8len[utf8len] to calculate the number of UTF-8 characters
in a string.

function::let[]

*syntax:* (let ( (_sym1_ [_exp-init1_]) [(_sym2_ [_exp-init2_]) ... ]) _body_) +
*syntax:* (let (_sym1_ _exp-init1_ [_sym2_ _exp-init2_ ... ]) _body_)

One or more variables _sym1_, _sym2_, ... are declared locally and
initialized with expressions in _exp-init1_, _exp-init2_, etc. In the
fully parenthesized first syntax, initializers are optional and assumed
`nil` if missing.

When the local variables are initialized, the initializer expressions
evaluate using symbol bindings as before the `let` statement. To
incrementally use symbol bindings as evaluated during the initialization
of locals in `let`, use link:#letn[letn].

One or more expressions in _exp-body_ are evaluated using the local
definitions of _sym1_, _sym2_ etc. `let` is useful for breaking up
complex expressions by defining local variables close to the place where
they are used. The second form omits the parentheses around the variable
expression pairs but functions identically.

[source,newlisp]
---------------------------------------------------
(define (sum-sq a b)
    (let ((x (* a a)) (y (* b b)))
        (+ x y)))

(sum-sq 3 4) → 25

(define (sum-sq a b)           ; alternative syntax
    (let (x (* a a) y (* b b))
        (+ x y)))
---------------------------------------------------

The variables `x` and `y` are initialized, then the expression `(+ x y)`
is evaluated. The let form is just an optimized version and syntactic
convenience for writing:

[source,newlisp]
---------------------------------------------------------------
((lambda (sym1 [sym2 ... ]) exp-body ) exp-init1 [ exp-init2 ])
---------------------------------------------------------------

See also link:#letn[letn] for an incremental or nested form of `let` and
local for initializing to `nil`.

function::letex[]

*syntax:* (letex ( (_sym1_ [_exp-init1_]) [(_sym2_ [_exp-init2_]) ... ]) _body_) +
*syntax:* (letex (_sym1_ _exp-init1_ [_sym2_ _exp-init2_ ... ]) _body_)

This function combines link:#let[let] and link:#expand[expand] to expand
local variables into an expression before evaluating it. In the fully
parenthesized first syntax initializers are optional and assumed `nil`
if missing.

Both forms provide the same functionality, but in the second form the
parentheses around the initializers can be omitted:

[source,newlisp]
---------------------------------------------------
(letex (x 1 y 2 z 3) '(x y z))    → (1 2 3)

(letex ( (x 1) (y '(a b c)) (z "hello") ) '(x y z))

→ (1 (a b c) "hello")
---------------------------------------------------

Before the expression `'(x y z)` gets evaluated, `x, y` and `z` are
literally replaced with the initializers from the `letex` initializer
list. The final expression which gets evaluated is `'(1 2 3)`.

In the second example a function `make-adder` is defined for making
adder functions:

[source,newlisp]
---------------------------------------------------
(define (make-adder n)
    (letex (c n) (lambda (x) (+ x c))))

(define add3 (make-adder 3)) → (lambda (x) (+ x 3))

(add3 10) → 13
---------------------------------------------------

`letex` evaluates `n` to the constant `3` and replaces `c` with it in
the lambda expression.

function::letn[]

*syntax:* (letn ( (_sym1_ [_exp-init1_]) [(_sym2_ [_exp-init2_]) ... ]) _body_) +
*syntax:* (letn (_sym1_ _exp-init1_ [_sym2_ _exp-init2_ ... ]) _body_)

`letn` is like a _nested let_ and works similarly to link:#let[let], but
will incrementally use the new symbol bindings when evaluating the
initializer expressions as if several link:#let[let] were nested. In the
fully parenthesized first syntax, initializers are optional and assumed
`nil` if missing.

The following comparison of link:#let[let] and `letn` show the
difference:

[source,newlisp]
------------------------------
(set 'x 10)
(let ((x 1) (y (+ x 1)))
(list x y))           → (1 11)

(letn ((x 1) (y (+ x 1)))
(list x y))          → (1 2)
------------------------------

While in the first example using link:#let[let] the variable `y` is
calculated using the binding of `x` before the link:#let[let]
expression, in the second example using `letn` the variable `y` is
calculated using the new local binding of `x`.

[source,newlisp]
-------------------------
(letn  (x 1 y x)
(+ x y))             →  2

;; same as nested let's

(let (x 1)
(let (y x)
(+ x y)))       →  2
-------------------------

`letn` works like several _nested_ link:#let[let]. The parentheses
around the initializer expressions can be omitted.

function::list[]

*syntax:* (list _exp-1_ [_exp-2_ ... ])

The _exp_ are evaluated and the values used to construct a new list.
Note that arguments of array type are converted to lists.

[source,newlisp]
--------------------------------------------------
(list 1 2 3 4 5)                → (1 2 3 4 5)
(list 'a '(b c) (+ 3 4) '() '*) → (a (b c) 7 () *)
--------------------------------------------------

See also link:#cons[cons] and link:#push[push] for other forms of
building lists.

function::list?[]

*syntax:* (list? _exp_)

Returns `true` only if the value of _exp_ is a list; otherwise returns
`nil`. Note that lambda and lambda-macro expressions are also recognized
as special instances of a list expression.

[source,newlisp]
------------------------------------
(set 'var '(1 2 3 4))    → (1 2 3 4)
(list? var)              → true

(define (double x) (+ x x))

(list? double)           → true
------------------------------------

function::load[]

*syntax:* (load _str-file-name-1_ [_str-file-name-2_ ... ] [_sym-context_])

Loads and translates newLISP from a source file specified in one or more
_str-file-name_ and evaluates the expressions contained in the file(s).
When loading is successful, `load` returns the result of the last
expression in the last file evaluated. If a file cannot be loaded,
`load` throws an error.

An optional _sym-context_ can be specified, which becomes the context of
evaluation, unless such a context switch is already present in the file
being loaded. By default, files which do not contain
link:#context[context] switches will be loaded into the `MAIN` context.

The _str-file-name_ specs can contain URLs. Both `http://` and
` file://` URLs are supported.

[source,newlisp]
--------------------------------------------------------
(load "myfile.lsp")

(load "a-file.lsp" "b-file.lsp")

(load "file.lsp" "http://mysite.org/mypro")

(load "http://192.168.0.21:6000//home/test/program.lsp")

(load "a-file.lsp" "b-file.lsp" 'MyCTX)

(load "file:///usr/share/newlisp/mysql.lsp")
--------------------------------------------------------

In case expressions evaluated during the `load` are changing the
link:#context[context], this will not influence the programming module
doing the `load`.

The current context after the `load` statement will always be the same
as before the `load`.

Normal file specs and URLs can be mixed in the same load command.

`load` with `HTTP` URLs can also be used to load code remotely from
newLISP server nodes running on a Unix-like operating system. In this
mode, `load` will issue an HTTP GET request to the target URL. Note that
a double backslash is required when path names are specified relative to
the root directory. `load` in `HTTP` mode will observe a 60-second
timeout.

The second to last line causes the files to be loaded into the context
`MyCTX`. The quote forces the context to be created if it did not exist.

The `file://` URL is followed by a third `/` for the directory spec.

function::log[]

*syntax:* (log _num_) +
*syntax:* (log _num_ _num-base_)

In the first syntax, the expression in _num_ is evaluated and the
natural logarithmic function is calculated from the result.

[source,newlisp]
-------------------
(log 1)         → 0
(log (exp 1))   → 1
-------------------

In the second syntax, an arbitrary base can be specified in _num-base_.

[source,newlisp]
-----------------------------
(log 1024 2)             → 10
(log (exp 1) (exp 1))    →  1
-----------------------------

See also link:#exp[exp], which is the inverse function to `log` with
base *_e_* (2.718281828).

function::lookup[]

*syntax:* (lookup _exp-key_ _list-assoc_ [_int-index_ [_exp-default_]])

Finds in _list-assoc_ an association, the key element of which has the
same value as _exp-key_, and returns the _int-index_ element of
association (or the last element if _int-index_ is absent).

Optionally, _exp-default_ can be specified, which is returned if an
association matching _exp-key_ cannot be found. If the _exp-default_ is
absent and no association has been found, `nil` is returned.

See also link:#indexing[Indexing elements of strings and lists].

`lookup` is similar to link:#assoc[assoc] but goes one step further by
extracting a specific element found in the list.

[source,newlisp]
-------------------------------------------------------
(set 'params '(
    (name "John Doe")
    (age 35)
    (gender "M")
    (balance 12.34)
))

(lookup 'age params)             → 35

; use together with setf to modify and association list
(setf (lookup 'age params) 42)   → 42
(lookup 'age params)             → 42

(set 'persons '(
    ("John Doe" 35 "M" 12.34)
    ("Mickey Mouse" 65 "N" 12345678)
))

(lookup "Mickey Mouse" persons 2)    → "N"
(lookup "Mickey Mouse" persons -3)   → 65
(lookup "John Doe" persons 1)        → 35
(lookup "John Doe" persons -2)       → "M"

(lookup "Jane Doe" persons 1 "N/A")  → "N/A"
-------------------------------------------------------

See also link:#assoc[assoc]

[[lower-case]]
function::lower-case[utf8]

*syntax:* (lower-case _str_)

Converts the characters of the string in _str_ to lowercase. A new
string is created, and the original is left unaltered.

[source,newlisp]
-------------------------------------------
(lower-case "HELLO WORLD")  → "hello world"
(set 'Str "ABC")
(lower-case Str)  → "abc"
Str               → "ABC"
-------------------------------------------

See also the link:#upper-case[upper-case] and
link:#title-case[title-case] functions.

function::macro?[]

*syntax:* (macro? _exp_)

returns `true` if _exp_ evaluates to a lambda-macro expression;
otherwise, `nil` is returned.

[source,newlisp]
------------------------------------------------
(define-macro (mysetq lv rv) (set lv (eval rv)))

(macro? mysetq)  → true
------------------------------------------------

function::main-args[]

*syntax:* (main-args) +
*syntax:* (main-args _int-index_)

`main-args` returns a list with several string members, one for program
invocation and one for each of the command-line arguments.

[source,newlisp]
--------------------------------
newlisp 1 2 3

> (main-args)
("/usr/bin/newlisp" "1" "2" "3")
--------------------------------

After `newlisp 1 2 3` is executed at the command prompt, `main-args`
returns a list containing the name of the invoking program and three
command-line arguments.

Optionally, `main-args` can take an _int-index_ for indexing into the
list. Note that an index out of range will cause `nil` to be returned,
not the last element of the list like in list-indexing.

[source,newlisp]
------------------
newlisp a b c

> (main-args 0)
"/usr/bin/newlisp"
> (main-args -1)
"c"
> (main-args 2)
"b"
> (main-args 10)
nil
------------------

Note that when newLISP is executed from a script, `main-args` also
returns the _name_ of the script as the second argument:

[source,newlisp]
---------------------------------------------------------
#!/usr/bin/newlisp
#
# script to show the effect of 'main-args' in script file

(print (main-args) "\n")
(exit)

# end of script file

;; execute script in the OS shell:

script 1 2 3

("/usr/bin/newlisp" "./script" "1" "2" "3")
---------------------------------------------------------

Try executing this script with different command-line parameters.

function::make-dir[]

*syntax:* (make-dir _str-dir-name_ [_int-mode_])

Creates a directory as specified in _str-dir-name_, with the optional
access mode _int-mode_. Returns `true` or `nil` depending on the
outcome. If no access mode is specified, most Unix systems default to
`drwxr-xr-x`.

On Unix systems, the access mode specified will also be masked by the
OS's _user-mask_ set by the system administrator. The _user-mask_ can be
retrieved on Unix systems using the command `umask` and is usually
`0022` (octal), which masks write (and creation) permission for
non-owners of the file.

[source,newlisp]
----------------------------------------------------
;; 0 (zero) in front of 750 makes it an octal number

(make-dir "adir" 0750)
----------------------------------------------------

This example creates a directory named `adir` in the current directory
with an access mode of `0750` (octal 750 = `drwxr-x---`).

function::map[]

*syntax:* (map _exp-functor_ _list-args-1_ [_list-args-2_ ... ])

Successively applies the primitive function, defined function, or lambda
expression _exp-functor_ to the arguments specified in _list-args-1,
list-args-2—_, returning all results in a list.

[source,newlisp]
-------------------------------------------------------------
(map + '(1 2 3) '(50 60 70))  → (51 62 73)

(map if '(true nil true nil true) '(1 2 3 4 5) '(6 7 8 9 10))
→ '(1 7 3 9 5)

(map (fn (x y) (* x y)) '(3 4) '(20 10))
→ (60 40)
-------------------------------------------------------------

The second example shows how to dynamically create a function for `map`:

[source,newlisp]
------------------------------------------------
(define (foo op p)
    (append (lambda (x)) (list (list op p 'x))))
------------------------------------------------

We can also use the shorter `fn`:

[source,newlisp]
--------------------------------------------
(define (foo op p)
    (append (fn (x)) (list (list op p 'x))))
--------------------------------------------

`foo` now works like a function-maker:

[source,newlisp]
-----------------------------------------------
(foo 'add 2)  → (lambda (x) (add 2 x))

(map (foo add 2) '(1 2 3 4 5))  → (3 4 5 6 7)

(map (foo mul 3) '(1 2 3 4 5))  → (3 6 9 12 15)
-----------------------------------------------

Note that the quote before the operand can be omitted because primitives
evaluate to themselves in newLISP.

By incorporating `map` into the function definition, we can do the
following:

[source,newlisp]
----------------------------------------------
(define (list-map op p lst)
    (map (lambda (x) (op p x)) lst))

(list-map + 2 '(1 2 3 4))  → (3 4 5 6)

(list-map mul 1.5 '(1 2 3 4))  → (1.5 3 4.5 6)
----------------------------------------------

`map` also sets the internal list index `$idx`.

[source,newlisp]
-----------------------------------------------------------
(map (fn (x) (list $idx x)) '(a b c)) → ((0 a) (1 b) (2 c))
-----------------------------------------------------------

The number of arguments used is determined by the length of the first
argument list. Arguments missing in other argument lists cause map to
stop collecting parameters for that level of arguments. This ensures
that the nth parameter list gets converted to the nth column during the
transposition occurring. If an argument list contains too many elements,
the extra ones will be ignored.

Special forms which use parentheses as syntax cannot be mapped (i.e.
link:#case[case]).

function::mat[]

*syntax:* (mat _+_ | _-_ | _*_ | _/_ _matrix-A matrix-B_) +
*syntax:* (mat _+_ | _-_ | _*_ | _/_ _matrix-A number_)

Using the first syntax, this function performs fast floating point
scalar operations on two-dimensional matrices in _matrix-A_ or
_matrix-B_. The type of operation is specified by one of the four
arithmetic operators `+`, `-`, `*`, or `/`. This type of arithmetic
operator is typically used for integer operations in newLISP. In the
case of `mat`, however, all operations will be performed as floating
point operations (`add`, `sub`, `mul`, `div`).

Matrices in newLISP are two-dimensional lists or arrays. Internally,
newLISP translates lists and arrays into fast, accessible C-language
data objects. This makes matrix operations in newLISP as fast as those
coded directly in C. The same is true for the matrix operations
link:#multiply[multiply] and link:#invert[invert].

[source,newlisp]
-------------------------------------
(set 'A '((1 2 3) (4 5 6)))
(set 'B A)

(mat + A B)    → ((2 4 6) (8 10 12))
(mat - A B)    → ((0 0 0) (0 0 0))
(mat * A B)    → ((1 4 9) (16 25 36))
(mat / A B)    → ((1 1 1) (1 1 1))

; specify the operator in a variable

(set 'op +)
(mat op A B)    → ((2 4 6) (8 10 12))
-------------------------------------

Using the second syntax, all cells in _matrix-A_ are operated on with a
scalar in _number_:

[source,newlisp]
----------------------------------------
(mat + A 5)    → ((6 7 8) (9 10 11))
(mat - A 2)    → ((-1 0 1) (2 3 4))
(mat * A 3)    → ((3 6 9) (12 15 18))
(mat / A 10)   → ((.1 .2 .3) (.4 .5 .6))
----------------------------------------

See also the other matrix operations link:#det[det],
link:#invert[invert], link:#multiply[multiply], and
link:#transpose[transpose].

function::match[]

*syntax:* (match _list-pattern_ _list-match_ [_bool_])

The pattern in _list-pattern_ is matched against the list in
_list-match_, and the matching expressions are returned in a list. The
three wildcard characters `?`, `+`, and `*` can be used in
_list-pattern_.

Wildcard characters may be nested. `match` returns a list of matched
expressions. For each `?` (question mark), a matching expression element
is returned. For each `+` (plus sign) or `*` (asterisk), a list
containing the matched elements is returned. If the pattern cannot be
matched against the list in _list-match_, `match` returns `nil`. If no
wildcard characters are present in the pattern an empty list is
returned.

Optionally, the Boolean value `true` (or any other expression not
evaluating to `nil`) can be supplied as a third argument. This causes
`match` to show all elements in the returned result.

`match` is frequently employed as a functor parameter in
link:#find[find], link:#ref[ref], link:#ref-all[ref-all] and
link:#replace[replace] and is internally used by
link:#find-all[find-all] for lists.

[source,newlisp]
--------------------------------------------------------
(match '(a ? c) '(a b c))  → (b)

(match '(a ? ?) '(a b c))  → (b c)

(match '(a ? c) '(a (x y z) c))  → ((x y z))

(match '(a ? c) '(a (x y z) c) true)  → (a (x y z) c)

(match '(a ? c) '(a x y z c))  → nil

(match '(a * c) '(a x y z c))  → ((x y z))

(match '(a (b c ?) x y z) '(a (b c d) x y z))  → (d)

(match '(a (*) x ? z) '(a (b c d) x y z))  → ((b c d) y)

(match '(+) '())  → nil

(match '(+) '(a))  → ((a))

(match '(+) '(a b))  → ((a b))

(match '(a (*) x ? z) '(a () x y z))  → (() y)

(match '(a (+) x ? z) '(a () x y z))  → nil
--------------------------------------------------------

Note that the `*` operator tries to grab the fewest number of elements
possible, but `match` backtracks and grabs more elements if a match
cannot be found.

The `+` operator works similarly to the `*` operator, but it requires at
least one list element.

The following example shows how the matched expressions can be bound to
variables.

[source,newlisp]
--------------------------------------------------------
(map set '(x y) (match '(a (? c) d *) '(a (b c) d e f)))

x  → b
y  → (e f)
--------------------------------------------------------

Note that `match` for strings has been eliminated. For more powerful
string matching, use link:#regex[regex], link:#find[find],
link:#find-all[find-all] or link:#parse[parse].

link:#unify[unify] is another function for matching expressions in a
PROLOG like manner.

function::max[]

*syntax:* (max _num-1_ [_num-2_ ... ])

Evaluates the expressions _num-1_— and returns the largest number.

[source,newlisp]
---------------------------
(max 4 6 2 3.54 7.1)  → 7.1
---------------------------

See also the link:#min[min] function.

function::member[]

*syntax:* (member _exp_ _list_) +
*syntax:* (member _str-key_ _str_ [_num-option_])

In the first syntax, `member` searches for the element _exp_ in the list
_list_. If the element is a member of the list, a new list starting with
the element found and the rest of the original list is constructed and
returned. If nothing is found, `nil` is returned. When specifying
_num-option_, `member` performs a regular expression search.

[source,newlisp]
----------------------------------------------------
(set 'aList '(a b c d e f g h))  → (a b c d e f g h)
(member 'd aList)                → (d e f g h)
(member 55 aList)                → nil
----------------------------------------------------

In the second syntax, `member` searches for _str-key_ in _str_. If
_str-key_ is found, all of _str_ (starting with _str-key_) is returned.
`nil` is returned if nothing is found.

[source,newlisp]
--------------------------------------
(member "LISP" "newLISP")  → "LISP"
(member "LI" "newLISP")    → "LISP"
(member "" "newLISP")      → "newLISP"
(member "xyz" "newLISP")   → nil
(member "li" "newLISP" 1)  → "LISP"
--------------------------------------

See also the related functions link:#slice[slice] and link:#find[find].

function::min[]

*syntax:* (min _num-1_ [_num-2_ ... ])

Evaluates the expressions _num-1_— and returns the smallest number.

[source,newlisp]
-------------------------
(min 4 6 2 3.54 7.1)  → 2
-------------------------

See also the link:#max[max] function.

function::mod[]

*syntax:* (mod _num-1_ _num-2_ [_num-3_ ... ]) +
*syntax:* (mod _num-1_)

Calculates the modular value of the numbers in _num-1_ and _num-2_.
`mod` computes the remainder from the division of the numerator _num-i_
by the denominator _num-i + 1_. Specifically, the return value is
_numerator - n * denominator_, where `n` is the quotient of the
numerator divided by the denominator, rounded towards zero to an
integer. The result has the same sign as the numerator and its magnitude
is less than the magnitude of the denominator.

In the second syntax `1` is assumed for _num-2_ and the result is the
fractional part of _num-1_.

[source,newlisp]
-----------------------
(mod 10.5 3.3)   →  0.6
(mod -10.5 3.3)  → -0.6
(mod -10.5)      → -0.5
-----------------------

Use the link:#arithmetic[%] (percent sign) function when working with
integers only.

function::mul[]

*syntax:* (mul _num-1_ _num-2_ [_num-3_ ... ])

Evaluates all expressions _num-1_—, calculating and returning the
product. `mul` can perform mixed-type arithmetic, but it always returns
floating point numbers. Any floating point calculation with `NaN` also
returns `NaN`.

[source,newlisp]
---------------------------
(mul 1 2 3 4 5 1.1)  → 132
(mul 0.5 0.5)        → 0.25
---------------------------

function::multiply[]

*syntax:* (multiply _matrix-A_ _matrix-B_)

Returns the matrix multiplication of matrices in _matrix-A_ and
_matrix-B_. If _matrix-A_ has the dimensions _n_ by _m_ and _matrix-B_
the dimensions _k_ by _l_ (_m_ and _k_ must be equal), the result is an
_n_ by _l_ matrix. ` multiply` can perform mixed-type arithmetic, but
the results are always double precision floating points, even if all
input values are integers.

The dimensions of a matrix are determined by the number of rows and the
number of elements in the first row. For missing elements in
non-rectangular matrices, `0.0` is assumed. A matrix can either be a
nested list or link:#array[array].

[source,newlisp]
-------------------------------------------------
(set 'A '((1 2 3) (4 5 6)))
(set 'B '((1 2) (1 2) (1 2)))
(multiply A B)  → ((6 12) (15 30))

(set 'v '(10 20 30))
(multiply A (transpose (list v))) → ((140) (320))
-------------------------------------------------

When multiplying a matrix with a vector of `n` elements, the vector must
be transformed into `n` rows by `1` column matrix using
link:#transpose[transpose].

All operations shown here on lists can be performed on arrays, as well.

See also the matrix operations link:#det[det], link:#invert[invert],
link:#mat[mat] and link:#transpose[transpose].

function::name[]

This function is deprecated, use link:#term[term] instead.

function::NaN?[]

*syntax:* (NaN? _float_)

Tests if the result of a floating point math operation is a `NaN`.
Certain floating point operations return a special IEEE 754 number
format called a `NaN` for 'Not a Number'.

[source,newlisp]
-------------------------------------------
; floating point operation on NaN yield NaN
(set 'x (sqrt -1))  → NaN
(NaN? x)            → true
(add x 123)         → NaN
(mul x 123)         → NaN

; integer operations treat NaN as zero
(+ x 123)  → 123
(* x 123)  → 0

; comparisons with NaN values yield nil
(> x 0)   → nil
(<= x 0)  → nil
(= x x)   → nil

(set 'infinity (mul 1.0e200 1.0e200)) → inf
(NaN? (sub infinity infinity)) → true
-------------------------------------------

Note that all floating point arithmetic operations with a `NaN` yield a
`NaN`. All comparisons with `NaN` return `nil`, but `true` when
comparing to itself. Comparison with itself, however, would result in
_not_ `true` when using ANSI C. Integer operations treat `NaN` as `0`
(zero) values.

See also link:#infp[inf?] for testing a floating point value for
infinity.

function::net-accept[]

*syntax:* (net-accept _int-socket_)

Accepts a connection on a socket previously put into listening mode.
Returns a newly created socket handle for receiving and sending data on
this connection.

[source,newlisp]
-------------------------------
(set 'socket (net-listen 1234))
(net-accept socket)
-------------------------------

Note that for ports less than 1024, newLISP must be started in superuser
mode on Unix-like operating systems.

See also the files `server` and `client` examples in the `examples/`
directory of the source distribution.

function::net-close[]

*syntax:* (net-close _int-socket_ [_true_])

Closes a network socket in _int-socket_ that was previously created by a
link:#net-connect[net-connect] or link:#net-accept[net-accept] function.
Returns `true` on success and `nil` on failure.

[source,newlisp]
-----------------
(net-close aSock)
-----------------

The optional _true_ flag suppresses immediate shutdown of sockets by
waiting for pending data transmissions to finish.

function::net-connect[]

*syntax:* (net-connect _str-remote-host_ _int-port_ [_int-timeout-ms_]) +
*syntax:* (net-connect _str-remote-host_ _int-port_ [_str-mode_ [_int-ttl_]]) +
*syntax:* (net-connect _str-file-path_)

In the first syntax, connects to a remote host computer specified in
_str-remote-host_ and a port specified in _int-port_. Returns a socket
handle after having connected successfully; otherwise, returns `nil`.

[source,newlisp]
--------------------------------------------
(set 'socket (net-connect "example.com" 80))
(net-send socket "GET /\r\n\r\n")
(net-receive socket buffer 10000)
(println buffer)
(exit)
--------------------------------------------

If successful, the `net-connect` function returns a socket number which
can be used to send and receive information from the host. In the
example a HTTP GET request is sent and subsequently a web page received.
Note that newLISP has already a buit-in function link:#get-url[get-url]
offering the same functionality.

Optionally a timeout value _int-timeout_ in milli seconds can be
specified. Without a timeout value the function will wait up to 10
seconds for an open port. With a timeout value the function can be made
to return on an unavailable port much earlier or later. The following
example shows a port scanner looking for open ports:

[source,newlisp]
-------------------------------------------------------------------------
(set 'host (main-args 2))
(println "Scanning: " host)
(for (port 1 1024)
    (if (set 'socket (net-connect host port 500))
        (println "open port: " port " " (or (net-service port "tcp") ""))
        (print port "\r"))
)
-------------------------------------------------------------------------

The programs takes the host string from the shell command line as either
a domain name or an IP number in dot notation then tries to open each
port from 1 to 1024. For each openport the port number and the service
description string is printed. If no description is available, an empty
string "" is output. For closed ports the function outputs numbers in
the shell window staying on the same line.

On Unix `net-connnect` may return with `nil` before the timeout expires,
when the port is not available. On Win32 `net-connect` will always wait
for the timout to expire before failing with `nil`.

UDP communications
^^^^^^^^^^^^^^^^^^

In the second syntax, a third parameter, the string `"udp"` or `"u"` can
be specified in the optional _str-mode_ to create a socket suited for
UDP (User Datagram Protocol) communications. In UDP mode, `net-connect`
does _not_ try to connect to the remote host, but creates the socket and
binds it to the remote address, if an address is specified. A subsequent
link:#net-send[net-send] will send a UDP packet containing that target
address. When using link:#net-send-to[net-send-to], only one of the two
functions `net-connect` or `net-send-to` should provide a target
address. The other function should specify and empty string `""` as the
target address.

[source,newlisp]
----------------------------------------
;; example server
(net-listen 4096 "226.0.0.1" "udp")  → 5
(net-receive-from 5 20)

;; example client I
(net-connect "226.0.0.1" 4096 "udp") → 3
(net-send 3 "hello")

;; example client II
(net-connect "" 4096 "udp") → 3
(net-send-to "226.0.0.1" 4096 "hello" 3)
----------------------------------------

The functions link:#net-receive[net-receive] and
link:#net-receive-from[net-receive-from] can both be used and will
perform UDP communications when the `"udp"` option as been used in
`net-listen` or `net-connect`. link:#net-select[net-select] and
link:#net-peek[net-peek] can be used to check for received data in a
non-blocking fashion.

link:#net-listen[net-listen] binds a specific local address and port to
the socket. When `net-connect` is used, the local address and port will
be picked by the socket-stack functions of the host OS.

UDP multicast communications
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When specifying `"multi"` or `"m"` as a third parameter for _str-mode_,
a socket for UDP multicast communications will be created. Optionally,
the fourth parameter `int-ttl` can be specified as a TTL (time to live)
value. If no _int-ttl_ value is specified, a value of 3 is assumed.

Note that specifying UDP multicast mode in `net-connect` does not
actually establish a connection to the target multicast address but only
puts the socket into UDP multicasting mode. On the receiving side, use
link:#net-listen[net-listen] together with the UDP multicast option.

[source,newlisp]
-------------------------------------------
;; example client I
(net-connect "" 4096 "multi")  → 3
(net-send-to "226.0.0.1" 4096 "hello" 3)

;; example client II
(net-connect "226.0.0.1" 4096 "multi")  → 3
(net-send 3 "hello")

;; example server
(net-listen 4096 "226.0.0.1" "multi")  → 5
(net-receive-from 5 20)
→ ("hello" "192.168.1.94" 32769)
-------------------------------------------

On the server side, link:#net-peek[net-peek] or
link:#net-select[net-select] can be used for non-blocking
communications. In the above example, the server would block until a
datagram is received.

The address `226.0.0.1` is just one multicast address in the Class D
range of multicast addresses from `224.0.0.0` to `239.255.255.255`.

The link:#net-send[net-send] and link:#net-receive[net-receive]
functions can also be used instead of link:#net-send-to[net-send-to] and
link:#net-receive-from[net-receive-from].

UDP broadcast communications
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Specifying the string `"broadcast"` or `"b"` in the third parameter,
_str-mode_, causes UDP broadcast communications to be set up. In this
case, the broadcast address ending in 255 is used.

[source,newlisp]
---------------------------------------------------
;; example client
(net-connect "192.168.2.255" 3000 "broadcast")  → 3
(net-send 3 "hello")

;; example server
(net-listen 3000 "" "udp")  → 5

(net-receive 5 buff 10)
buff  → "hello"
;; or
(net-receive-from 5 10)
→ ("hello" "192.168.2.1" 46620)
---------------------------------------------------

Note that on the receiving side, link:#net-listen[net-listen] should be
used with the default address specified with an `""` (empty string).
Broadcasts will not be received when specifying an address. As with all
UDP communications, link:#net-listen[net-listen] does not actually put
the receiving side in listen mode, but rather sets up the sockets for
the specific UDP mode.

The link:#net-select[net-select] or link:#net-peek[net-peek] functions
can be used to check for incoming communications in a non-blocking
fashion.

Local domain Unix sockets
^^^^^^^^^^^^^^^^^^^^^^^^^

In the third syntax, `net-connect` connects to a server on the local
file system via a _local domain Unix socket_ named using
_str-file-path_. Returns a socket handle after having connected
successfully; otherwise, returns `nil`.

[source,newlisp]
----------------------------------
(net-connect "/tmp/mysocket")  → 3

; on OS/2 use "\\socket\\" prefix

(net-connect "\\socket\\mysocket")
----------------------------------

A _local domain_ file system socket is created and returned. On the
server side, _local domain_ sockets have been created using
link:#net-listen[net-listen] and link:#net-accept[net-accept]. After the
connection has been established the functions
link:#net-select[net-select], link:#net-send[net-send] and
link:#net-receive[net-receive] can be used as usual for TCP/IP stream
communications. This type of connection can be used as a fast
bi-directional communications channel between processes on the same file
system. This type of connection is not available on Win32 platforms.

function::net-error[]

*syntax:* (net-error) +
*syntax:* (net-error _int-error_)

Retrieves the last error that occurred when calling a any of the
following functions: link:#net-accept[net-accept],
link:#net-connect[net-connect], link:#net-eval[net-eval],
link:#net-listen[net-listen], link:#net-lookup[net-lookup],
link:#net-receive[net-receive], link:#net-receive-udp[net-receive-udp],
link:#net-select[net-select], link:#net-send[net-send],
link:#net-send-udp[net-send-udp], and link:#net-service[net-service].
Whenever one of these functions fails, it returns `nil` and `net-error`
can be used to retrieve more information.

Functions that communicate using sockets close the socket automatically
and remove it from the link:#net-sessions[net-sessions] list.

Each successful termination of a link:#socket_tcpip[net-*] function
clears the error number.

The following messages are returned:

[cols="1<,5<",width="40%",options="header",]
|=====================================
|no |description
|1 |Cannot open socket
|2 |DNS resolution failed
|3 |Not a valid service
|4 |Connection failed
|5 |Accept failed
|6 |Connection closed
|7 |Connection broken
|8 |Socket send() failed
|9 |Socket recv() failed
|10 |Cannot bind socket
|11 |Too many sockets in net-select
|12 |Listen failed
|13 |Badly formed IP
|14 |Select failed
|15 |Peek failed
|16 |Not a valid socket
|17 |Cannot unblock socket
|18 |Operation timed out
|19 |HTTP bad formed URL
|20 |HTTP file operation failed
|21 |HTTP transfer failed
|22 |HTTP invalid response from server
|23 |HTTP no response from server
|24 |HTTP document empty
|25 |HTTP error in header
|26 |HTTP error in chunked format
|=====================================

[source,newlisp]
-------------------------------------------------
(net-error) → nil

(net-connect "jhghjgkjhg" 80)  →  nil

(net-error)  →  (2 "ERR: "DNS resolution failed")
-------------------------------------------------

When _int-error_ is specified the number and error text for that error
number is returned.

[source,newlisp]
------------------------------------------
(net-error 10) → (10 "Cannot bind socket")
------------------------------------------

See also link:#last-error[last-error] and link:#sys-error[sys-error].

function::net-eval[]

*syntax:* (net-eval _str-host_ _int-port_ _exp_ [_int-timeout_ [_func-handler_]]) +
*syntax:* (net-eval '( (_str-host_ _int-port_ _exp_) ... ) [_int-timeout_ [_func-handler_]])

Can be used to evaluate source remotely on one or more newLISP servers.
This function handles all communications necessary to connect to the
remote servers, send source for evaluation, and wait and collect
responses.

The expression in _exp_ evaluates to either a string or an expression
which will be evaluated remotely in the environment of the target node.

The remote TCP/IP servers are started in the following way:

[source,sh]
-----------------------------------------
newlisp -c -d 4711 &

; or with logging connections

newlisp -l -c -d 4711 &

; communicate via Uix local domain socket

newlisp -c /tmp/mysocket
-----------------------------------------

Instead of `4711`, any other port number can be used. Multiple nodes can
be started on different hosts and with the same or different port
numbers. The `-l` or `-L` logging options can be specified to log
connections and remote commands.

The `-d` daemon mode allows newLISP to maintain state between
connections. When keeping state between connections is not desired, the
link:#inetd_daemon[inetd daemon mode] offers more advantages. The
Internet `inetd` or `xinetd` services daemon will start a new newLISP
process for each client connection. This makes for much faster servicing
of multiple connections. In `-d` daemon mode, each new client request
would have to wait for the previous request to be finished. See the
chapter link:#inetd_daemon[inetd daemon mode] on how to configure this
mode correctly.

In the first syntax, `net-eval` talks to only one remote newLISP server
node, sending the host in _str-host_ on port _int-port_ a request to
evaluate the expression _exp_. If _int-timeout_ is not given, `net-eval`
will wait up to 60 seconds for a response after a connection is made.
Otherwise, if the timeout in milliseconds has expired, `nil` is
returned; else, the evaluation result of _exp_ is returned.

[source,newlisp]
-------------------------------------------------------------------------------
; the code to be evaluated is given in a quoted expression
(net-eval "192.168.1.94" 4711 '(+ 3 4))       → 7

; expression as a string
(net-eval "192.168.1.94" 4711 "(+ 3 4)")      → 7

; with timeout
(net-eval "192.168.1.94" 4711 '(+ 3 4) 1)     → nil  ; timeout to short
(net-error)                                   → (17 "ERR: Operation timed out")

(net-eval "192.168.1.94" 4711 '(+ 3 4) 1000)  → 7

; program contained in a variable
(set 'prog '(+ 3 4))
(net-eval "192.168.1.94" 4711 prog)           → 7

; specify a local-domain Unix socket (not available on Win32)
(net-eval "/tmp/mysocket" 0 '(+ 3 4))         → 7
-------------------------------------------------------------------------------

The second syntax of `net-eval` returns a list of the results after all
of the responses are collected or timeout occurs. Responses that time
out return `nil`. The last example line shows how to specify a
local-domain Unix socket specifying the socket path and a port number of
`0`. Connection errors or errors that occur when sending information to
nodes are returned as a list of error numbers and descriptive error
strings. See the function link:#net-error[net-error] for a list of
potential error messages.

[source,newlisp]
------------------------------------------------------
; two different remote nodes different IPs
(net-eval '(
    ("192.168.1.94" 4711 '(+ 3 4))
    ("192.168.1.95" 4711 '(+ 5 6))
    ) 5000)
→ (7 11)

; two persistent nodes on the same CPU different ports
(net-eval '(
    ("localhost" 8081 '(foo "abc"))
    ("localhost" 8082 '(myfunc 123)')
    ) 3000)

; inetd or xinetd nodes on the same server and port
; nodes are loaded on demand
(net-eval '(
    ("localhost" 2000 '(foo "abc"))
    ("localhost" 2000 '(myfunc 123))
    ) 3000)
------------------------------------------------------

The first example shows two expressions evaluated on two different
remote nodes. In the second example, both nodes run on the local
computer. This may be useful when debugging or taking advantage of
multiple CPUs on the same computer. When specifying `0` for the port
number , `net-eval` takes the host name as the file path to the
local-domain Unix socket.

Note that definitions of `foo` and `myfunc` must both exist in the
target environment. This can be done using a `net-eval` sending `define`
statements before. It also can be done by preloading code when starting
remode nodes.

When nodes are inetd or xinetd-controlled, several nodes may have the
same IP address and port number. In this case, the Unix daemon inetd or
xinetd will start multiple newLISP servers on demand. This is useful
when testing distributed programs on just one machine. The last example
illustrates this case. It is also useful on multi core CPUs, where the
platform OS can distribute different processes on to different CPU
cores.

The source sent for evaluation can consist of entire multiline programs.
This way, remote nodes can be loaded with programs first, then specific
functions can be called. For large program files, the functions
link:#put-url[put-url] or link:#save[save] (with a URL file name) can be
used to transfer programs. The a `net-eval` statement could load these
programs.

Optionally, a handler function can be specified. This function will be
repeatedly called while waiting and once for every remote evaluation
completion.

[source,newlisp]
---------------------------------------------------------------------------
(define (myhandler param)
    (if param
        (println param))
)

(set 'Nodes '(
    ("192.168.1.94" 4711)
    ("192.168.1.95" 4711)
))

(set 'Progs '(
    (+ 3 4)
    (+ 5 6)
))

(net-eval (map (fn (n p) (list (n 0) (n 1) p)) Nodes Progs) 5000 myhandler)
→
("192.168.1.94" 4711 7)
("192.168.1.95" 4711 11)
---------------------------------------------------------------------------

The example shows how the list of node specs can be assembled from a
list of nodes and sources to evaluate. This may be useful when
connecting to a larger number of remote nodes.

[source,newlisp]
------------------------------------------
(net-eval (list
  (list (Nodes 0 0) (Nodes 0 1) (Progs 0))
  (list (Nodes 1 0) (Nodes 1 1) (Progs 1))
 ) 3000 myhandler)
------------------------------------------

While waiting for input from remote hosts, `myhandler` will be called
with `nil` as the argument to `param`. When a remote node result is
completely received, `myhandler` will be called with `param` set to a
list containing the remote host name or IP number, the port, and the
resulting expression. `net-eval` will return `true` before a timeout or
`nil` if the timeout was reached or exceeded. All remote hosts that
exceeded the timeout limit will contain a `nil` in their results list.

For a longer example see this program:
http://www.newlisp.org/syntax.cgi?code/mapreduce.txt[mapreduce]. The
example shows how a word counting task gets distributed to three remote
nodes. The three nodes count words in different texts and the master
node receives and consolidates the results.

function::net-interface[]

*syntax:* (net-interface _str-ip-addr_) +
*syntax:* (net-interface)

Sets the default local interface address to be used for network
connections. If not set then network functions will default to an
internal default address, except when overwritten by an optional
interface address given in link:#net-listen[net-listen].

When no _str-ip-addr_ is specified, the current default is returned. If
the `net-interface` has not been used yet to specify an IP address, the
address `0.0.0.0` is returned. This means that all network routines will
use the default address preconfigured by the underlying operating
system.

This function has only usage on multihomed servers with either multiple
network interface hardware or otherwise supplied multiple IP numbers. On
all other machines network functions will automatically select the
single network interface installed.

On error the function returns `nil` and link:#net-error[net-error] can
be used to report the error.

[source,newlisp]
------------------------------------------------
(net-interface "192.168.1.95")  → "192.168.1.95"
(net-interface "localhost")     → "127.0.0.1"
------------------------------------------------

An interface address can be defined as either an IP address or a name.
The return value is the address given in _str-ip-addr_

function::net-ipv[]

*syntax:* (net-ipv _int-version_) +
*syntax:* (net-ipv)

Switches between IPv4 and IPv6 internet protocol versions. _int-version_
contains either a 4 for IPv4 or a 6 for IPv6. When no parameter is
given, `net-ipv` returns the current setting.

[source,newlisp]
------------------
(net-ipv)      → 4
(net-ipv 6)    → 6
------------------

By default newLISP starts up in IPv4 mode. The IPv6 protocol mode can
also be specified from the commandline when starting newlisp:

[source,sh]
----------
newlisp -6
----------

Once a socket is connected with either link:#net-connect[net-connect] or
listened on with link:#net-listen[net-listen], the
link:#net-accept[net-accept], link:#net-select[net-select],
link:#net-send[net-send], link:#net-receive[net-receive] and
link:#net-receive-from[net-receive-from] functions automatically adjust
to the address protocol used when creating the sockets. Different
connections with different IPv4/6 settings can be open at the same time.

Note, that currently link:#net-packet[net-packet] does not support IPv6
and will work in IPv4 mode regardless of settings.

function::net-listen[]

*syntax:* (net-listen _int-port_ [_str-ip-addr_ [_str-mode_]]) +
*syntax:* (net-listen _str-file-path_)

Listens on a port specified in _int-port_. A call to `net-listen`
returns immediately with a socket number, which is then used by the
blocking link:#net-accept[net-accept] function to wait for a connection.
As soon as a connection is accepted, link:#net-accept[net-accept]
returns a socket number that can be used to communicate with the
connecting client.

[source,newlisp]
--------------------------------------------------
(set 'port 1234)
(set 'listen (net-listen port))
(unless listen (begin
    (print "listening failed\n")
    (exit)))

(print "Waiting for connection on: " port "\n")

(set 'connection (net-accept listen))
(if connection
    (while (net-receive connection buff 1024 "\n")
        (print buff)
        (if (= buff "\r\n") (exit)))
    (print "Could not connect\n"))
--------------------------------------------------

The example waits for a connection on port 1234, then reads incoming
lines until an empty line is received. Note that listening on ports
lower than 1024 may require superuser access on Unix systems.

On computers with more than one interface card, specifying an optional
interface IP address or name in _str-ip-addr_ directs `net-listen` to
listen on the specified address.

[source,newlisp]
--------------------------------
;; listen on a specific address
(net-listen port "192.168.1.54")
--------------------------------

Local domain Unix sockets
^^^^^^^^^^^^^^^^^^^^^^^^^

In the second syntax, `net-listen` listens for a client on the local
file system via a _local domain Unix socket_ named using
_str-file-path_. If successful, returns a socket handle that can be used
with link:#net-accept[net-accept] to accept a client connection;
otherwise, returns `nil`.

[source,newlisp]
---------------------------------
(net-listen "/tmp/mysocket")  → 5

; on OS/2 use "\\socket\\" prefix

(net-listen "\\socket\\mysocket")

(net-accept 5)
---------------------------------

A _local domain_ file system socket is created and listened on. A client
will try to connect using the same _str-file-path_. After a connection
has been accepted the functions link:#net-select[net-select],
link:#net-send[net-send] and link:#net-receive[net-receive] can be used
as usual for TCP/IP stream communications. This type of connection can
be used as a fast bi-directional communications channel between
processes on the same file system. This type of connection is not
available on Win32 platforms.

UDP communications
^^^^^^^^^^^^^^^^^^

As a third parameter, the optional string `"udp"` or `"u"` can be
specified in _str-mode_ to create a socket suited for UDP (User Datagram
Protocol) communications. A socket created in this way can be used
directly with link:#net-receive-from[net-receive-from] to await incoming
UDP data _without_ using `net-accept`, which is only used in TCP
communications. The link:#net-receive-from[net-receive-from] call will
block until a UDP data packet is received. Alternatively,
link:#net-select[net-select] or link:#net-peek[net-peek] can be used to
check for ready data in a non-blocking fashion. To send data back to the
address and port received with link:#net-receive-from[net-receive-from],
use link:#net-send-to[net-send-to].

Note that link:#net-peer[net-peer] will not work, as UDP communications
do not maintain a connected socket with address information.

[source,newlisp]
----------------------------------------
(net-listen 10002 "192.168.1.120" "udp")

(net-listen 10002 "" "udp")
----------------------------------------

The first example listens on a specific network adapter, while the
second example listens on the default adapter. Both calls return a
socket number that can be used in subsequent
link:#net-receive[net-receive],
link:#net-receive-from[net-receive-from],
link:#net-send-to[net-send-to], link:#net-select[net-select], or
link:#net-peek[net-peek] function calls.

Both a UDP server _and_ UDP client can be set up using `net-listen` with
the `"udp"` option. In this mode, `net-listen` does not really _listen_
as in TCP/IP communications; it just binds the socket to the local
interface address and port.

For a working example, see the files `examples/client` and
`examples/server` in the newLISP source distribution.

Instead of `net-listen` and the `"udp"` option, the functions
link:#net-receive-udp[net-receive-udp] and
link:#net-send-udp[net-send-udp] can be used for short transactions
consisting only of one data packet.

`net-listen`, link:#net-select[net-select], and link:#net-peek[net-peek]
can be used to facilitate non-blocking reading. The listening/reading
socket is not closed but is used again for subsequent reads. In
contrast, when the link:#net-receive-udp[net-receive-udp] and
link:#net-send-udp[net-send-udp] pair is used, both sides close the
sockets after sending and receiving.

UDP multicast communications
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If the optional string _str-mode_ is specified as `"multi"` or `"m"`,
`net-listen` returns a socket suitable for multicasting. In this case,
_str-ip-addr_ contains one of the multicast addresses in the range
`224.0.0.0` to `239.255.255.255`. `net-listen` will register
_str-ip-addr_ as an address on which to receive multicast transmissions.
This address should not be confused with the IP address of the server
host.

[source,newlisp]
-------------------------------------------
;; example client

(net-connect "226.0.0.1" 4096 "multi")  → 3

(net-send-to "226.0.0.1" 4096 "hello" 3)

;; example server

(net-listen 4096 "226.0.0.1" "multi")  → 5

(net-receive-from 5 20)
→ ("hello" "192.168.1.94" 32769)
-------------------------------------------

On the server side, link:#net-peek[net-peek] or
link:#net-select[net-select] can be used for non-blocking
communications. In the example above, the server would block until a
datagram is received.

The link:#net-send[net-send] and link:#net-receive[net-receive]
functions can be used instead of link:#net-send-to[net-send-to] and
link:#net-receive-from[net-receive-from].

Packet divert sockets and ports
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If _str-mode_ is specified as `"divert"`, a divert socket can be created
for a divert port in _int-port_ on BSD like platforms. The content of IP
address in _str-ip-addr_ is ignored and can be specifed as an empty
string. Only the _int-port_ is relevant and will be bound to the raw
socket returned.

To use the divert option in `net-listen`, newLISP must run in super-user
mode. This option is only available on Unix like platforms.

The divert socket will receive all raw packets diverted to the divert
port. Packets may also be written back to a divert socket, in which case
they re-enter OS kernel IP packet processing.

Rules for packet diversion to the divert port must be defined using
either the _ipfw_ BSD or _ipchains_ Linux configuration utilities.

The link:#net-receive-from[net-receive-from] and
link:#net-send-to[net-send-to] functions are used to read and write raw
packets on the divert socket created and returned by the `net-listen`
statement. The same address received by
link:#net-receive-from[net-receive-from] is used in the
link:#net-send-to[net-send-to] call when re-injecting the packet:

[source,newlisp]
----------------------------------------------------------
; rules have been previously configured for a divert port
(set 'divertSocket (net-listen divertPort "" "divert"))

(until (net-error)
    (set 'rlist (net-receive-from divertSocket maxBytes))
    (set 'buffer (rlist 1))
    ; buffer can be processed here before reinjecting
    (net-send-to (rlist 0) divertPort buffer divertSocket)
)
----------------------------------------------------------

For more information see the Unix man pages for _divert_ and the _ipfw_
(BSDs) or _ipchains_ (Linux) configuration utilities.

function::net-local[]

*syntax:* (net-local _int-socket_)

Returns the IP number and port of the local computer for a connection on
a specific _int-socket_.

[source,newlisp]
-----------------------------------------
(net-local 16)  → ("204.179.131.73" 1689)
-----------------------------------------

Use the link:#net-peer[net-peer] function to access the remote
computer's IP number and port.

function::net-lookup[]

*syntax:* (net-lookup _str-ip-number_) +
*syntax:* (net-lookup _str-hostname_ [_bool_])

Returns either a hostname string from _str-ip-number_ in IP dot format
or the IP number in dot format from _str-hostname_:

[source,newlisp]
-----------------------------------------------------
(net-lookup "209.24.120.224")    → "www.nuevatec.com"
(net-lookup "www.nuevatec.com")  → "209.24.120.224"

(net-lookup "216.16.84.66.sbl-xbl.spamhaus.org" true)
→ "216.16.84.66"
-----------------------------------------------------

Optionally, a _bool_ flag can be specified in the second syntax. If the
expression in _bool_ evaluates to anything other than `nil`,
host-by-name lookup will be forced, even if the name string starts with
an IP number.

function::net-packet[]

*syntax:* (net-packet _str-packet_)

The function allows custom configured network packets to be sent via a
_raw sockets_ interface. The packet in _str-packet_ must start with an
IP (Internet Protocol) header followed by either a TCP, UDP or ICMP
header and optional data. newLISP must be run with super user
privileges, and this function is only available on Mac OS X, Linux and
other Unix operating systems and only for IPv4. Currently `net-packet`
is IPv4 only and has been tested on MAC OS X, Linux and OpenBSD.

On success the function returns the number of bytes sent. On failure the
function returns `nil` and both, link:#net-error[net-error] and
link:#sys-error[sys-error], should be inspected.

When custom configured packets contains zeros in the checksum fields,
`net-packet` will calculate and insert the correct checksums. Already
existing checksums stay untouched.

The following example injects a UDP packet for IP number `192.168.1.92`.
The IP header consists of 20 bytes ending with the target IP number. The
following UDP header has a length of 8 bytes and is followed by the data
string `Hello World`. The checksum bytes in both headers are left as
`0x00 0x00` and will be recalculated internally.

[source,newlisp]
-----------------------------------------------------------------------------------
; packet as generated by: (net-send-udp "192.168.1.92" 12345 "Hello World")

(set 'udp-packet (pack (dup "b" 39) '(
    0x45 0x00 0x00 0x27 0x4b 0x8f 0x00 0x00 0x40 0x11 0x00 0x00 192  168  1    95
    192  168  1    92   0xf2 0xc8 0x30 0x39 0x00 0x13 0x00 0x00 0x48 0x65 0x6c 0x6c
    0x6f 0x20 0x57 0x6f 0x72 0x6c 0x64)))

(unless (net-packet udp-packet)
    (println "net-error: " (net-error))
    (println "sys-error: " (sys-error)))
-----------------------------------------------------------------------------------

The `net-packet` function is used when testing net security. Its wrong
application can upset the correct functioning of network routers and
other devices connected to a network. For this reason the function
should only be used on well isolated, private intra-nets and only by
network professionals.

For other examples of packet configuration, see the file
`qa-specific-tests/qa-packet` in the newLISP source distribution.

function::net-peek[]

*syntax:* (net-peek _int-socket_)

Returns the number of bytes ready for reading on the network socket
_int-socket_. If an error occurs or the connection is closed, `nil` is
returned.

[source,newlisp]
--------------------------------------------
(set 'aSock (net-connect "aserver.com" 123))

(while ( = (net-peek aSock) 0)
    (do-something-else))

(net-receive aSock buff 1024)
--------------------------------------------

After connecting, the program waits in a while loop until `aSock` can be
read.

Use the link:#peek[peek] function to check file descriptors and `stdin`.

function::net-peer[]

*syntax:* (net-peer _int-socket_)

Returns the IP number and port number of the remote computer for a
connection on _int-socket_.

[source,newlisp]
--------------------------------------
(net-peer 16)  → ("192.100.81.100" 13)
--------------------------------------

Use the link:#net-local[net-local] function to access the local
computer's IP number and port number.

function::net-ping[]

*syntax:* (net-ping _str-address_ [_int-timeout_ [_int-count_ _bool_]]]) +
*syntax:* (net-ping _list-addresses_ [_int-timeout_ [_int-count_ _bool_]]])

This function is only available on Unix-based systems and must be run in
superuser mode, i.e. using: `sudo newlisp` to start newLISP on Mac OS X
or other BSD's, or as the root user on Linux. Broadcast mode and
specifying ranges with the `-` (hyphen) or _*_ (star) are not available
on IPv6 address mode.

Since version 10.1.7, superuser mode is not required on Mac OS X.

In the first syntax, `net-ping` sends a ping ICMP 64-byte echo request
to the address specified in _str-address_. If it is a broadcast address,
the ICMP packet will be received by all addresses on the subnet. Note
that for security reasons, many computers do not answer ICMP broadcast
ping (ICMP_ECHO) requests. An optional timeout parameter can be
specified in _int-timeout_. If no timeout is specified, a waiting time
of 1000 milliseconds (one second) is assumed.

`net-ping` returns either a list of lists of IP strings and round-trip
time in microseconds for which a response was received or an empty list
if no response was received.

A return value of `nil` indicates a failure. Use the
link:#net-error[net-error] function to retrieve the error message. If
the message reads `Cannot open socket`, it is probably because newLISP
is running without root permissions. newLISP can be started using:

[source,sh]
------------
sudo newlisp
------------

Alternatively, newLISP can be installed with the set-user-ID bit set to
run in superuser mode.

[source,newlisp]
---------------------------------------------------------
(net-ping "newlisp.org")     → (("66.235.209.72" 634080))
(net-ping "127.0.0.1")       → (("127.0.0.1" 115))
(net-ping "yahoo.com" 3000)  → nil
---------------------------------------------------------

In the second syntax, `net-ping` is run in _batch mode_. Only one socket
is opened in this mode, but multiple ICMP packets are sent out—one each
to multiple addresses specified in a list or specified by range. Packets
are sent out as fast as possible. In this case, multiple answers can be
received. If the same address is specified multiple times, the receiving
IP address will be flooded with ICMP packets.

To limit the number of responses to be waited for in broadcast or batch
mode, an additional argument indicating the maximum number of responses
to receive can be specified in _int-count_. Usage of this parameter can
cause the function to return sooner than the specified timeout. When a
given number of responses has been received, `net-ping` will return
before the timeout has occurred. Not specifying _int-count_ or
specifying `0` assumes an _int-count_ equal to the number of packets
sent out.

As third optional parameter, a `true` value can be specified. This
setting will return an error string instead of the response time, if the
host does not answer.

[source,newlisp]
-------------------------------------------------------------------------------------
(net-ping '("newlisp.org" "192.168.1.255") 2000 20)
→ (("66.235.209.72" 826420) ("192.168.1.1" 124) ("192.168.1.254" 210))

(net-ping "192.168.1.*" 500) ; from 1 to 254
→ (("192.168.1.1" 120) ("192.168.1.2" 245) ("192.168.2.3" 180) ("192.168.2.254" 234))

(net-ping "192.168.1.*" 500 2) ; returns after 2 responses
→ (("192.168.1.3" 115) ("192.168.1.1" 145))

(net-ping "192.168.1.1-10" 1000) ; returns after 1 second
→ (("192.168.1.3" 196) ("192.168.1.1" 205))

(net-ping '("192.168.1.100-120" "192.168.1.124-132") 2000) ; returns after 2 seconds
→ ()
-------------------------------------------------------------------------------------

Broadcast or batch mode—as well as normal addresses and IP numbers or
hostnames— can be mixed in one `net-ping` statement by putting all of
the IP specs into a list.

The second and third lines show how the batch mode of `net-ping` can be
initiated by specifying the `*` (asterisk) as a wildcard character for
the last subnet octet in the IP number. The fourth and fifth lines show
how an IP range can be specified for the last subnet octet in the IP
number. `net-ping` will iterate through all numbers from either 1 to 254
for the star `*` or the range specified, sending an ICMP packet to each
address. Note that this is different from the _broadcast_ mode specified
with an IP octet of `255`. While in broadcast mode, `net-ping` sends out
only one packet, which is received by multiple addresses. Batch mode
explicitly generates multiple packets, one for each target address. When
specifying broadcast mode, _int-count_ should be specified, too.

When sending larger lists of IPs in batch mode over one socket, a longer
timeout may be necessary to allow enough time for all of the packets to
be sent out over one socket. If the timeout is too short, the function
`net-ping` may return an incomplete list or the empty list `()`. In this
case, link:#net-error[net-error] will return a timeout error. On error,
`nil` is returned and link:#net-error[net-error] can be used to retrieve
an error message.

On some systems only lists up to a specific length can be handled
regardless of the timeout specified. In this case, the range should be
broken up into sub-ranges and used with multiple `net-ping` invocations.
In any case, `net-ping` will send out packages as quickly as possible.

function::net-receive[!]

*syntax:* (net-receive _int-socket_ _sym-buffer_ _int-max-bytes_ [_wait-string_])

Receives data on the socket _int-socket_ into a string contained in
_sym-buffer_. _sym-buffer_ can also be a default functor specified by a
context symbol for reference passing in and out of user-defined
functions.

A maximum of _int-max-bytes_ is received. `net-receive` returns the
number of bytes read. If there is a break in the connection, `nil` is
returned. The space reserved in _sym-buffer_ is exactly the size of
bytes read.

Note that `net-receive` is a blocking call and does not return until the
data arrives at _int-socket_. Use link:#net-peek[net-peek] or
link:#net-select[net-select] to find out if a socket is ready for
reading.

Optionally, a _wait-string_ can be specified as a fourth parameter.
`net-receive` then returns after a character or string of characters
matching _wait-string_ is received. The _wait-string_ will be part of
the data contained in _sym-buffer_.

[source,newlisp]
---------------------------------
(define (gettime)
    (net-connect "netcom.com" 13)
    (net-receive socket buf 256)
    (print buf "\n")
    (net-close socket))
---------------------------------

When calling `gettime`, the program connects to port 13 of the server
netcom.com. Port 13 is a date-time service on most server installations.
Upon connection, the server sends a string containing the date and time
of day.

[source,newlisp]
--------------------------------------------------
(define (net-receive-line socket sBuff)
    (net-receive socket sBuff 256 "\n"))

(set 'bytesReceived (net-receive-line socket 'sm))
--------------------------------------------------

The second example defines a new function `net-receive-line`, which
returns after receiving a newline character (a string containing one
character in this example) or 256 characters. The "\n" string is part of
the contents of sBuff.

Note that when the fourth parameter is specified, `net-receive` is
slower than the normal version because information is read
character-by-character. In most situations, the speed difference can be
neglected.

function::net-receive-from[]

*syntax:* (net-receive-from _int-socket_ _int-max-size_)

`net-receive-from` can be used to set up non-blocking UDP
communications. The socket in _int-socket_ must previously have been
opened by either link:#net-listen[net-listen] or
link:#net-connect[net-connect] (both using the `"udp"` option).
_int-max-size_ specifies the maximum number of bytes that will be
received. On Linux/BSD, if more bytes are received, those will be
discarded; on Win32, `net-receive-from` returns `nil` and closes the
socket.

On success `net-receive` returns a list of the data string, remote IP
number and remote port used. On failure it returns `nil`.

[source,newlisp]
--------------------------------------------------------------
;; listen on port 1001 on the default address
(net-listen 1001 "" "udp")  → 1980

;; optionally poll for arriving data with 100ms timeout
(while (not (net-select 1980 "r" 100000)) (do-something ... ))

(net-receive-from 1980 20)  → ("hello" "192.168.0.5" 3240)

;; send answer back to sender
(net-send-to "192.168.0.5" 3240 "hello to you" 1980)

(net-close 1980) ; close socket
--------------------------------------------------------------

The second line in this example is optional. Without it, the
`net-receive-from` call would block until data arrives. A UDP server
could be set up by listening and polling several ports, serving them as
they receive data.

Note that `net-receive` could not be used in this case because it does
not return the sender's address and port information, which are required
to talk back. In UDP communications, the data packet itself contains the
address of the sender, _not_ the socket over which communication takes
place. `net-receive` can also be used for TCP/IP communications.

See also the link:#net-connect[net-connect] function with the `"udp"`
option and the link:#net-send-to[net-send-to] function for sending UDP
data packets over open connections.

For blocking short UDP transactions, see the
link:#net-send-udp[net-send-udp] and
link:#net-receive-udp[net-receive-udp] functions.

function::net-receive-udp[]

*syntax:* (net-receive-udp _int-port_ _int-maxsize_ [_int-microsec_ [_str-addr-if_]])

Receives a User Datagram Protocol (UDP) packet on port _int-port_,
reading _int-maxsize_ bytes. If more than _int-maxsize_ bytes are
received, bytes over _int-maxsize_ are discarded on Linux/BSD; on Win32,
`net-receive-udp` returns `nil`. `net-receive-udp` blocks until a
datagram arrives or the optional timeout value in _int-microsec_
expires. When setting up communications between datagram sender and
receiver, the `net-receive-udp` statement must be set up first.

No previous setup using `net-listen` or `net-connect` is necessary.

`net-receive-udp` returns a list containing a string of the UDP packet
followed by a string containing the sender's IP number and the port
used.

[source,newlisp]
------------------------------------------------------------
;; wait for datagram with maximum 20 bytes
(net-receive-udp 10001 20)

;; or
(net-receive-udp 10001 20 5000000)  ; wait for max 5 seconds

;; executed on remote computer
(net-send-udp "nuevatec.com" 1001 "Hello")  → 4

;; returned from the net-receive-udp statement
→ ("Hello" "128.121.96.1" 3312)

;; sending binary information
(net-send-udp "ahost.com" 2222 (pack "c c c c" 0 1 2 3))
→ 4

;; extracting the received info
(set 'buff (first (net-receive-udp 2222 10)))

(print (unpack "c c c c" buff))  → (0 1 2 3)
------------------------------------------------------------

See also the link:#net-send-udp[net-send-udp] function for sending
datagrams and the link:#pack[pack] and link:#unpack[unpack] functions
for packing and unpacking binary information.

To listen on a specified address on computers with more than one
interface card, an interface IP address or name can be optionally
specified in _str-addr-if_. When specifying _str-addr-if_, a timeout
must also be specified in _int-wait_.

As an alternative, UDP communication can be set up using
link:#net-listen[net-listen], or link:#net-connect[net-connect] together
with the `"udp"` option to make non-blocking data exchange possible with
link:#net-receive-from[net-receive-from] and
link:#net-send-to[net-send-to].

function::net-select[]

*syntax:* (net-select _int-socket_ _str-mode_ _int-micro-seconds_) +
*syntax:* (net-select _list-sockets_ _str-mode_ _int-micro-seconds_)

In the first form, `net-select` finds out about the status of one socket
specified in _int-socket_. Depending on _str-mode_, the socket can be
checked if it is ready for reading or writing, or if the socket has an
error condition. A timeout value is specified in _int-micro-seconds_.

In the second syntax, `net-select` can check for a list of sockets in
_list-sockets_.

The following value can be given for _str-mode_:

`"read"` or `"r"` to check if ready for reading or accepting. +
`"write"` or `"w"` to check if ready for writing. +
`"exception"` or `"e"` to check for an error condition. +

Read, send, or accept operations can be handled without blocking by
using the `net-select` function. `net-select` waits for a socket to be
ready for the value given in _int-micro-seconds_, then returns `true` or
`nil` depending on the readiness of the socket. During the select loop,
other portions of the program can run. On error,
link:#net-error[net-error] is set. When `-1` is specified for
_int-micro-seconds_, `net-select` will never time out.

[source,newlisp]
---------------------------------------------------
(set 'listen-socket (net-listen 1001))

;; wait for connection
(while (not (net-select listen-socket "read" 1000))
    (if (net-error) (print (net-error))))

(set 'connection (net-accept listen-socket))
(net-send connection "hello")

;; wait for incoming message
(while (not (net-select connection "read" 1000))
    (do-something))

(net-receive connection buff 1024)
---------------------------------------------------

When `net-select` is used, several listen and connection sockets can be
watched, and multiple connections can be handled. When used with a list
of sockets, `net-select` will return a list of ready sockets. The
following example would listen on two sockets and continue accepting and
servicing connections:

[source,newlisp]
-----------------------------------------------------------
(set 'listen-list '(1001 1002))

; accept-connection, read-connection and write-connection
; are userdefined functions

(while (not (net-error))
    (dolist (conn (net-select listen-list "r" 1000))
    (accept-connection conn))  ; build an accept-list

    (dolist (conn (net-select accept-list "r" 1000))
    (read-connection conn))    ; read on connected sockets

    (dolist (conn (net-select accept-list "w" 1000))
    (write-connection conn)))  ; write on connected sockets
-----------------------------------------------------------

In the second syntax, a list is returned containing all the sockets that
passed the test; if timeout occurred, an empty list is returned. An
error causes link:#net-error[net-error] to be set.

Note that supplying a nonexistent socket to `net-select` will cause an
error to be set in link:#net-error[net-error].

function::net-send[]

*syntax:* (net-send _int-socket_ _str-buffer_ [_int-num-bytes_])

Sends the contents of _str-buffer_ on the connection specified by
_int-socket_. If _int-num-bytes_ is specified, up to _int-num-bytes_ are
sent. If _int-num-bytes_ is not specified, the entire contents will be
sent. `net-send` returns the number of bytes sent or `nil` on failure.

On failure, use link:#net-error[net-error] to get more error
information.

[source,newlisp]
------------------------------
(set 'buf "hello there")

(net-send sock buf)       → 11
(net-send sock buf 5)     → 5

(net-send sock "bye bye") → 7
------------------------------

The first `net-send` sends the string `"hello there"`, while the second
`net-send` sends only the string `"hello"`.

function::net-send-to[]

*syntax:* (net-send-to _str-remotehost_ _int-remoteport_ _str-buffer_ _int-socket_)

Can be used for either UDP or TCP/IP communications. The socket in
_int-socket_ must have previously been opened with a
link:#net-connect[net-connect] or link:#net-listen[net-listen] function.
If the opening functions was used with the `"udp"` option, `net-listen`
or `net-connect` are not used to listen or to connect but only to create
the UDP socket. The host in _str-remotehost_ can be specified either as
a hostname or as an IP-number string.

When using `net-connect` together with `net-send-to`, then only one of
the functions should specify the remote host. The other should leave the
address as an empty string.

[source,newlisp]
------------------------------------------------------
;;;;;;;;;;;;;;;;;; UDP server
(set 'socket (net-listen 10001 "" "udp"))
(if socket (println "server listening on port " 10001)
       (println (net-error)))
(while (not (net-error))
   (set 'msg (net-receive-from socket 255))
   (println "-> " msg)
   (net-send-to (nth 1 msg) (nth 2 msg)
                (upper-case (first msg)) socket))

;;;;;;;;;;;;;;;;;; UDP client
(set 'socket (net-listen 10002 "" "udp"))
(if (not socket) (println (net-error)))
(while (not (net-error))
   (print "> ")
   (net-send-to "127.0.0.1" 10001 (read-line) socket)
   (net-receive socket buff 255)
   (println "-> " buff))
------------------------------------------------------

In the examples both, the client and the server use `net-listen` to
create the UDP socket for sending and receiving. The server extracts the
client address and port from the message received and uses it in the
`net-send-to` statement.

See also the link:#net-receive-from[net-receive-from] function and the
link:#net-listen[net-listen] function with the `"udp"` option.

For blocking short UDP transactions use link:#net-send-udp[net-send-udp]
and link:#net-receive-udp[net-receive-udp].

function::net-send-udp[]

*syntax:* (net-send-udp _str-remotehost_ _int-remoteport_ _str-buffer_ [_bool_])

Sends a User Datagram Protocol (UDP) to the host specified in
_str-remotehost_ and to the port in _int-remoteport_. The data sent is
in _str-buffer_.

The theoretical maximum data size of a UDP packet on an IPv4 system is
64K minus IP layer overhead, but much smaller on most Unix flavors. 8k
seems to be a safe size on Mac OS X, BSDs and Linux.

No previous setup using `net-connect` or `net-listen` is necessary.
`net-send-udp` returns immediately with the number of bytes sent and
closes the socket used. If no `net-receive-udp` statement is waiting at
the receiving side, the datagram sent is lost. When using datagram
communications over insecure connections, setting up a simple protocol
between sender and receiver is recommended for ensuring delivery. UDP
communication by itself does not guarantee reliable delivery as TCP/IP
does.

[source,newlisp]
-----------------------------------------------
(net-send-udp "somehost.com" 3333 "Hello")  → 5
-----------------------------------------------

`net-send-udp` is also suitable for sending binary information (e.g.,
the zero character or other non-visible bytes). For a more comprehensive
example, see link:#net-receive-udp[net-receive-udp].

Optionally, the sending socket can be put in broadcast mode by
specifying `true` or any expression not evaluating to `nil` in _bool_:

[source,newlisp]
-----------------------------------------------------
(net-send-udp "192.168.1.255" 2000 "Hello" true)  → 5
-----------------------------------------------------

The UDP will be sent to all nodes on the `192.168.1` network. Note that
on some operating systems, sending the network mask `255` without the
_bool_ `true` option will enable broadcast mode.

As an alternative, the link:#net-connect[net-connect] function using the
`"udp"` option—together with the link:#net-send-to[net-send-to]
function—can be used to talk to a UDP listener in a non-blocking
fashion.

function::net-service[]

*syntax:* (net-service _str-service_ _str-protocol_) +
*syntax:* (net-service _int-port_ _str-protocol_)

In the first syntax `net-service` makes a lookup in the _services_
database and returns the standard port number for this service.

In the second syntax a service port is supplied in _int-port_ to look up
the service name.

Returns `nil` on failure.

[source,newlisp]
-------------------------------------------------------
; get the port number from the name
(net-service "ftp" "tcp")       → 21
(net-service "http" "tcp")      → 80
(net-service "net-eval" "tcp")  → 4711  ; if configured

; get the service name from the port number
(net-service 22 "tcp")          → "ssh"
-------------------------------------------------------

function::net-sessions[]

*syntax:* (net-sessions)

Returns a list of active listening and connection sockets.

function::new[]

*syntax:* (new _context-source_ _sym-context-target_ [_bool_]) +
*syntax:* (new _context-source_)

The context _context-source_ is copied to _sym-context-target_. If the
target context does not exist, a new context with the same variable
names and user-defined functions as in _context-source_ is created. If
the target context already exists, then new symbols and definitions are
added. Existing symbols are only overwritten when the expression in
_bool_ evaluates to anything other than `nil`; otherwise, the content of
existing symbols will remain. This makes _mixins_ of context objects
possible. `new` returns the target context, which cannot be MAIN.

In the second syntax, the existing context in _context-source_ gets
copied into the current context as the target context.

All references to symbols in the originating context will be translated
to references in the target context. This way, all functions and data
structures referring to symbols in the original context will now refer
to symbols in the target context.

[source,newlisp]
--------------------------------------
(new CTX 'CTX-2)  → CTX-2

;; force overwrite of existing symbols
(new CTX MyCTX true)  → MyCTX
--------------------------------------

The first line in the example creates a new context called `CTX-2` that
has the exact same structure as the original one. Note that `CTX` is not
quoted because contexts evaluate to themselves, but CTX-2 must be quoted
because it does not exist yet.

The second line merges the context `CTX` into `MyCTX`. Any existing
symbols of the same name in `MyCTX` will be overwritten. Because `MyCTX`
already exists, the quote before the context symbol can be omitted.

Context symbols need not be mentioned explicitly, but they can be
contained in variables:

[source,newlisp]
---------------------------------------
(set 'foo:x 123)
(set 'bar:y 999)

(set 'ctxa foo)
(set 'ctxb bar)

(new ctxa ctxb)  ; from foo to bar

bar:x  → 123  ; x has been added to bar
bar:y  → 999)
---------------------------------------

The example refers to contexts in variables and merges context `foo`
into `bar`.

See also the function link:#def-new[def-new] for moving and merging
single functions instead of entire contexts. See the
link:#context[context] function for a more comprehensive example of
`new`.

function::nil?[]

*syntax:* (nil? _exp_)

If the expression in _exp_ evaluates to `nil`, then `nil?` returns
`true`; otherwise, it returns `nil`.

[source,newlisp]
----------------------------------
(map nil? '(x nil  1 nil "hi" ()))
→ (nil true nil true nil nil)

(nil? nil)  → true
(nil? '())  → nil

; nil? means strictly nil
(nil? (not '()))  → nil
----------------------------------

The `nil?` predicate is useful for distinguishing between `nil` and the
empty list `()`.

Note that `nil?` means _strictly_ `nil` while `true?` means everything
not `nil` or the empty list `()`.

function::normal[]

*syntax:* (normal _float-mean_ _float-stdev_ _int-n_) +
*syntax:* (normal _float-mean_ _float-stdev_)

In the first form, `normal` returns a list of length _int-n_ of random,
continuously distributed floating point numbers with a mean of
_float-mean_ and a standard deviation of _float-stdev_. The random
generator used internally can be seeded using the link:#seed[seed]
function.

[source,newlisp]
-------------------------------------------------------
(normal 10 3 10)
→ (7 6.563476562 11.93945312 6.153320312 9.98828125
7.984375 10.17871094 6.58984375 9.42578125 12.11230469)
-------------------------------------------------------

In the second form, `normal` returns a single normal distributed
floating point number:

[source,newlisp]
----------------------------
(normal 0 1)  → 0.6630859375
----------------------------

See also the link:#random[random] and link:#rand[rand] functions for
evenly distributed numbers, link:#amb[amb] for randomizing evaluation in
a list of expressions, and link:#seed[seed] for setting a different
start point for pseudo random number generation.

function::not[]

*syntax:* (not _exp_)

If _exp_ evaluates to `nil` or the empty list `()`, then `true` is
returned; otherwise, `nil` is returned.

[source,newlisp]
----------------------------
(not true)            → nil
(not nil)             → true
(not '())             → true
(not (< 1 10))        → nil
(not (not (< 1 10)))  → true
----------------------------

function::now[]

*syntax:* (now [_int-minutes-offset_ [_int-index_]])

Returns information about the current date and time as a list of
integers. An optional time-zone offset can be specified in minutes in
_int-minutes-offset_. This causes the time to be shifted forward or
backward in time, before being split into separate date values.

An optional list-index in _int-index_ makes `now` return a specific
member in the result list.

[source,newlisp]
-----------------------------------------------------
(now)       → (2002 2 27 18 21 30 140000 57 3 -300 0)
(now 0 -2)  → -300 ; minutes west of GMT

(apply date-value (now))  → 1014834090
-----------------------------------------------------

The numbers represent the following date-time fields:

[cols="1<,3<",width="50%",options="header",]
|=======================================================================
|format |description
|year |Gregorian calendar

|month |(1–12)

|day |(1–31)

|hour |(0–23) UTC

|minute |(0–59)

|second |(0–59)

|microsecond |(0–999999) OS-specific, millisecond resolution

|day of current year |Jan 1st is 1

|day of current week |(1–7) starting Monday

|time zone offset in minutes |west of GMT

|daylight savings time type |(0–6) on Linux/Unix or bias in minutes on
Win32
|=======================================================================

The second example returns the Coordinated Universal Time (UTC) time
value of seconds after January 1, 1970.

Ranging from 0 to 23, hours are given in UTC and are not adjusted for
the local time zone. The resolution of the `microseconds` field depends
on the operating system and platform. On some platforms, the last three
digits of the `microseconds` field are always `0` (zero).

The "day of the week" field starts with 1 on Monday comforming to the
ISO 8601 international standard for date and time representation.

On some platforms, the daylight savings time flag is not active and
returns `0` (zero) even during daylight savings time (dst).

Depending on the geographical area, the daylight savings time type (dst)
has a different value from 1 to 6:

[cols="1<,5<",width="15%",options="header",]
|=======================
|type |area
|0 |not on dst
|1 |USA style dst
|2 |Australian style dst
|3 |Western European dst
|4 |Middle European dst
|5 |Eastern European dst
|6 |Canada dst
|=======================

See also the link:#date[date], link:#date-list[date-list],
link:#date-parse[date-parse], link:#date-value[date-value],
link:#time[time], and link:#time-of-day[time-of-day] functions.

function::nper[]

*syntax:* (nper _num-interest_ _num-pmt_ _num-pv_ [_num-fv_ [_int-type_]])

Calculates the number of payments required to pay a loan of _num-pv_
with a constant interest rate of _num-interest_ and payment _num-pmt_.
If payment is at the end of the period, _int-type_ is `0` (zero) or
_int-type_ is omitted; for payment at the beginning of each period,
_int-type_ is 1.

[source,newlisp]
--------------------------------------------------
(nper (div 0.07 12) 775.30 -100000)  → 239.9992828
--------------------------------------------------

The example calculates the number of monthly payments required to pay a
loan of $100,000 at a yearly interest rate of 7 percent with payments of
$775.30.

See also the link:#fv[fv], link:#irr[irr], link:#npv[npv],
link:#pmt[pmt], and link:#pv[pv] functions.

function::npv[]

*syntax:* (npv _num-interest_ _list-values_)

Calculates the net present value of an investment with a fixed interest
rate _num-interest_ and a series of future payments and income in
_list-values_. Payments are represented by negative values in
_list-values_, while income is represented by positive values in
_list-values_.

[source,newlisp]
----------------------------------------
(npv 0.1 '(1000 1000 1000))
→ 2486.851991

(npv 0.1 '(-2486.851991 1000 1000 1000))
→ -1.434386832e-08  ; ~ 0.0 (zero)
----------------------------------------

In the example, an initial investment of $2,481.85 would allow for an
income of $1,000 after the end of the first, second, and third years.

See also the link:#fv[fv], link:#irr[irr], link:#nper[nper],
link:#pmt[pmt], and link:#pv[pv] functions.

function::nth[utf8]

*syntax:* (nth _int-index_ _list_) +
*syntax:* (nth _int-index_ _array_) +
*syntax:* (nth _int-index_ _str_) +
*syntax:* (nth _list-indices_ _list_) +
*syntax:* (nth _list-indices_ _array_)

In the first syntax group `nth` uses _int-index_ an index into the
_list_, _array_ or _str_ found and returning the element found at that
index. See also link:#indexing[Indexing elements of strings and lists].

Multiple indices may be specified to recursively access elements in
nested lists or arrays. If there are more indices than nesting levels,
the extra indices are ignored. When multiple indices are used, they must
be put in a list as shown in the second syntax group.

[source,newlisp]
--------------------------------------------------------
(set 'L '(a b c))
(nth 0 L)    → a
; or simply
(L 0) → a

(set 'names '(john martha robert alex))
→ (john martha robert alex)

(nth 2 names)    → robert
; or simply
(names 2)        → robert

(names -1)       → alex

; multiple indices
(set 'persons '((john 30) (martha 120) ((john doe) 17)))

(persons 1 1)           → 120

(nth '(2 0 1) persons)  → doe

; or simply
(persons 2 0 1)        → doe

; multiple indices in a vector
(set 'v '(2 0 1))
(persons v)       → doe
(nth v persons)   → doe

; negative indices
(persons -2 0)    → martha

; out-of-bounds indices cause error
(persons 10)  → ERR: list index out of bounds
(person -5)   → ERR: list index out of bounds
--------------------------------------------------------

The list `L` can be the context of the default functor `L:L`. This
allows lists passed by reference:

[source,newlisp]
---------------------------------------
(set 'L:L '(a b c d e f g))

(define (second ctx)
    (nth 1 ctx))

(reverse L) → (g f e d c b a)
L:L → (g f e d c b a)

;; passing the list in L:L by reference
(second L)   → b

;; passing the list in L:L by value
(second L:L) → b
---------------------------------------

Reference passing is faster and uses less memory in big lists and should
be used on lists with more than a few hundred items.

Note that the _implicit indexing_ version of `nth` is not breaking
newLISP syntax rules but should be understood as a logical expansion of
newLISP syntax rules to other data types than built-in functions or
lambda expressions. A list in the functor position of an s-expression
assumes self-indexing functionality using the index arguments following.

The implicit indexed syntax forms are faster but the other form with an
explicit `nth` may be more readable in some situations.

`nth` works on link:#array[arrays] just like it does on lists:

[source,newlisp]
----------------------------------------
(set 'aArray (array 2 3 '(a b c d e f)))
→ ((a b c) (d e f))
(nth 1 aArray)      →  (d e f)
(aArray 1)          →  (d e f)

(nth '(1 0) aArray)    → d
(aArray 1 0)           → d
(aArray '(1 0))        → d

(set 'vec '(1 0))
(aArray vec)           → d
----------------------------------------

In the String version, `nth` returns the character found at the position
_int-index_ in _str_ and returns it as a string.

[source,newlisp]
--------------------------
(nth  0 "newLISP")   → "n"

("newLISP" 0)        → "n"

("newLISP" -1)       → "P"
--------------------------

Note that link:#nth[nth] works on character boundaries rather than byte
boundaries when using the UTF-8–enabled version of newLISP. To access
ASCII and binary string buffers on single byte boundaries use
link:#slice[slice].

See also link:#setf[setf] for modifying multidimensional lists and
arrays and link:#push[push] and link:#pop[pop] for modifying lists.

function::null?[]

*syntax:* (null? _exp_)

Checks if an expression evaluates to `nil`, the empty list `()`, the
empty string `""`, `NaN` (not a number), or `0` (zero), in which case it
returns `true`. In all other cases, `null?` returns `nil`. The predicate
`null?` is useful in conjunction with the functions link:#filter[filter]
or link:#clean[clean] to check the outcome of other newLISP operations.

[source,newlisp]
----------------------------------------------------------
(set 'x (sqrt -1)) → NaN ; or nan on UNIX
(null? x) → true

(map null? '(1 0 0.0 2 "hello" "" (a b c) () true))
→ (nil true true nil nil true nil true nil)

(filter null? '(1 0 2 0.0 "hello" "" (a b c) () nil true))
→ (0 0 "" () nil)

(clean null? '(1 0 2 0.0 "hello" "" (a b c) () nil true))
→ (1 2 "hello" (a b c) true)
----------------------------------------------------------

See also the predicates link:#emptyp[empty?], link:#nilp[nil?] and
link:#zerop[zero?].

function::number?[]

*syntax:* (number? _exp_)

`true` is returned only if _exp_ evaluates to a floating point number or
an integer; otherwise, `nil` is returned.

[source,newlisp]
-----------------------
(set 'x 1.23)
(set 'y 456)
(number? x)      → true
(number? y)      → true
(number? "678")  → nil
-----------------------

See the functions link:#floatp[float?] and link:#integerp[integer?] to
test for a specific number type.

function::odd?[]

*syntax:* (odd? _int-number_)

Checks the parity of an integer number. If the number is not _even
divisable_ by `2`, it has _odd_ parity. When a floating point number is
passed for _int-number_, it will be converted first to an integer by
cutting off its fractional part.

[source,newlisp]
------------------
(odd? 123)  → true
(odd? 8)    → nil
(odd? 8.7)  → nil
------------------

Use link:#evenp[even?] to check if an integer is even, divisable by `2`.

function::open[]

*syntax:* (open _str-path-file_ _str-access-mode_ [_str-option_])

The _str-path-file_ is a file name, and _str-access-mode_ is a string
specifying the file access mode. `open` returns an integer, which is a
file handle to be used on subsequent read or write operations on the
file. On failure, `open` returns `nil`. The access mode `"write"`
creates the file if it doesn't exist, or it truncates an existing file
to `0` (zero) bytes in length.

The following strings are legal access modes:

`"read"` or `"r"` for read only access +
`"write"` or `"w"` for write only access +
`"update"` or `"u"` for read/write access +
`"append"` or `"a"` for append read/write access +

[source,newlisp]
-------------------------------------------
(device (open "newfile.data" "write"))  → 5
(print "hello world\n")  → "hello world"
(close (device))         → 5

(set 'aFile (open "newfile.data" "read"))
(seek aFile 6)
(set 'inChar (read-char aFile))
(print inChar "\n")
(close aFile)
-------------------------------------------

The first example uses `open` to set the device for link:#print[print]
and writes the word `"hello world"` into the file `newfile.data`. The
second example reads a byte value at offset 6 in the same file (the
ASCII value of `'w'` is 119). Note that using `close` on
link:#device[(device)] automatically resets link:#device[device] to `0`
(zero).

As an additional _str-option_, `"non-block"` or `"n"` can be specified
after the `"read"` or `"write"` option. Only available on Unix systems,
non-blocking mode can be useful when opening _named pipes_ but is not
required to perform I/O on named pipes.

To create a named pipe in newLISP, use the link:#exec[exec] or
link:#import[import] function:

[source,newlisp]
----------------------------------
(exec "mkfifo myfifo")

;; or alternatively

(import "/lib/libc.so.6" "mkfifo")
(mkfifo "/tmp/myfifo" 0777)
----------------------------------

The named pipe can now be used like a file with link:#open[open],
link:#read[read], and link:#write[write].

function::or[]

*syntax:* (or _exp-1_ [_exp-2_ ... ])

Evaluates expressions _exp-x_ from left to right until finding a result
that does not evaluate to `nil` or the empty list `()`. The result is
the return value of the `or` expression.

[source,newlisp]
------------------------------------------
(set 'x 10)
(or (> x 100) (= x 10))          → true
(or "hello" (> x 100) (= x 10))  → "hello"
(or '())                         → ()
(or true)                        → true
(or)                             → nil
------------------------------------------

function::ostype[]

*syntax:* ostype

`ostype` is a built-in system constant containing the name of the
operating system newLISP is running on.

[source,newlisp]
-----------------
ostype  → "Win32"
-----------------

One of the following strings is returned:
`"Linux", "BSD", "OSX", "Tru64Unix", "Solaris", "SunOS", "Win32", or "OS/2"`.

`ostype` can be used to write platform-independent code:

[source,newlisp]
---------------------------------------------------
(if
    (= ostype "Linux") (import "libz.so")
    (= ostype "BSD") (import "libz.so")
    (= ostype "OSX") (import "libz.dylib")
    ...
    (println "cannot import libz on this platform")
)
---------------------------------------------------

Use link:#sys-info[sys-info] to learn more about the current flavor of
newLISP running.

For a table of other built-in system variables and symbols see the
chapter link:#system_symbols[System Symbols and Constants] in the
appendix.

function::pack[]

*syntax:* (pack _str-format_ _exp-1_ [_exp-2_ ... ]) +
*syntax:* (pack _str-format_ _list_) +
*syntax:* (pack _struct_ _exp-1_ [_exp-2_ ... ]) +
*syntax:* (pack _struct_ _list_)

When the first parameter is a string, `pack` packs one or more
expressions (_exp-1_ to _exp-n_) into a binary format specified in the
format string _str-format_, and returning the binary structure in a
string buffer. The symmetrical link:#unpack[unpack] function is used for
unpacking. The expression arguments can also be given in a _list_.
`pack` and `unpack` are useful when reading and writing binary files
(see link:#read[read] and link:#write[write]) or when unpacking binary
structures from return values of imported C functions using `import`.

When the first parameter is the symbol of a link:#struct[struct]
definition, `pack` uses the format as specified in _struct_. While
`pack` with _str-format_ literally packs as specified, `pack` with
_struct_ will insert structure aligning pad-bytes depending on data
type, order of elements and CPU architecture. Refer to the description
of the link:#struct[struct] function for more detail.

The following characters are used in _str-format_:

[cols="1<,5<",width="40%",options="header",]
|==================================================
|format |description
|`c ` |a signed 8-bit number
|`b ` |an unsigned 8-bit number
|`d ` |a signed 16-bit short number
|`u ` |an unsigned 16-bit short number
|`ld` |a signed 32-bit long number
|`lu` |an unsigned 32-bit long number
|`Ld` |a signed 64-bit long number
|`Lu` |an unsigned 64-bit long number
|`f ` |a float in 32-bit representation
|`lf` |a double float in 64-bit representation
|`sn` |a string of _n_ null padded ASCII characters
|`nn` |_n_ null characters
|`>` |switch to big endian byte order
|`<` |switch to little endian byte order
|==================================================

`pack` will convert all floats into integers when passed to `b`, `c`,
`d`, `ld`, or `lu` formats. It will also convert integers into floats
when passing them to `f` and `lf` formats.

[source,newlisp]
---------------------------------------------------------
(pack "c c c" 65 66 67)  → "ABC"
(unpack "c c c" "ABC")   → (65 66 67)

(pack "c c c" 0 1 2)             → "\000\001\002"
(unpack "c c c" "\000\001\002")  → (0 1 2)

(set 's (pack "c d u" 10 12345 56789))
(unpack "c d u" s)  → (10 12345 56789)

(set 's (pack "s10 f" "result" 1.23))
(unpack "s10 f" s)
→ ("result\000\000\000\000" 1.230000019)

(pack "n10") → "\000\000\000\000\000\000\000\000\000\000"

(set 's (pack "s3 lf" "result" 1.23))
(unpack "s3 f" s)  → ("res" 1.23)

(set 's (pack "c n7 c" 11 22))
(unpack "c n7 c" s)  → (11 22))

(unpack "b" (pack "b" -1.0))  → (255)
(unpack "f" (pack "f" 123))   → (123)
---------------------------------------------------------

The last two statements show how floating point numbers are converted
into integers when required by the format specification.

The expressions to pack can also be given in a list:

[source,newlisp]
---------------------------------------------------------
(set 'lst '("A" "B" "C"))
(set 'adr (pack "lululu" lst))
(map get-string (unpack "lululu" adr))    → ("A" "B" "C")
---------------------------------------------------------

Note that the list should be referenced directly in `pack`, so the
pointers passed by `adr` are valid. `adr` would be written as
`char * adr[]` in the C-programming language and represents a 32-bit
pointer to an array of 32-bit string pointers.

The `>` and `<` specifiers can be used to switch between _little endian_
and _big endian_ byte order when packing or unpacking:

[source,newlisp]
------------------------------------------------------------
(pack "d" 1)   → "\001\000"  ;; on little endian CPU
(pack ">d" 1)  → "\000\001"  ;; force big endian

(pack "ld" 1)   → "\001\000\000\000" ;; on little endian CPU
(pack "<ld" 1)  → "\000\000\000\001" ;; force big endian

(pack ">u <u" 1 1) → "\000\001\001\000" ;; switch twice
------------------------------------------------------------

Switching the byte order will affect all number formats with 16-, 32-,
or 64-bit sizes.

The pack and unpack format need not be the same:

[source,newlisp]
--------------------------------
(set 's (pack "s3" "ABC"))
(unpack "c c c" s)  → (65 66 67)
--------------------------------

The examples show spaces between the format specifiers. These are not
required but can be used to improve readability.

See also the link:#address[address], link:#get-int[get-int],
link:#get-long[get-long], link:#get-char[get-char],
link:#get-string[get-string], and link:#unpack[unpack] functions.

function::parse[]

*syntax:* (parse _str-data_ [_str-break_ [_int-option_]])

Breaks the string that results from evaluating _str-data_ into string
tokens, which are then returned in a list. When no _str-break_ is given,
`parse` tokenizes according to newLISP's internal parsing rules. A
string may be specified in _str-break_ for tokenizing only at the
occurrence of a string. If an _int-option_ number is specified, a
regular expression pattern may be used in _str-break_.

When _str-break_ is not specified, the maximum token size is 2048 for
quoted strings and 256 for identifiers. In this case, newLISP uses the
same faster tokenizer it uses for parsing newLISP source. If _str-break_
is specified, there is no limitation on the length of tokens. A
different algorithm is used that splits the source string _str-data_ at
the string in _str-break_.

[source,newlisp]
-------------------------------------------------------------
(parse "hello how are you")     → ("hello" "how" "are" "you")

(parse "one:two:three" ":")     → ("one" "two" "three")

(parse "one--two--three" "--")  → ("one" "two" "three")

(parse "one-two--three---four" "-+" 0)
→ ("one" "two" "three" "four")

(parse "hello regular   expression 1, 2, 3" {,\s*|\s+} 0)
→ ("hello" "regular" "expression" "1" "2" "3")
-------------------------------------------------------------

The last two examples show a regular expression as the break string with
the default option `0` (zero). Instead of `{` and `}` (left and right
curly brackets), double quotes can be used to limit the pattern. In this
case, double backslashes must be used inside the pattern. The last
pattern could be used for parsing CSV (Comma Separated Values) files.
For the regular expression option numbers, see link:#regex[regex].

`parse` will return empty fields around separators as empty strings:

[source,newlisp]
---------------------------------------
(parse "1,2,3," ",") → ("1" "2" "3" "")
(parse "1,,,4" ",")  → ("1" "" "" "4")
(parse "," ",")      → ("" "")

(parse "")      → ()
(parse "" " ")  → ()
---------------------------------------

This behavior is needed when parsing records with empty fields.

Parsing an empty string will always result in an empty list.

Use the link:#regex[regex] function to break strings up and the
link:#directory[directory], link:#find[find], link:#find-all[find-all],
link:#regex[regex], link:#replace[replace], and link:#search[search]
functions for using regular expressions.

function::peek[]

*syntax:* (peek _int-handle_)

Returns the number of bytes ready to be read on a file descriptor;
otherwise, it returns `nil` if the file descriptor is invalid. `peek`
can also be used to check `stdin`. This function is only available on
Unix-like operating systems.

[source,newlisp]
-------------------------------------------
(peek 0)  ; check # of bytes ready on stdin
-------------------------------------------

Use the link:#net-peek[net-peek] function to check for network sockets,
or for the number of available bytes on them. On Unix systems,
link:#net-peek[net-peek] can be used to check file descriptors. The
difference is that link:#net-peek[net-peek] also sets
link:#net-error[net-error].

function::pipe[]

*syntax:* (pipe)

Creates an inter-process communications pipe and returns the `read` and
`write` handles to it within a list.

[source,newlisp]
--------------------------------------------
(pipe)  → (3 4)  ; 3 for read, 4 for writing
--------------------------------------------

The pipe handles can be passed to a child process launched via
link:#process[process] or to link:#fork[fork] for inter-process
communications.

Note that the pipe does not block when being written to, but it does
block reading until bytes are available. A link:#read-line[read-line]
blocks until a newline character is received. A link:#read[read] blocks
when fewer characters than specified are available from a pipe that has
not had the writing end closed by all processes.

More than one pipe can be opened if required.

newLISP can also use _named pipes_. See the link:#open[open] function
for further information.

function::pmt[]

*syntax:* (pmt _num-interest_ _num-periods_ _num-principal_ [_num-future-value_ [_int-type_]])

Calculates the payment for a loan based on a constant interest of
_num-interest_ and constant payments over _num-periods_ of time.
_num-future-value_ is the value of the loan at the end (typically
`0.0`). If payment is at the end of the period, _int-type_ is `0` (zero)
or _int-type_ is omitted; for payment at the beginning of each period,
_int-type_ is 1.

[source,newlisp]
----------------------------------------------
(pmt (div 0.07 12) 240 100000)  → -775.2989356
----------------------------------------------

The above example calculates a payment of $775.30 for a loan of $100,000
at a yearly interest rate of 7 percent. It is calculated monthly and
paid over 20 years (20 * 12 = 240 monthly periods). This illustrates the
typical way payment is calculated for mortgages.

See also the link:#fv[fv], link:#irr[irr], link:#nper[nper],
link:#npv[npv], and link:#pv[pv] functions.

function::pop[!,utf8]

*syntax:* (pop _list_ [_int-index-1_ [_int-index-2_ ... ]]) +
*syntax:* (pop _list_ [_list-indexes_]) +
*syntax:* (pop _str_ [_int-index_ [_int-length_]])

Using `pop`, elements can be removed from lists and characters from
strings.

In the first syntax, `pop` extracts an element from the list found by
evaluating _list_. If a second parameter is present, the element at
_int-index_ is extracted and returned. See also link:#indexing[Indexing
elements of strings and lists].

In the second version, indices are specified in the list _list-indexes_.
This way, `pop` works easily together with link:#ref[ref] and
link:#ref-all[ref-all], which return lists of indices.

`pop` changes the contents of the target list. The popped element is
returned.

[source,newlisp]
------------------------------------------
(set 'pList '((f g) a b c "hello" d e 10))

(pop pList)  → (f g)
(pop pList)  → a
pList        → (b c "hello" d e 10)

(pop pList 3)    → d
(pop pList 100)  → 10
pList            → (b c "hello" e)

(pop pList -1)  → e
pList           → (b c "hello")

(pop pList -2)  → c
pList           → (b "hello")

(set 'pList '(a 2 (x y (p q) z)))

(pop pList -1 2 0)  → p

;; use indices in a list
(set 'pList '(a b (c d () e)))

(push 'x pList '(2 2 0))
→ (a b (c d (x) e))

pList
→ (a b (c d (x) e))

(ref 'x pList)  → (2 2 0)

(pop pList '(2 2 0))  → x
------------------------------------------

`pop` can also be used on strings with one index:

[source,newlisp]
------------------------
;; use pop on strings

(set 'str "newLISP")

(pop str -4 4)  → "LISP"

str  → "new"

(pop str 1)  → "e"

str  → "nw"

(set 'str "x")

(pop str)  → "x"
(pop str)  → ""
------------------------

Popping an empty string will return an empty string.

See also the link:#push[push] function, the inverse operation to `pop`.

function::pop-assoc[!]

*syntax:* (pop-assoc _exp-key_ _list-assoc_) +
*syntax:* (pop-assoc _list-keys_ _list-assoc_)

Removes an association referred to by the key in _exp-key_ from the
association list in _list-assoc_ and returns the popped expression.

[source,newlisp]
--------------------------------------
;; simple associations

(set 'L '((a 1) (b 2) (c 3)))
(pop-assoc 'b L) → (b 2)
L → ((a 1) (c 3))

;; nested associations

(set 'L '((a (b 1) (c (d 2)))))
(pop-assoc 'a L) → (a (b 1) (c (d 2)))
L → ()

(set 'L '((a (b 1) (c (d 2)))))
(pop-assoc '(a b) L)  → (b 1)
L →  ((a (c (d 2))))

(set 'L '((a (b 1) (c (d 2)))))
(pop-assoc '(a c) L)  → (c (d 2))
L → ((a (b 1))))
--------------------------------------

See also link:#assoc[assoc] for retrieving associations and
link:#setf[setf] for modifying association lists.

function::post-url[]

*syntax:* (post-url _str-url_ _str-content_ [_str-content-type_ [_str-option_] [_int-timeout_ [ _str-header_]]])

Sends an HTTP POST request to the URL in _str-url_. POST requests are
used to post information collected from web entry forms to a web site.
Most of the time, the function `post-url` mimics what a web browser
would do when sending information collected in an HTML form to a server,
but it can also be used to upload files (see an HTTP reference). The
function returns the page returned from the server in a string.

When `post-url` encounters an error, it returns a string description of
the error beginning with `ERR:`.

The last parameter, _int-timeout_, is for an optional timeout value,
which is specified in milliseconds. When no response from the host is
received before the timeout has expired, the string `ERR: timeout` is
returned.

[source,newlisp]
---------------------------------------------------
;; specify content type
(post-url "http://somesite.com/form.pl"
          "name=johnDoe&city=New%20York"
          "application/x-www-form-urlencoded")

;; specify content type and timeout
(post-url "http://somesite.com/form.pl"
          "name=johnDoe&city=New%20York"
          "application/x-www-form-urlencoded" 8000)

;; assumes default content type and no timeout
(post-url "http://somesite.com/form.pl"
          "name=johnDoe&city=New%20York"
---------------------------------------------------

The above example uploads a user name and city using a special format
called `application/x-www-form-urlencoded`. `post-url` can be used to
post other content types such as files or binary data. See an HTTP
reference for other content-type specifications and data encoding
formats. When the content-type parameter is omitted, `post-url` assumes
`application/x-www-form-urlencoded` as the default content type.

Additional parameters
^^^^^^^^^^^^^^^^^^^^^

When _str-content-type_ is specified, the _str-option_ `"header"` or
`"list"` can be specified as the return page. If the _int-timeout_
option is specified, the custom header option _str-header_ can be
specified, as well. See the function link:#get-url[get-url] for details
on both of these options.

See also the link:#get-url[get-url] and link:#put-url[put-url]
functions.

function::pow[]

*syntax:* (pow _num-1_ _num-2_ [_num-3_ ... ]) +
*syntax:* (pow _num-1_)

Calculates _num-1_ to the power of _num-2_ and so forth.

[source,newlisp]
------------------------
(pow 100 2)      → 10000
(pow 100 0.5)    → 10
(pow 100 0.5 3)  → 1000

(pow 3)  → 9
------------------------

When _num-1_ is the only argument, `pow` assumes 2 for the exponent.

function::prefix[]

*syntax:* (prefix _sym_)

Returns the context of a symbol in _sym_:

[source,newlisp]
-------------------------------------------------
(setf s 'Foo:bar)      → Foo:bar
(prefix s)             → Foo
(context? (prefix s))  → true

(term s)                         → "bar"
(= s (sym (term s) (prefix s)))  → true

>(context (prefix s))   ; switches to context Foo
Foo
Foo>
-------------------------------------------------

See also link:#term[term] to extract the term part of a symbol.

function::pretty-print[]

*syntax:* (pretty-print [_int-length_ [_str-tab_ [_str-fp-format_]])

Reformats expressions for link:#print[print], link:#save[save], or
link:#source[source] and when printing in an interactive console. The
first parameter, _int-length_, specifies the maximum line length, and
_str-tab_ specifies the string used to indent lines. The third parameter
_str-fp-format_ describes the default format for printing floating point
numbers. All parameters are optional. `pretty-print` returns the current
settings or the new settings when parameters are specified.

[source,newlisp]
------------------------------------------------------
(pretty-print)  → (80 " " "%1.10g")  ; default setting

(pretty-print 90 "\t")  → (90 "\t")

(pretty-print 100)  → (100 "\t")

(sin 1)    → 0.8414709848
(pretty-print 80 " " "%1.3f")
(sin 1)    → 0.841

(set 'x 0.0)
x   → 0.000
------------------------------------------------------

The first example reports the default settings of 80 for the maximum
line length and a `space` character for indenting. The second example
changes the line length to 90 and the indent to a TAB character. The
third example changes the line length only. The last example changes the
default format for floating point numbers. This is useful when printing
unformatted floating point numbers without fractional parts, and these
numbers should still be recognizable as floating point numbers. Without
the custom format, `x` would be printed as `0` indistinguishable from
floating point number. All situations where unformatted floating point
numbers are printed, are affected.

Note that `pretty-print` cannot be used to prevent line breaks from
being printed. To completely suppress pretty printing, use the function
link:#string[string] to convert the expression to a raw unformatted
string as follows:

[source,newlisp]
------------------------------
;; print without formatting

(print (string my-expression))
------------------------------

function::primitive?[]

*syntax:* (primitive? _exp_)

Evaluates and tests if _exp_ is a primitive symbol and returns `true` or
`nil` depending on the result.

[source,newlisp]
------------------------
(set 'var define)
(primitive? var)  → true
------------------------

function::print[]

*syntax:* (print _exp-1_ [_exp-2_ ... ])

Evaluates and prints _exp-1_— to the current I/O device, which defaults
to the console window. See the built-in function link:#device[device]
for details on how to specify a different I/O device.

List expressions are indented by the nesting levels of their opening
parentheses.

Several special characters may be included in strings encoded with the
escape character `\`:

[cols="1<,4<",width="40%",options="header",]
|================================================================
|character |description
|`\n` |the line-feed character (ASCII 10)
|`\r` |the carriage-return character (ASCII 13)
|`\t` |the tab character (ASCII 9)
|`\nnn` |where `nnn` is a decimal ASCII code between 000 and 255
|`\xnn` |where `nn` is a hexadecimal ASCII code between 00 and FF
|================================================================

[source,newlisp]
--------------------------------
(print (set 'res (+ 1 2 3)))
(print "the result is" res "\n")

"\065\066\067"  → "ABC"
--------------------------------

To finish printing with a line-feed, use link:#println[println].

function::println[]

*syntax:* (println _exp-1_ [_exp-2_ ... ])

Evaluates and prints _exp-1_— to the current I/O device, which defaults
to the console window. A line-feed is printed at the end. See the
built-in function link:#device[device] for details on how to specify a
different I/O device. `println` works exactly like link:#print[print]
but emits a line-feed character at the end.

See also the link:#write-line[write-line] and link:#print[print]
functions.

function::prob-chi2[]

*syntax:* (prob-chi2 _num-chi2_ _int-df_)

Returns the probability of an observed _Chi²_ statistic in _num-chi2_
with _num-df_ degrees of freedom to be equal or greater under the null
hypothesis. `prob-chi2` is derived from the incomplete Gamma function
link:#gammai[gammai].

[source,newlisp]
--------------------------------
(prob-chi2 10 6)  → 0.1246520195
--------------------------------

See also the inverse function link:#crit-chi2[crit-chi2].

function::prob-f[]

*syntax:* (prob-f _num-f_ _int-df1_ _int-df2_)

Returns the probability of an observed _F_ statistic in _num-f_ with
_int-df1_ and _int-df2_ degrees of freedom to be equal or greater under
the null hypothesis.

[source,newlisp]
-----------------------------------
(prob-f 2.75 10 12)  → 0.0501990804
-----------------------------------

See also the inverse function link:#crit-f[crit-f].

function::prob-t[]

*syntax:* (prob-t _num-t_ _int-df1_)

Returns the probability of an observed _Student's t_ statistic in
_num-t_ with _int-df_ degrees of freedom to be equal or greater under
the null hypothesis.

[source,newlisp]
---------------------------------
(prob-t 1.76 14)  → 0.05011454551
---------------------------------

See also the inverse function link:#crit-t[crit-t].

function::prob-z[]

*syntax:* (prob-z _num-z_)

Returns the probability of _num-z_, not to exceed the observed value
where _num-z_ is a normal distributed value with a mean of `0.0` and a
standard deviation of `1.0`.

[source,newlisp]
-------------------
(prob-z 0.0)  → 0.5
-------------------

See also the inverse function link:#crit-z[crit-z].

function::process[]

*syntax:* (process _str-command_) +
*syntax:* (process _str-command_ _int-pipe-in_ _int-pipe-out_ [_int-win32-option_]) +
*syntax:* (process _str-command_ _int-pipe-in_ _int-pipe-out_ [_int-unix-pipe-error_])

In the first syntax, `process` launches a process specified in
_str-command_ and immediately returns with a process ID or `nil` if a
process could not be created. This process will execute the program
specified or immediately die if _str-command_ could not be executed.

On Mac OS X and other Unixes, the application or script must be
specified with its full path-name. The new process inherits the OS
environment from the parent process.

Command line arguments are parsed out at spaces. Arguments containing
spaces must be delimited using single quotes on Mac OS X and other
Unixes. On Win32, double quotes are used. The process id returned can be
used to destroy the running process using link:#destroy[destroy], if the
process does not exit by itself.

[source,newlisp]
--------------------------------------------------------------
(process "c:/WINDOWS/system32/notepad.exe")  → 1894 ; on Win32

; find out the path of the program to start using exec,
; if the path is not known

(process (first (exec "which xclock")))  → 22607 ; on Unix
--------------------------------------------------------------

If the path of the executable is unknown, `exec` together with the Unix
`which` command can be used to start a program. The pid returned can be
used to link:#destroy[destroy] the process.

In the second syntax, standard input and output of the created process
can be redirected to pipe handles. When remapping standard I/O of the
launched application to a pipe, it is possible to communicate with the
other application via link:#write-line[write-line] and
link:#read-line[read-line] or link:#write[write] and link:#read[read]
statements:

[source,newlisp]
----------------------------------------------------------------
;; Linux/Unix
;; create pipes
(map set '(myin bcout) (pipe))
(map set '(bcin myout) (pipe))

;; launch Unix 'bc' calculator application
(process "/usr/bin/bc" bcin bcout) → 7916

(write myout "3 + 4\n")  ; bc expects a line-feed

(read-line myin)  → "7"

;; bc can use bignums with arbitrary precision

(write myout "123456789012345 * 123456789012345\n")

(read-line myin)  → "15241578753238669120562399025"

;; destroy the process
(destroy 7916)

;; Win32
(map set '(myin cmdout) (pipe))
(map set '(cmdin myout) (pipe))

(process "c:/Program Files/newlisp/newlisp.exe -c" cmdin cmdout)
→ 1284

(write-line myout "(+ 3 4)")

(read-line myin) → "7"

;; destroy the process
(destroy 1284)
----------------------------------------------------------------

On Win32 versions of newLISP, a fourth optional parameter of
_int-win32-option_ can be specified to control the display status of the
application. This option defaults to `1` for showing the application's
window, `0` for hiding it, and `2` for showing it minimized on the
Windows launch bar.

On both Win32 and Linux/Unix systems, standard error will be redirected
to standard out by default. On Linux/Unix, an optional pipe handle for
standard error output can be defined in _int-unix-pipe-error_.

The function link:#peek[peek] can be used to check for information on
the pipe handles:

[source,newlisp]
-------------------------------------------
;; create pipes
(map set '(myin bcout) (pipe))
(map set '(bcin myout) (pipe))
(map set '(errin errout) (pipe))

;; launch Unix 'bc' calculator application
(process "bc" bcin bcout errout)

(write myout command)

;; wait for bc sending result or error info
(while (and (= (peek myin) 0)
            (= (peek errin) 0)) (sleep 10))

(if (> (peek errin) 0)
    (println (read-line errin)))

(if (> (peek myin) 0)
    (println (read-line myin)))
-------------------------------------------

Not all interactive console applications can have their standard I/O
channels remapped. Sometimes only one channel, _in_ or _out_, can be
remapped. In this case, specify `0` (zero) for the unused channel. The
following statement uses only the launched application's output:

[source,newlisp]
------------------------
(process "app" 0 appout)
------------------------

Normally, two pipes are used: one for communications to the child
process and the other one for communications from the child process.

See also the link:#pipe[pipe] and link:#share[share] functions for
inter-process communications and the link:#semaphore[semaphore] function
for synchronization of several processes. See the link:#fork[fork]
function for starting separate newLISP processes on Linux/Unix.

function::prompt-event[]

*syntax:* (prompt-event _sym-event-handler_ | _func-event-handler_)

Refines the prompt as shown in the interactive newLISP shell. The
_sym-event-handler_ or _func-event-handler_ is either a symbol of a
user-defined function or a lambda expression:

[source,newlisp]
-------------------------------------------------------------
> (prompt-event (fn (ctx) (string ctx ":" (real-path) "$ ")))
$prompt-event
MAIN:/Users/newlisp$ (+ 3 4)
7
MAIN:/Users/newlisp$
-------------------------------------------------------------

The current context before calling the `prompt-event` code is passed as
a parameter to the function. Computer output is shown in bold.

The example redefines the `>` prompt to be the current context followed
by a colon `:`, followed by the directory name, followed by the dollar
symbol. Together with the link:#command-event[command-event] function
this can be used to create fully customized shells or custom command
interpreters.

The function in `prompt-event` must return a string of 63 characters
maximum. Not returning a string will leave the prompt unchanged.

function::protected?[]

*syntax:* (protected? _sym_)

Checks if a symbol in _sym_ is protected. Protected symbols are built-in
functions, context symbols, and all symbols made constant using the
link:#constant[constant] function:

[source,newlisp]
-------------------------------
(protected? 'println)    → true
(constant 'aVar 123)
(protected? 'aVar)       → true
-------------------------------

function::push[!,utf8]

*syntax:* (push _exp_ _list_ [_int-index-1_ [_int-index-2_ ... ]]) +
*syntax:* (push _exp_ _list_ [_list-indexes_]) +
*syntax:* (push _str-1_ _str-2_ [_int-index_])

Inserts the value of _exp_ into the list _list_. If _int-index_ is
present, the element is inserted at that index. If the index is absent,
the element is inserted at index `0` (zero), the first element. `push`
is a destructive operation that changes the contents of the target list.

The list changed is returned as a reference on which other built-in
functions can work. See also link:#indexing[Indexing elements of strings
and lists].

If more than one _int-index_ is present, the indices are used to access
a nested list structure. Improper indices (those not matching list
elements) are discarded.

The second version takes a list of _list-indexes_ but is otherwise
identical to the first. In this way, `push` works easily together with
link:#ref[ref] and link:#ref-all[ref-all], which return lists of
indices.

If _list_ does not contain a list, _list_ must contain a `nil` and will
be initialized to the empty list.

Repeatedly using `push` to the end of a list using `-1` as the
_int-index_ is optimized and as fast as pushing to the front of a list
with no index at all. This can be used to efficiently grow a list.

[source,newlisp]
---------------------------------------------------
; inserting in front
(set 'pList '(b c))  → (b c)
(push 'a pList)      → (a b c)
pList                → (a b c)

; insert at index
(push "hello" pList 2)  → (a b "hello" c)

; optimized appending at the end
(push 'z pList -1)  → (a b "hello" c z)

; inserting lists in lists
(push '(f g) pList)  → ((f g) a b "hello" c z)

; inserting at negative index
(push 'x pList -3)  → ((f g) a b "hello" x c z)

; using multiple indices
(push 'h pList 0 -1)  → ((f g h) a b "hello" x c z)

; use indices in a list
(set 'pList '(a b (c d () e)))

(push 'x pList '(2 2 0))  → (a b (c d (x) e))

(ref 'x pList)   → (2 2 0)

(pop pList '(2 2 0))  → x

; push on un-initialized symbol
aVar  → nil

(push 999 aVar)  → (999)

aVar  → (999)
---------------------------------------------------

`push` and pop can be combined to model a queue:

[source,newlisp]
---------------------------
; pop and push a as a queue
(set 'Q '(a b c d e))

(pop (push 'f Q -1)) → a
(pop (push 'g Q -1)) → b

Q →  (c d e f g)
---------------------------

Because `push` returns a reference to the modified list, `pop` can work
on it directly.

In the third syntax `push` can be used to change strings. When
_int-index_ is used, it refers to character positions rather than byte
positions. UTF-8 characters may be multi-byte characters.

[source,newlisp]
-----------------------------------------
;; push on strings

(set 'str "abcdefg")

(push "hijk" str -1)  → "abcdefghijk"
str                   → "abcdefghijk"

(push "123" str)  → "123abcdefghijk"
(push "4" str 3)  → "1234abcdefghijk"

(set 'str "\u03b1\u03b2\u03b3")  →  "αβγ"

(push "*" str 1)  →  "α*βγ"

;; push on a string reference

(set 'lst '("abc" "xyz"))

(push x (lst 0)) → "xabc"

lst → ("xabc" "xyz")
-----------------------------------------

See also the link:#pop[pop] function, which is the inverse operation to
`push`.

function::put-url[]

*syntax:* (put-url _str-url_ _str-content_ [_str-option_] [_int-timeout_ [_str-header_]])

The HTTP PUT protocol is used to transfer information in _str-content_
to a file specified in _str-url_. The lesser-known HTTP PUT mode is
frequently used for transferring web pages from HTML editors to Web
servers. In order to use PUT mode, the web server's software must be
configured correctly. On the Apache web server, use the `'Script PUT'`
directive in the section where directory access rights are configured.

If _str-url_ starts with `file://` then _str-content_ is written to the
local file system.

Optionally, an _int-timeout_ value can be specified in milliseconds as
the last parameter. `put-url` will return `ERR:     timeout` when the
host gives no response and the timeout expires. On other error
conditions, `put-url` returns a string starting with `ERR:` and the
description of the error.

`put-url` requests are also understood by newLISP server nodes.

[source,newlisp]
--------------------------------------------------------
(put-url "http://asite.com/myFile.txt" "Hi there")
(put-url "http://asite.com/myFile.txt" "Hi there" 2000)

(put-url "http://asite.com/webpage.html"
    (read-file "webpage.html"))

; write /home/joe/newfile.txt on the local file system
(puts-url "file:///home/joe/newfile.txt" "Hello World!")
--------------------------------------------------------

The first example creates a file called `myFile.txt` on the target
server and stores the text string `'Hi there'` in it. In the second
example, the local file `webpage.html` is transferred to `asite.com`.

On an Apache web server, the following could be configured in
`httpd.conf`.

[source,newlisp]
---------------------------
<directory /www/htdocs>
Options All
Script PUT /cgi-bin/put.cgi
</directory>
---------------------------

The script `put.cgi` would contain code to receive content from the web
server via STDIN. The following is a working `put.cgi` written in
newLISP for the Apache web server:

[source,newlisp]
---------------------------------------------
#!/usr/home/johndoe/bin/newlisp
#
#
# get PUT method data from CGI STDIN
# and write data to a file specified
# int the PUT request
#
#

(print "Content-Type: text/html\n\n")

(set 'cnt 0)
(set 'result "")

(if (= "PUT" (env "REQUEST_METHOD"))
    (begin
      (set 'len (int (env "CONTENT_LENGTH")))

      (while (< cnt len)
          (set 'n (read (device) buffer len))
          (if (not n)
            (set 'cnt len)
            (begin
              (inc cnt n)
              (write result buffer))))

      (set 'path (append
              "/usr/home/johndoe"
              (env "PATH_TRANSLATED")))

      (write-file path result)
    )
)

(exit)
---------------------------------------------

Note that the script appends ".txt" to the path to avoid the CGI
execution of uploaded malicious scripts. Note also that the two lines
where the file path is composed may work differently in your web server
environment. Check environment variables passed by your web server for
composition of the right file path.

`put-url` returns content returned by the `put.cgi` script.

Additional parameters
^^^^^^^^^^^^^^^^^^^^^

In _str-option_, `"header"` or `"list"` can be specified for the
returned page. If the _int-timeout_ option is specified, the custom
header option _str-header_ can be specified, as well. See the function
link:#get-url[get-url] for details on both of these options.

See also the functions link:#get-url[get-url] and
link:#post-url[post-url], which can be used to upload files when
formatting form data as `multipart/form-data`.

function::pv[]

*syntax:* (pv _num-int_ _num-nper_ _num-pmt_ [_num-fv_ [_int-type_]])

Calculates the present value of a loan with the constant interest rate
_num-interest_ and the constant payment _num-pmt_ after _num-nper_
number of payments. The future value _num-fv_ is assumed to be `0.0` if
omitted. If payment is at the end of the period, _int-type_ is `0`
(zero) or _int-type_ is omitted; for payment at the beginning of each
period, _int-type_ is 1.

[source,newlisp]
---------------------------------------------
(pv (div 0.07 12) 240 775.30)  → -100000.1373
---------------------------------------------

In the example, a loan that would be paid off (future value = `0.0`) in
240 payments of $775.30 at a constant interest rate of 7 percent per
year would start out at $100,000.14.

See also the link:#fv[fv], link:#irr[irr], link:#nper[nper],
link:#npv[npv], and link:#pmt[pmt] functions.

function::quote[]

*syntax:* (quote _exp_)

Returns _exp_ without evaluating it. The same effect can be obtained by
prepending a `'` (single quote) to _exp_.

[source,newlisp]
---------------------------
(quote x)         → x
(quote 123)       → 123
(quote (a b c))   → (a b c)
(= (quote x) 'x)  → true
---------------------------

function::quote?[]

*syntax:* (quote? _exp_)

Evaluates and tests whether _exp_ is quoted. Returns `true` or `nil`
depending on the result.

[source,newlisp]
----------------------
(set 'var ''x)  → 'x
(quote? var)    → true
----------------------

Note that in the `set` statement, ` ''x` is quoted twice because the
first quote is lost during the evaluation of the `set` assignment.

function::rand[]

*syntax:* (rand _int-range_ [_int-N_])

Evaluates the expression in _int-range_ and generates a random number in
the range of `0` (zero) to (_int-range_ - 1). When `0` (zero) is passed,
the internal random generator is initialized using the current value
returned by the C `time()` function. Optionally, a second parameter can
be specified to return a list of length _int-N_ of random numbers.

[source,newlisp]
---------------------------------------------------------------
(dotimes (x 100) (print (rand 2))) =>
11100000110100111100111101 ... 10111101011101111101001100001000

(rand 3 100)  → (2 0 1 1 2 0 …)
---------------------------------------------------------------

The first line in the example prints equally distributed `0`'s and
`1`'s, while the second line produces a list of 100 integers with `0`,
`1`, and `2` equally distributed. Use the link:#random[random] and
link:#normal[normal] functions to generate floating point random
numbers, and use link:#seed[seed] to vary the initial seed for random
number generation.

function::random[]

*syntax:* (random _float-offset_ _float-scale_ _int-n_) +
*syntax:* (random _float-offset_ _float-scale_)

In the first form, `random` returns a list of _int-n_ evenly distributed
floating point numbers scaled (multiplied) by _float-scale_, with an
added offset of _float-offset_. The starting point of the internal
random generator can be seeded using link:#seed[seed].

[source,newlisp]
-----------------------------------------------------------
(random 0 1 10)
→ (0.10898973 0.69823783 0.56434872 0.041507289 0.16516733
    0.81540917 0.68553784 0.76471068 0.82314585 0.95924564)
-----------------------------------------------------------

When used in the second form, `random` returns a single evenly
distributed number:

[source,newlisp]
------------------------
(random 10 5)  → 11.0971
------------------------

See also the link:#normal[normal] and link:#rand[rand] functions.

function::randomize[]

*syntax:* (randomize _list_ [_bool_])

Rearranges the order of elements in _list_ into a random order.

[source,newlisp]
-----------------------------------------------
(randomize '(a b c d e f g))  → (b a c g d e f)
(randomize (sequence 1 5))    → (3 5 4 1 2)
-----------------------------------------------

`randomize` will always return a sequence different from the previous
one without the optional _bool_ flag. This may require the function to
calculate several sets of reordered elements, which in turn may lead to
different processing times with different invocations of the function on
the same input list length. To allow for the output to be equal to the
input, `true` or any expression evaluating to not `nil` must be
specified in _bool_.

`randomize` uses an internal _pseudo random sequence_ generator that
returns the same series of results each time newLISP is started. Use the
link:#seed[seed] function to change this sequence.

function::read[!]

*syntax:* (read _int-file_ _sym-buffer_ _int-size_ [_str-wait_])

Reads a maximum of _int-size_ bytes from a file specified in _int-file_
into a buffer in _sym-buffer_. Any data referenced by the symbol
_sym-buffer_ prior to the reading is deleted. The handle in _int-file_
is obtained from a previous link:#open[open] statement. The symbol
_sym-buffer_ contains data of type string after the read operation.
_sym-buffer_ can also be a default functor specified by a context symbol
for reference passing in and out of user-defined functions.

`read` is a shorter writing of `read-buffer`. The longer form still
works but is deprecated and should be avoided in new code.

Optionally, a string to be waited for can be specified in _str-wait_.
`read` will read a maximum amount of bytes specified in _int-size_ or
return earlier if _str-wait_ was found in the data. The wait-string is
part of the returned data and must not contain binary `0` (zero)
characters.

Returns the number of bytes read or `nil` when the wait-string was not
found. In any case, the bytes read are put into the buffer pointed to by
_sym-buffer_, and the file pointer of the file read is moved forward. If
no new bytes have been read, _sym-buffer_ will contain `nil`.

[source,newlisp]
---------------------------------------
(set 'handle (open "aFile.ext" "read"))
(read handle buff 200)
---------------------------------------

Reads 200 bytes into the symbol `buff` from the file `aFile.ext`.

[source,newlisp]
-----------------------------------
(read handle buff 1000 "password:")
-----------------------------------

Reads 1000 bytes or until the string `password:` is encountered. The
string `password:` will be part of the data returned.

See also the link:#write[write] function.

function::read-char[]

*syntax:* (read-char [_int-file_])

Reads a byte from a file specified by the file handle in _int-file_ or
from the current I/O device - e.g. _stdin_ - when no file handle is
specified. The file handle is obtained from a previous link:#open[open]
operation. Each `read-char` advances the file pointer by one byte. Once
the end of the file is reached, `nil` is returned.

[source,newlisp]
------------------------------------------
(define (slow-file-copy from-file to-file)
    (set 'in-file (open from-file "read"))
    (set 'out-file (open to-file "write"))
    (while (set 'chr (read-char in-file))
        (write-char out-file chr))
    (close in-file)
    (close out-file)
    "finished")
------------------------------------------

Use link:#read-line[read-line] and link:#device[device] to read whole
text lines at a time. Note that newLISP supplies a fast built-in
function called link:#copy-file[copy-file] for copying files.

See also the link:#write-char[write-char] function.

function::read-expr[]

*syntax:* (read-expr _str-source_ [_sym-context_ [_exp-error_ [_int-offset_]]])

`read-expr` parses the first expressions it finds in _str-source_ and
returns the translated expression without evaluating it. An optional
context in _sym-context_ specifies a namespace for the translated
expression.

After a call to `read-expr` the system variable `$0` contains the number
of characters scanned.

If an error occurs when translating _str-source_ the expression in
_exp-error_ is evaluated and the result returned.

_int-offset_ specifies an optional offset into _str-source_ where
processing should start. When calling `read-expr` repeatedly this number
can be updated using `$0`.

[source,newlisp]
--------------------------------------------------------
(set 'code "; a statement\n(define (double x) (+ x x))")

(read-expr code) → (define (double x) (+ x x))

$0 → 41
--------------------------------------------------------

`read-expr` behaves similar to link:#eval-string[eval-string] but
without the evaluation step:

[source,newlisp]
----------------------------------
(read-expr "(+ 3 4)")    → (+ 3 4)

(eval-string "(+ 3 4)")  → 7
----------------------------------

Using `read-expr` a customized code reader can be programmed
preprocessing expressions before evaluation.

See also link:#reader-event[reader-event] for preprocessing expressions
event-driven.

function::read-file[]

*syntax:* (read-file _str-file-name_)

Reads a file in _str-file-name_ in one swoop and returns a string buffer
containing the data.

On failure the function returns `nil`. For error information, use
link:#sys-error[sys-error] when used on files. When used on URLs
link:#net-error[net-error] gives more error information.

[source,newlisp]
-------------------------------------------------------
(write-file "myfile.enc"
    (encrypt (read-file "/home/lisp/myFile") "secret"))
-------------------------------------------------------

The file `myfile` is read, then encrypted using the password `"secret"`
before being written back into a new file titled `"myfile.enc"` in the
current directory.

`read-file` can take an `http://` or `file://` URL in _str-file-name_.
When the prefix is `http://`, `read-file` works exactly like
link:#get-url[get-url] and can take the same additional parameters.

[source,newlisp]
-------------------------------------------------
(read-file "http://asite.com/somefile.tgz" 10000)
-------------------------------------------------

The file `somefile.tgz` is retrieved from the remote location
`http://asite.com`. The file transfer will time out after 10 seconds if
it is not finished. In this mode, `read-file` can also be used to
transfer files from remote newLISP server nodes.

See also the link:#write-file[write-file] and
link:#append-file[append-file] functions.

function::read-key[]

*syntax:* (read-key)

Reads a key from the keyboard and returns an integer value. For
navigation keys, more than one `read-key` call must be made. For keys
representing ASCII characters, the return value is the same on all OSes,
except for navigation keys and other control sequences like function
keys, in which case the return values may vary on different OSes and
configurations.

[source,newlisp]
---------------------------------------------------
(read-key)  → 97  ; after hitting the A key
(read-key)  → 65  ; after hitting the shifted A key
(read-key)  → 10  ; after hitting [enter] on Linux
(read-key)  → 13  ; after hitting [enter] on Win32

(while (!= (set 'c (read-key)) 1) (println c))
---------------------------------------------------

The last example can be used to check return sequences from navigation
and function keys. To break out of the loop, press `Ctrl-A`.

Note that `read-key` will only work when newLISP is running in a Unix
shell or Win32 command shell. It will not work in the Java based
newLISP-GS or Tcl/Tk based newLISP-Tk frontend. It will also not work
when executed by newLISP Unix shared library or newLISP Win32 DLL
(Dynamic Link Library).

function::read-line[]

*syntax:* (read-line [_int-file_])

Reads from the current I/O device a string delimited by a line-feed
character (ASCII 10). There is no limit to the length of the string that
can be read. The line-feed character is not part of the returned string.
The line always breaks on a line-feed, which is then swallowed. A line
breaks on a carriage return (ASCII 13) only if followed by a line-feed,
in which case both characters are discarded. A carriage return alone
only breaks and is swallowed if it is the last character in the stream.

By default, the current link:#device[device] is the keyboard
(link:#device[device] `0`). Use the built-in function
link:#device[device] to specify a different I/O device (e.g., a file).
Optionally, a file handle can be specified in the _int-file_ obtained
from a previous link:#open[open] statement.

The last buffer contents from a read-line operation can be retrieved
using link:#current-line[current-line].

When `read-line` is reading from a file or from _stdin_ in a CGI program
or pipe, it will return `nil` when input is exhausted.

When using `read-line` on _stdin_, line length is limited to 2048
characters and performance is much faster.

[source,newlisp]
----------------------------------------
(print "Enter a num:")
(set 'num (int (read-line)))

(set 'in-file (open "afile.dat" "read"))
(while (read-line in-file)
        (write-line))
(close in-file)
----------------------------------------

The first example reads input from the keyboard and converts it to a
number. In the second example, a file is read line-by-line and displayed
on the screen. The `write-line` statement takes advantage of the fact
that the result from the last `read-line` operation is stored in a
system internal buffer. When link:#write-line[write-line] is used
without argument, it writes the contents of the last `read-line` buffer
to the screen.

See also the link:#current-line[current-line] function for retrieving
this buffer.

function::read-utf8[]

*syntax:* (read-utf8 _int-file_)

Reads an UTF-8 character from a file specified by the file handle in
_int-file_. The file handle is obtained from a previous link:#open[open]
operation. Each `read-utf8` advances the file pointer by the number of
bytes contained in the UTF-8 character. Once the end of the file is
reached, `nil` is returned.

The function returns an integer value which can be converted to a
displayable UTF-8 character string using the link:#char[char] function.

[source,newlisp]
---------------------------------------
(set 'fle (open "utf8text.txt" "read"))
(while (setq chr (read-utf8 fle))
    (print (char chr)))
---------------------------------------

The example reads a file containing UTF-8 encoded text and displays it
to the terminal screen.

function::reader-event[]

*syntax:* (reader-event [_sym-event-handler | func-event-handler_]) +
*syntax:* (reader-event 'nil)

An event handler can be specified to hook between newLISP's reader,
translation and evaluation process. The function specified in
_sym-event-handler_ or _func-event-handler_ gets called after newLISP
translates an expression and before evaluating it. The event handler can
do transformation on the expression before it gets evaluated.

Specifying a quoted `nil` for the event will disable it.

The following one-liner `reader-event` could be used to enhance the
interactive shell with a tracer:

[source,newlisp]
-----------------------------------------------
>(reader-event (lambda (ex) (print " => " ex)))
$reader-event
> (+ 1 2 3)
 => (+ 1 2 3)
6
>
-----------------------------------------------

The expression intercepted passes through unchanged, but output is
enhanced.

The following example shows the core of a simple macro rewrite
pre-processor. A full version is installed in the standard location as
module file `macro.lsp`.

[source,newlisp]
---------------------------------------------------------------------
(context 'macro)

; initialize macro list
(setf macro-list '())

; registers a macro
(define-macro (macro:macro callp body)
    (push (list (first callp) '*) macro-list -1)
    (eval (expand '(define-macro callp (expand 'body)) 'callp 'body))
)

; the event handler translating expressions
(define (rewrite expr)
    (if (list? expr)
        (dolist (pattern macro-list)
            (if (match pattern expr)
                (setf expr (eval expr))
                (set-ref-all pattern expr (eval $it) match)) )
    )
    expr
)

; register event handler
(reader-event rewrite)

(context MAIN)
---------------------------------------------------------------------

The reader event function will be called after each reading of an
s-expression by the link:#load[load] or link:#eval-string[eval-string]
function.

Register a function macro for pre-processing:

[source,newlisp]
------------------------------------------------------
(macro (square X) (pow X 2)) ; must use uppercase vars

; use the macro
(square 3) → 9
------------------------------------------------------

After registering the macro `square` newLISP will expand each occurrence
of a `(square ...)` to a `(pow ... 2)` expression.

Note, that variables in the macro definition must be upper-case. The
macro registering function uses a syntax form of `expand` working only
on upper-case variables.

For a more detailed description see the documentation for `macro.lsp`.

function::real-path[]

*syntax:* (real-path [_str-path_])

Returns the full path from the relative file path given in _str-path_.
If a path is not given, `"."` (the current directory) is assumed.

[source,newlisp]
----------------------------------------------------
(real-path)  → "/usr/home/fred"  ; current directory
(real-path "./somefile.txt")
→ "/usr/home/fred/somefile.txt"
----------------------------------------------------

The output length is limited by the OS's maximum allowed path length. If
`real-path` fails (e.g., because of a nonexistent path), `nil` is
returned.

function::receive[!]

*syntax:* (receive _int-pid_ _sym-message_) +
*syntax:* (receive)

In the first syntax, the function is used for message exchange between
child processes launched with link:#spawn[spawn] and their parent
process. The message received replaces the contents in _sym-message._

The function reads one message from the receiver queue of _int-pid_ for
each invocation. When the queue is empty, `nil` is returned.

[source,newlisp]
------------------------------
; sending process
(send spid "hello")  → true

; receiving process
(receive pid msg)    → true
msg                  → "hello"
------------------------------

To make `receive` blocking and wait for arriving messages, use the
following form:

[source,newlisp]
----------------------------------
; wait until a message can be read
(until (receive pid msg))
----------------------------------

The function will loop until a message can be read from the queue.

In the second syntax, the function returns a list of all child processes
with pending messages for the parent process:

[source,newlisp]
---------------------------------------------------
; read pending messages from child processes
(dolist (pid (receive))
    (receive pid msg)
    (println "received message: " msg " from:" pid)
)
---------------------------------------------------

The list of child process IDs returned by `(receive)` only contains PIDs
of processes which have unread messages in their send queues. The
`(receive pid msg)` statement now can be issued non-blocking, because it
always is guarenteed to find a pending message in a child's message
queue.

The `receive` function is not available on Win32.

For a more detailed discussion of this function and examples, see the
link:#send[send] function.

function::ref[]

*syntax:* (ref _exp-key_ _list_ [_func-compare_ [true]])

`ref` searches for the key expression _exp-key_ in _list_ and returns a
list of integer indices or an empty list if _exp-key_ cannot be found.
`ref` can work together with link:#push[push] and link:pop[pop], both of
which can also take lists of indices.

By default, `ref` checks if expressions are equal. With _func-compare_,
more complex comparison functions can be used. The comparison function
can be a previously defined function. Note that this function always
takes two arguments, even if only the second argument is used inside the
function.

When the optional `true` parameter is present, the element found is
returned instead of the index vector.

[source,newlisp]
--------------------------------------------------------
; get index vectors for list elements

(set 'pList '(a b (c d (x) e)))

(ref 'x pList)    → (2 2 0)

(ref '(x) pList)   → (2 2)

; the key expression is in a variable

(set 'p '(c d (x) e))

(ref p pList p)     → (2)

; indexing using the vector returned from ref

(set 'v (ref '(x) pList)) → (2 2)

(pList v) → (x)

; if nothing is found, nil is returned

(ref 'foo plist)  → nil

; not specifying a comparison functor assumes =

(set 'L '(a b (c d (e) f)))

(ref 'e L)      → (2 2 0)
(ref 'e L =)    → (2 2 0)

; a is the first symbol where e is greater

(ref 'e L >)  → (0)

; return the element instead of the index

(ref 'e L > true)  → a

; use an anonymous comparison function

(ref 'e L (fn (x y) (or (= x y) (= y 'd))))      → (2 1)

(ref 'e L (fn (x y) (or (= x y) (= y 'd))) true) → d
--------------------------------------------------------

The following example shows the use of link:#match[match] and
link:#unify[unify] to formulate searches that are as powerful as regular
expressions are for strings:

[source,newlisp]
--------------------------------------------
(set 'L '((l 3) (a 12) (k 5) (a 10) (z 22)))

; use match as a comparison function

(ref '(a ?) L match) → (1)

; use unify as a comparison function

(set 'L '( ((a b) (c d)) ((e e) (f g)) ))

(ref '(X X) L unify)      → (1 0)

(ref '(X g) L unify)      → (1 1)

(ref '(X g) L unify true) → (f g)
--------------------------------------------

The `'(X X)` pattern with link:#unify[unify] searches for a list pair
where the two elements are equal. The `unify` pattern `'(X g)` searches
for a list pair with the symbol `g` as the second member. The patterns
are quoted to protect them from evaluation.

Pass the list as a default functor:

[source,newlisp]
---------------------------
(set 'C:C '(a b (c d) e f))

(ref 'd C)  → (2 1)
---------------------------

This is suitable when passing lists by reference using a context. See
also the chapter link:#pass_big[Passing data by reference].

See also the link:#ref-all[ref-all] function, which searches for all
occurrences of a key expression in a nested list.

function::ref-all[]

*syntax:* (ref-all _exp-key_ _list_ [_func-compare_ [true]])

Works similarly to link:#ref[ref], but returns a list of all index
vectors found for _exp-key_ in _list_.

When the optional `true` parameter is present, the elements found is
returned of the index vectors.

By default, `ref-all` checks if expressions are equal. With
_func-compare_, more complex comparison functions can be used.

[source,newlisp]
----------------------------------------------------------------------------------
(set 'L '(a b c (d a f (a h a)) (k a (m n a) (x))))

(ref-all 'a L) → ((0) (3 1) (3 3 0) (3 3 2) (4 1) (4 2 2))

; the index vector returned by ref-all can be used to index the list

(L '(3 1)) → a

; mapped implicit indexing of L

(map 'L (ref-all 'a L)) → (a a a a a a)

; with comparison operator

(set 'L '(a b c (d f (h l a)) (k a (m n) (x))))

; not specifying a comparison functor assumes =

(ref-all 'c L)       → ((2))
(ref-all 'c L =)     → ((2))

; look for all elements where c is greater

(ref-all 'c L >)       → ((0) (1) (3 2 2) (4 1))
(ref-all 'c L > true)  → (a b a a)

; use an anonymous function to compare

(ref-all 'a L (fn (x y) (or (= x y) (= y 'k))))
→ ((0) (3 2 2) (4 0) (4 1))

; the key is nil because the comparison function only looks at the second argument

(ref-all nil L (fn (x y) (> (length y) 2)))
→ ((3) (3 2) (4))

; define the comparison functions first

(define (is-long? x y) (> (length y) 2)) ; the x gets occupied by 'nil

(ref-all nil L is-long?)    →  ((3) (3 2) (4))

(define (is-it-or-d x y) (or (= x y) (= y 'd)))

(set 'L '(a b (c d (e) f)) )

(ref-all 'e L is-it-or-d)  → ((2 1) (2 2 0))
----------------------------------------------------------------------------------

The comparison function can be a previously defined function. Note that
the comparison function always takes two arguments, even if only the
second argument is used inside the function (as in the example using
`is-long?`).

Using the link:#match[match] and link:#unify[unify] functions, list
searches can be formulated that are as powerful as regular expression
searches are for strings.

[source,newlisp]
-------------------------------------------------------------
(set 'L '((l 3) (a 12) (k 5) (a 10) (z 22)) )

; look for all pairs staring with the symbol a

(ref-all '(a ?) L match)      → ((1) (3))
(ref-all '(a ?) L match true) → ((a 12) (a 10))

; look for all pairs where elements are equal

(set 'L '( ((a b) (c d)) ((e e) (f g)) ((z) (z))))

(ref-all '(X X) L unify)      → ((1 0) (2))
(ref-all '(X X) L unify true) → ((e e) ((z) (z)))

; look for all pairs where the second element is the symbol g

(set 'L '( ((x y z) g) ((a b) (c d)) ((e e) (f g)) ))

(ref-all '(X g) L unify)      → ((0) (2 1))
(ref-all '(X g) L unify true) → (((x y z) g) (f g))
-------------------------------------------------------------

See also the link:#ref[ref] function.

function::regex[]

*syntax:* (regex _str-pattern_ _str-text_ [_int-option_ [_int-offset_]])

Performs a Perl Compatible Regular Expression (PCRE) search on
_str-text_ with the pattern specified in _str-pattern_. The same regular
expression pattern matching is also supported in the functions
link:#directory[directory], link:#find[find], link:#find-all[find-all],
link:#parse[parse], link:#replace[replace], and link:#search[search]
when using these functions on strings.

`regex` returns a list with the matched strings and substrings and the
beginning and length of each string inside the text. If no match is
found, it returns `nil`. The offset numbers can be used for subsequent
processing.

Additionally an _int-option_ can be specified to control certain regular
expression options explained later. The additional _int-offset_
parameter tells `regex` to start searching for a match not at the
beginning of the string but at an offset.

The offset and length numbers in the `regex` results are given based on
single bytes even when running the UTF-8 enabled version of newLISP.

`regex` also sets the variables `$0, $1,` and `$2—` to the expression
and subexpressions found. Just like any other symbol in newLISP, these
variables or their equivalent expressions `($ 0), ($ 1),` and `($ 2)—`
can be used in other newLISP expressions for further processing.

Functions using regular expressions will not reset the `$0, $1 ... $15`
variables to `nil` when no match is found.

[source,newlisp]
---------------------------------------------------------------
(regex "b+" "aaaabbbaaaa")  → ("bbb" 4 3)

; case-insensitive search option 1
(regex "b+" "AAAABBBAAAA" 1)  → ("BBB" 4 3)

(regex "[bB]+" "AAAABbBAAAA" )  → ("BbB" 4 3)

(regex "http://(.*):(.*)" "http://nuevatec.com:80")
→ ("http://nuevatec.com:80" 0 22 "nuevatec.com" 7 12 "80" 20 2)

$0  → "http://nuevatec.com:80"
$1  → "nuevatec.com"
$2  → "80"

(dotimes (i 3) (println ($ i)))
http://nuevatec.com:80
nuevatec.com
80
→ "80"
---------------------------------------------------------------

The second example shows the usage of extra options, while the third
example demonstrates more complex parsing of two subexpressions that
were marked by parentheses in the search pattern. In the last example,
the expression and subexpressions are retrieved using the system
variables `$0` to `$2` or their equivalent expression `($ 0)` to
`($ 2)`.

When `""` (quotes) are used to delimit strings that include literal
backslashes, the backslash must be doubled in the regular expression
pattern. As an alternative, `{ }` (curly brackets) or `[text]` and
`[/text]` (text tags) can be used to delimit text strings. In these
cases, no extra backslashes are required.

Characters escaped by a backslash in newLISP (e.g., the quote `\"` or
`\n`) need not to be doubled in a regular expression pattern, which
itself is delimited by quotes.

[source,newlisp]
-----------------------------------------------------------
;; double backslash for parentheses (special char in regex)
(regex "\\(abc\\)" "xyz(abc)xyz")  → ("(abc)" 3 5)

;; one backslash for quotes (special char in newLISP)
(regex "\"" "abc\"def")  → ("\"" 3 1)

;; brackets as delimiters
(regex {\(abc\)} "xyz(abc)xyz")  → ("(abc)" 3 5)

;; brackets as delimiters and quote in pattern
(regex {"} "abc\"def")  → ("\"" 3 1)

;; text tags as delimiters, good for multiline text in CGI
(regex [text]\(abc\)[/text] "xyz(abc)xyz")  → ("(abc)" 3 5)
(regex [text]"[/text] "abc\"def")           → ("\"" 3 1)
-----------------------------------------------------------

When curly brackets or text tags are used to delimit the pattern string
instead of quotes, a simple backslash is sufficient. The pattern and
string are then passed in raw form to the regular expression routines.
When curly brackets are used inside a pattern itself delimited by curly
brackets, the inner brackets must be balanced, as follows:

[source,newlisp]
-------------------------------------------------
;; brackets inside brackets are balanced
(regex {\d{1,3}} "qwerty567asdfg")  → ("567" 6 3)
-------------------------------------------------

The following constants can be used for _int-option_. Several options
can be combined using a binary or `|` (pipe) operator. E.g. `(| 1 4)`
would combine options `1` and `4`. The uppercase names are used in the
PCRE regex documentation and could be predefined in `init.lsp`. The last
option is a newLISP custom option only to be used in
link:#replace[replace]; it can be combined with PCRE options.

[cols="3<,1<,5<",width="75%",options="header",]
|=======================================================================
|PCRE name |no |description
|PCRE_CASELESS |1 |treat uppercase like lowercase

|PCRE_MULTILINE |2 |limit search at a newline like Perl's /m

|PCRE_DOTALL |4 |. (dot) also matches newline

|PCRE_EXTENDED |8 |ignore whitespace except inside char class

|PCRE_ANCHORED |16 |anchor at the start

|PCRE_DOLLAR_ENDONLY |32 |$ matches at end of string, not before newline

|PCRE_EXTRA |64 |additional functionality currently not used

|PCRE_NOTBOL |128 |first ch, not start of line; ^ shouldn't match

|PCRE_NOTEOL |256 |last char, not end of line; $ shouldn't match

|PCRE_UNGREEDY |512 |invert greediness of quantifiers

|PCRE_NOTEMPTY |1024 |empty string considered invalid

|PCRE_UTF8 |2048 |pattern and strings as UTF-8 characters

|REPLACE_ONCE |0x8000 |replace only one occurrence only for use in
link:#replace[replace]

|PRECOMPILED |0x10000 |pattern is pre-compiled, can only be combined
with RREPLACE_ONCE 0x8000
|=======================================================================

The settings of the PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL, and
PCRE_EXTENDED options can be changed from within the pattern by a
sequence of option letters enclosed between "(?" and ")". The option
letters are:

[cols="1<,4<",width="15%"]
|=====================
|i |for PCRE_CASELESS
|m |for PCRE_MULTILINE
|s |for PCRE_DOTALL
|x |for PCRE_EXTENDED
|=====================

Note that regular expression syntax is very complex and feature-rich
with many special characters and forms. Please consult a book or the
PCRE manual pages for more detail. Most PERL books or introductions to
Linux or Unix also contain chapters about regular expressions. See also
http://www.pcre.org[http://www.pcre.org] for further references and
manual pages.

Regular expression patterns can be precompiled for higher speed when
using changing repetitive patterns with link:#regex-comp[regex-comp].

function::regex-comp[]

*syntax:* (regex-comp _str-pattern_ [_int-option_])

newLISP automatically compiles regular expression patterns and caches
the last compilation to speed up repetitive pattern searches. If
patterns change from one to the next, but are repeated over and over
again, then the caching of the last pattern is not sufficient.
`regex-comp` can be used to pre-compile repetitive patterns to speed up
regular expression searches:

[source,newlisp]
----------------------------------------------
; slower without pre-compilation

(dolist (line page)
    (replace pattern-str1 line repl1 0)
    (replace pattern-str2 line repl2 512)
)

; fast with pre-compilation and option 0x10000

(set 'p1 (regex-comp pattern-str1))
(set 'p2 (regex-comp pattern-str2 512))

(dolist (line page)
    (replace p1 line repl1 0x10000)
    (replace p2 line repl2 0x10000)
)
----------------------------------------------

When using pre-compiled patterns in any of the functions using regular
expressions, the option number is set to `0x10000` to signal that
pre-compiled patterns are used. Normal pattern options are specified
during pre-compilation with `regex-comp` . The `0x10000` option can only
be combined with `0x8000`, the option used to specify that only one
replacement should be made when using link:#replace[replace].

function::remove-dir[]

*syntax:* (remove-dir _str-path_)

Removes the directory whose path name is specified in _str-path_. The
directory must be empty for `remove-dir` to succeed. Returns `nil` on
failure.

[source,newlisp]
-------------------
(remove-dir "temp")
-------------------

Removes the directory `temp` in the current directory.

function::rename-file[]

*syntax:* (rename-file _str-path-old_ _str-path-new_)

Renames a file or directory entry given in the path name _str-path-old_
to the name given in _str-path-new_. Returns `nil` or `true` depending
on the operation's success.

[source,newlisp]
---------------------------------------
(rename-file "data.lisp" "data.backup")
---------------------------------------

function::replace[!]

*syntax:* (replace _exp-key_ _list_ _exp-replacement_ [_func-compare_]) +
*syntax:* (replace _exp list_) +
*syntax:* (replace _str-key_ _str-data_ _exp-replacement_) +
*syntax:* (replace _str-pattern_ _str-data_ _exp-replacement_ _int-regex-option_)

List replacement
^^^^^^^^^^^^^^^^

If the second argument is a list, `replace` replaces all elements in the
list _list_ that are equal to the expression in _exp-key_. The element
is replaced with _exp-replacement_. Note that `replace` is destructive.
It changes the list passed to it and returns the changed list. The
number of replacements made is contained in the system variable `$0`
when the function returns. During executions of the replacement
expression, the system variable `$0` and the anaphoric system variable
`$it` are set to the expression to be replaced.

Optionally, _func-compare_ can specify a comparison operator or
user-defined function. By default, _func-compare_ is the `=` (equals
sign).

[source,newlisp]
-----------------------------------------------------------------
;; list replacement

(set 'aList '(a b c d e a b c d))

(replace 'b aList 'B)  → (a B c d e a B c d)
aList  → (a B c d e a B c d)
$0     → 2  ; number of replacements

;; list replacement with special compare functor/function

; replace all numbers where 10 < number
(set 'L '(1 4 22 5 6 89 2 3 24))

(replace 10 L 10 <) → (1 4 10 5 6 10 2 3 10)

; same as:

(replace 10 L 10 (fn (x y) (< x y))) → (1 4 10 5 6 10 2 3 10)

; change name-string to symbol, x is ignored as nil

(set 'AL '((john 5 6 4) ("mary" 3 4 7) (bob 4 2 7 9) ("jane" 3)))

(replace nil AL (cons (sym ($it 0)) (rest $it))
                (fn (x y) (string? (y 0))))
→ ((john 5 6 4) (mary 3 4 7) (bob 4 2 7 9) (jane 3))
-----------------------------------------------------------------

Using the link:#match[match] and link:#unify[unify] functions, list
searches can be formulated that are as powerful as regular expression
string searches:

[source,newlisp]
---------------------------------------------------------------------------------------
; calculate the sum in all associations with 'mary

(set 'AL '((john 5 6 4) (mary 3 4 7) (bob 4 2 7 9) (jane 3)))

(replace '(mary *)  AL (list 'mary (apply + (rest $it))) match)
→ ((john 5 6 4) (mary 14) (bob 4 2 7 9) (jane 3))

; make sum in all expressions

(set 'AL '((john 5 6 4) (mary 3 4 7) (bob 4 2 7 9) (jane 3)))

(replace '(*) AL (list ($0 0) (apply + (rest $it))) match)
→ ((john 15) (mary 14) (bob 22) (jane 3))

; using unify
(replace '(X X) '((3 10) (2 5) (4 4) (6 7) (8 8)) (list ($it 0) 'double ($it 1)) unify)
→ ((3 10) (2 5) (4 double 4) (6 7) (8 double 8))

---------------------------------------------------------------------------------------

List removal
^^^^^^^^^^^^

The last form of `replace` has only two arguments: the expression _exp_
and _list_. This form removes all _exp_s found in _list_.

[source,newlisp]
--------------------------------
;; removing elements from a list

(set 'lst '(a b a a c d a f g))
(replace 'a lst)  → (b c d f g)
lst               → (b c d f g)

$0  → 4
--------------------------------

String replacement without regular expression
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If all arguments are strings, `replace` replaces all occurrences of
_str-key_ in _str-data_ with the evaluated _exp-replacement_, returning
the changed string. The expression in _exp-replacement_ is evaluated for
every replacement. The number of replacements made is contained in the
system variable `$0`. This form of `replace` can also process binary
`0`s (zeros).

[source,newlisp]
--------------------------------------------------
;; string replacement
(set 'str "this isa sentence")
(replace "isa" str "is a")  → "this is a sentence"
--------------------------------------------------

Regular expression replacement
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The presence of a fourth parameter indicates that a regular expression
search should be performed with a regular expression pattern specified
in _str-pattern_ and an option number specified in _int-option_ (e.g.,
`1` (one) for case-insensitive searching or `0` (zero) for a standard
Perl Compatible Regular Expression (PCRE) search). See
link:#regex[regex] above for details.

By default, `replace` replaces all occurrences of a search string even
if a beginning-of-line specification is included in the search pattern.
After each replace, a new search is started at a new position in
_str-data_. Setting the option bit to `0x8000` in _int-option_ will
force `replace` to replace only the first occurrence. The changed string
is returned.

`replace` with regular expressions also sets the internal variables
`$0, $1,` and `$2—` with the contents of the expressions and
subexpressions found. The anaphoric system variable `$it` is set to the
same value as `$0`. These can be used to perform replacements that
depend on the content found during replacement. The symbols
`$it, $0, $1,` and `$2—` can be used in expressions just like any other
symbols. If the replacement expression evaluates to something other than
a string, no replacement is made. As an alternative, the contents of
these variables can also be accessed by using `($ 0), ($ 1), ($ 2),` and
so forth. This method allows indexed access (e.g., `($ i)`, where `i` is
an integer).

After all replacements are made, the number of replacements is contained
in the system variable `$0`.

[source,newlisp]
-----------------------------------------------------------
;; using the option parameter to employ regular expressions

(set 'str "ZZZZZxZZZZyy")     → "ZZZZZxZZZZyy"
(replace "[x|y]" str "PP" 0)  → "ZZZZZPPZZZZPPPP"
str                           → "ZZZZZPPZZZZPPPP"

;; using system variables for dynamic replacement

(set 'str "---axb---ayb---")
(replace "(a)(.)(b)" str (append $3 $2 $1) 0)
→ "---bxa---bya---"

str  → "---bxa---bya---"

;; using the 'replace once' option bit 0x8000

(replace "a" "aaa" "X" 0)  → "XXX"

(replace "a" "aaa" "X" 0x8000)  → "Xaa"

;; URL translation of hex codes with dynamic replacement

(set 'str "xxx%41xxx%42")
(replace "%([0-9A-F][0-9A-F])" str
               (char (int (append "0x" $1))) 1)

str  → "xxxAxxxB"

$0   → 2
-----------------------------------------------------------

The link:#setf[setf] function together with link:#nth[nth],
link:#first[first] or link:#last[last] can also be used to change
elements in a list.

See link:#directory[directory], link:#find[find],
link:#find-all[find-all], link:#parse[parse], link:#regex[regex], and
link:#search[search] for other functions using regular expressions.

function::reset[]

*syntax:* (reset) +
*syntax:* (reset true)

In the first syntax, `reset` returns to the top level of evaluation,
switches the link:#trace[trace] mode off, and switches to the MAIN
context/namespace. `reset` restores the top-level variable environment
using the saved variable environments on the stack. It also fires an
error "user reset - no error". This behavior can be used when writing
error handlers.

`reset` may return memory that was claimed by newLISP to the operating
system. `reset` walks through the entire cell space, which may take a
few seconds in a heavily loaded system.

`reset` occurs automatically after an error condition.

In the second syntax, `reset` will stop the current process and start a
new clean newLISP process with the same command-line parameters. This
mode will only work when newLISP was started using its full path-name,
e.g. `/usr/bin/newlisp` instead of only `newlisp`. This mode is not
available on Win32.

function::rest[utf8]

*syntax:* (rest _list_) +
*syntax:* (rest _array_) +
*syntax:* (rest _str_)

Returns all of the items in a list or a string, except for the first.
`rest` is equivalent to _cdr_ or _tail_ in other Lisp dialects.

[source,newlisp]
------------------------------------------
(rest '(1 2 3 4))            → (2 3 4)
(rest '((a b) c d))          → (c d)
(set 'aList '(a b c d e))    → (a b c d e)
(rest aList)                 → (b c d e)
(first (rest aList))         → b
(rest (rest aList))          → (d e)
(rest (first '((a b) c d)))  → (b)

(set 'A (array 2 3 (sequence 1 6)))
→ ((1 2) (3 4) (5 6))

(rest A)  → ((3 4) (5 6))

(rest '()) → ()
------------------------------------------

In the second version, `rest` returns all but the first character of the
string _str_ in a string.

[source,newlisp]
------------------------------------
(rest "newLISP")          → "ewLISP"
(first (rest "newLISP"))  → "e"
------------------------------------

See also the link:#first[first] and link:#last[last] functions.

Note that an _implicit rest_ is available for lists. See the chapter
link:#implicit_rest_slice[Implicit rest and slice].

Note that link:#rest[rest] works on character boundaries rather than
byte boundaries when the UTF-8–enabled version of newLISP is used.

function::reverse[!]

*syntax:* (reverse _list_) +
*syntax:* (reverse _string_)

In the first form, `reverse` reverses and returns the _list_. Note that
`reverse` is destructive and changes the original list.

[source,newlisp]
----------------------------------
(set 'l '(1 2 3 4 5 6 7 8 9))

(reverse l)  → (9 8 7 6 5 4 3 2 1)
l            → (9 8 7 6 5 4 3 2 1)
----------------------------------

In the second form, `reverse` is used to reverse the order of characters
in a string.

[source,newlisp]
--------------------------
(set 'str "newLISP")

(reverse str)  → "PSILwen"
str            → "PSILwen"
--------------------------

See also the link:#sort[sort] function.

function::rotate[!]

*syntax:* (rotate _list_ [_int-count_]) +
*syntax:* (rotate _str_ [_int-count_])

Rotates and returns the _list_ or string in _str_. A count can be
optionally specified in _int-count_ to rotate more than one position. If
_int-count_ is positive, the rotation is to the right; if _int-count_ is
negative, the rotation is to the left. If no _int-count_ is specified,
`rotate` rotates 1 to the right. `rotate` is a destructive function that
changes the contents of the original list or string.

[source,newlisp]
------------------------------------
(set 'l '(1 2 3 4 5 6 7 8 9))

(rotate l)    → (9 1 2 3 4 5 6 7 8)
(rotate l 2)  → (7 8 9 1 2 3 4 5 6)

l  → (7 8 9 1 2 3 4 5 6)

(rotate l -3)  → (1 2 3 4 5 6 7 8 9)

(set 'str "newLISP")

(rotate str)     → "PnewLIS"
(rotate str 3)   → "LISPnew"
(rotate str -4)  → "newLISP"
------------------------------------

When working on a string, `rotate` works on byte boundaries rather than
character boundaries.

function::round[]

*syntax:* (round _number_ [_int-digits_])

Rounds the number in _number_ to the number of digits given in
_int-digits_. When decimals are being rounded, _int-digits_ is negative.
It is positive when the integer part of a number is being rounded.

If _int-digits_ is omitted, the function rounds to `0` decimal digits.

[source,newlisp]
----------------------------
(round 123.49 2)    → 100
(round 123.49 1)    → 120
(round 123.49 0)    → 123
(round 123.49)      → 123
(round 123.49 -1)   → 123.5
(round 123.49 -2)   → 123.49
----------------------------

Note that rounding for display purposes is better accomplished using
link:#format[format].

function::save[]

*syntax:* (save _str-file_) +
*syntax:* (save _str-file_ _sym-1_ [_sym-2_ ... ])

In the first syntax, the `save` function writes the contents of the
newLISP workspace (in textual form) to the file _str-file_. `save` is
the inverse function of `load`. Using `load` on files created with
`save` causes newLISP to return to the same state as when `save` was
originally invoked. System symbols starting with the `$` character
(e.g., `$0` from regular expressions or `$main-args` from the
command-line), symbols of built-in functions and symbols containing
`nil` are not saved.

In the second syntax, symbols can be supplied as arguments. If _sym-n_
is supplied, only the definition of that symbol is saved. If _sym-n_
evaluates to a context, all symbols in that context are saved. More than
one symbol can be specified, and symbols and context symbols can be
mixed. When contexts are saved, system variables and symbols starting
with the `$` character are not saved. Specifying system symbols
explicitly causes them to be saved.

Each symbol is saved by means of a link:#set[set] statement or—if the
symbol contains a lambda or lambda-macro function—by means of
link:#define[define] or link:#define-macro[define-macro] statements.

`save` returns `true` on completion.

[source,newlisp]
---------------------------------------------------------------
(save "save.lsp")

(save "/home/myself/myfunc.LSP" 'my-func)
(save "file:///home/myself/myfunc.LSP" 'my-func)

(save "http://asite.com:8080//home/myself/myfunc.LSP" 'my-func)

(save "mycontext.lsp" 'mycontext)

;; multiple args
(save "stuff.lsp" 'aContext 'myFunc '$main-args 'Acontext)
---------------------------------------------------------------

Because all context symbols are part of the context `MAIN`, saving
`MAIN` saves all contexts.

Saving to a URL will cause an HTTP PUT request to be sent to the URL. In
this mode, `save` can also be used to push program source to remote
newLISP server nodes. Note that a double backslash is required when path
names are specified relative to the root directory. `save` in `HTTP`
mode will observe a 60-second timeout.

Symbols made using link:#sym[sym] that are incompatible with the normal
syntax rules for symbols are serialized using a link:#sym[sym] statement
instead of a link:#set[set] statement.

`save` serializes contexts and symbols as if the current context is
`MAIN`. Regardless of the current context, `save` will always generate
the same output.

See also the functions link:#load[load] (the inverse operation of
`save`) and link:#source[source], which saves symbols and contexts to a
string instead of a file.

function::search[]

*syntax:* (search _int-file_ _str-search_ [_bool-flag_ [_int-options_]])

Searches a file specified by its handle in _int-file_ for a string in
_str-search_. _int-file_ can be obtained from a previous
link:#open[open] file. After the search, the file pointer is positioned
at the beginning or the end of the searched string or at the end of the
file if nothing is found.

By default, the file pointer is positioned at the beginning of the
searched string. If _bool-flag_ evaluates to `true`, then the file
pointer is positioned at the end of the searched string.

In _int-options_, the options flags can be specified to perform a PCRE
regular expression search. See the function link:#regex[regex] for
details. If _int-options_ is not specified a faster, plain string search
is performed. `search` returns the new file position or `nil` if nothing
is found.

When using the regular expression options flag, patterns found are
stored in the system variables `$0` to `$15`.

[source,newlisp]
--------------------------------------------------------
(set 'file (open "init.lsp" "read"))
(search file "define")
(print (read-line file) "\n")
(close file)

(set 'file (open "program.c" "r"))
(while (search file "#define (.*)" true 0) (println $1))
(close file)
--------------------------------------------------------

The file `init.lsp` is opened and searched for the string `define` and
the line in which the string occurs is printed.

The second example looks for all lines in the file `program.c` which
start with the string `#define` and prints the rest of the line after
the string "#define ".

For other functions using regular expressions, see
link:#directory[directory], link:#find[find], link:#find-all[find-all],
link:#parse[parse], link:#regex[regex], and link:#replace[replace].

function::seed[]

*syntax:* (seed _int-seed_)

Seeds the internal random generator that generates numbers for
link:#amb[amb], link:#normal[normal], link:#rand[rand], and
link:#random[random] with the number specified in _int-seed_. Note that
the random generator used in newLISP is the C-library function _rand()_.
All randomizing functions in newLISP are based on this function.

Note that the maximum value for _int-seed_ is limited to 16 or 32 bits,
depending on the operating system used. Internally, only the 32 least
significant bits are passed to the random seed function of the OS.

[source,newlisp]
--------------------
(seed 12345)

(seed (time-of-day))
--------------------

After using `seed` with the same number, the random generator starts the
same sequence of numbers. This facilitates debugging when randomized
data are involved. Using `seed`, the same random sequences can be
generated over and over again.

The second example is useful for guaranteeing a different seed any time
the program starts.

function::self[]

*syntax:* (self [_int-index_ ... ])

The function `self` accesses the target object of a FOOP method. One or
more _int-index_ are used to access the object members.

Objects referenced with `self` are mutable:

[source,newlisp]
-----------------------------------------------
(new Class 'Circle)

(define (Circle:move dx dy)
    (inc (self 1) dx)
    (inc (self 2) dy))

(set 'aCircle (Circle 1 2 3))
(:move aCircle 10 20)

aCircle → (Circle 11 22 3)

; objects can be anonymous
(set 'circles '((Circle 1 2 3) (Circle 4 5 6)))

(:move (circles 0) 10 20)
(:move (circles 1) 10 20)

circles → ((Circle 11 22 3) (Circle 14 25 6))
-----------------------------------------------

See also the chapter about programming with FOOP: link:#foop[Functional
object-oriented programming in newLISP]

function::seek[]

*syntax:* (seek _int-file_ [_int-position_])

Sets the file pointer to the new position _int-position_ in the file
specified by _int-file_.The new position is expressed as an offset from
the beginning of the file, `0` (zero) meaning the beginning of the file.
If no _int-position_ is specified, `seek` returns the current position
in the file. If _int-file_ is `0` (zero), on BSD, `seek` will return the
number of characters printed to STDOUT, and on Linux and Win32, it will
return `-1`. On failure, `seek` returns `nil`. When _int-position_ is
set to `-1`, `seek` sets the file pointer to the end of the file.

`seek` can set the file position past the current end of the file.
Subsequent writing to this position will extend the file and fill unused
positions with zero's. The blocks of zeros are not actually allocated on
disk, so the file takes up less space and is called a _sparse file_.

[source,newlisp]
-----------------------------------------
(set 'file (open "myfile" "read"))  → 5
(seek file 100)                     → 100
(seek file)                         → 100

(open "newlisp_manual.html" "read")
(seek file -1)  ; seek to EOF
→ 593816

(set 'fle (open "large-file" "read")
(seek file 30000000000)  → 30000000000
-----------------------------------------

newLISP supports file position numbers up to 9,223,372,036,854,775,807.

function::select[utf8]

*syntax:* (select _list_ _list-selection_) +
*syntax:* (select _list_ [_int-index_i_ ... ]) +
*syntax:* (select _string_ _list-selection_) +
*syntax:* (select _string_ [_int-index_i_ ... ])

In the first two forms, `select` picks one or more elements from _list_
using one or more indices specified in _list-selection_ or the
_int-index_i_.

[source,newlisp]
----------------------------------------
(set 'lst '(a b c d e f g))

(select lst '(0 3 2 5 3))  → (a d c f d)

(select lst '(-2 -1 0))  → (f g a)

(select lst -2 -1 0)  → (f g a)
----------------------------------------

In the second two forms, `select` picks one or more characters from
_string_ using one or more indices specified in _list-selection_ or the
_int-index_i_.

[source,newlisp]
------------------------------------
(set 'str "abcdefg")

(select str '(0 3 2 5 3))  → "adcfd"

(select str '(-2 -1 0))  → "fga"

(select str -2 -1 0)  → "fga"
------------------------------------

Selected elements can be repeated and do not have to appear in order,
although this speeds up processing. The order in _list-selection_ or
_int-index_i_ can be changed to rearrange elements.

function::semaphore[]

*syntax:* (semaphore) +
*syntax:* (semaphore _int-id_) +
*syntax:* (semaphore _int-id_ _int-wait_) +
*syntax:* (semaphore _int-id_ _int-signal_) +
*syntax:* (semaphore _int-id_ _0_)

A semaphore is an interprocess synchronization object that maintains a
count between `0` (zero) and some maximum value. Useful in controlling
access to a shared resource, a semaphore is set to signaled when its
count is greater than zero and to non-signaled when its count is zero.

A semaphore is created using the first syntax. This returns the
semaphore ID, an integer used subsequently as _int-id_ when the
_semaphore_ function is called. Initially, the semaphore has a value of
zero, which represents the non-signaled state.

If calling `semaphore` with a negative value in _int-wait_ causes it to
be decremented below zero, the function call will block until another
process signals the semaphore with a positive value in _int-signal_.
Calls to the semaphore with _int-wait_ or _int-signal_ effectively try
to increment or decrement the semaphore value by a positive or negative
value specified in _int-signal_ or _int-wait_. Because the value of a
semaphore must never fall below zero, the function call will block when
this is attempted (i.e., a semaphore with a value of zero will block
until another process increases the value with a positive _int-signal_).

The second syntax is used to inquire about the value of a semaphore by
calling `semaphore` with the _int-id_ only. This form is not available
on Win32.

Supplying `0` (zero) as the last argument will release system resources
for the semaphore, which then becomes unavailable. Any pending waits on
this semaphore in other child processes will be released.

On Win32, only parent and child processes can share a semaphore. On
Linux/Unix, independent processes can share a semaphore.

On failure the `semaphore` function returns `nil`.
link:#sys-error[sys-error] can be used to retrieve the error number and
text from the underlying operating system.

The following code examples summarize the different syntax forms:

[source,newlisp]
------------------------------------------------------------------------------
;; init semaphores
(semaphore)

;; assign a semaphore to sid
(set 'sid (semaphore))

;; inquire the state of a semaphore (not on Win32)
(semaphore sid)

;; put sid semaphore in wait state (-1)
(semaphore sid -1)

;; run sid semaphore previously put in wait (always 1)
(semaphore sid 1)

;; run sid semaphore with X times a skip (backward or forward) on the function
(semaphore sid X)

;; release sid semaphore system-wide (always 0)
(semaphore sid 0)
------------------------------------------------------------------------------

The following example shows semaphores controlling a child process:

[source,newlisp]
-------------------------------------------------------
;; counter process output in bold

(define (counter n)
    (println "counter started")
    (dotimes (x n)
        (semaphore sid -1)
        (println x)))

;; hit extra <enter> to make the prompt come back
;; after output to the console from the counter process

> (set 'sid (semaphore))

> (semaphore sid)
0

> (fork (counter 100))

counter started
> (semaphore sid 1)
0
> (semaphore sid 3)
1
2
3
> (semaphore sid 2)
4

5
> _
-------------------------------------------------------

After the semaphore is acquired in `sid`, it has a value of `0` (the
non-signaled state). When starting the process `counter`, the semaphore
will block after the initial start message and will wait in the
semaphore call. The `-1` is trying to decrement the semaphore, which is
not possible because its value is already zero. In the interactive, main
parent process, the semaphore is signaled by raising its value by `1`.
This unblocks the semaphore call in the `counter` process, which can now
decrement the semaphore from `1` to `0` and execute the `print`
statement. When the semaphore call is reached again, it will block
because the semaphore is already in the wait (`0`) state.

Subsequent calls to `semaphore` with numbers greater than `1` give the
`counter` process an opportunity to decrement the semaphore several
times before blocking.

More than one process can participate in controlling the semaphore, just
as more than one semaphore can be created. The maximum number of
semaphores is controlled by a system-wide kernel setting on Unix-like
operating systems.

Use the link:#fork[fork] function to start a new process and the
link:#share[share] function to share information between processes. For
a more comprehensive example of using `semaphore` to synchronize
processes, see the file `prodcons.lsp` example in the `examples`
directory in the source distribution, as well as the examples and
modules distributed with newLISP.

function::send[]

*syntax:* (send _int-pid_ _exp_) +
*syntax:* (send)

The `send` function enables communication between parent and child
processes started with link:#spawn[spawn]. Parent processes can send and
receive messages to and from their child processes and child processes
can send and receive messages to and from their parent process. A proxy
technique – shown further down – is employed to communicate between
child process peers. `send` and link:#receive[receive] do not require
locks or semaphores. They work on dual send and receive message queues.

Processes started using link:#fork[fork] or link:#process[process] can
not use `send` and `receive` message functions. Instead they should use
either link:#share[share] with link:#semaphore[semaphore] or
link:#pipe[pipe] to communicate.

The `send` function is not available on Win32.

In the first syntax `send` is used to send a message from a parent to a
child process or a child to a parent process.

The second syntax is only used by parent processes to get a list of all
child processes ready to accept message from the parent in their receive
queues. If a child's receive queue is full, it will not be part of the
list returned by the `(send)` statement.

The content of a message may be any newLISP expression either atomic or
list expressions: boolean constants `nil` and `true`, integers, floating
point numbers or strings, or any list expression in valid newLISP
syntax. The size of a message is unlimited.

The _exp_ parameter specifies the data to be sent to the recipient in
_int-pid_. The recipient can be either a spawned child process of the
current process or the parent process. If a message queue is full, it
can be read from the receiving end, but a `send` issued on the other
side of the queue will fail and return `nil`.

[source,newlisp]
---------------------------------------------
; child process dispatching message to parent

(set 'ppid (sys-info -4)) ; get parent pid

(send ppid "hello") ; send message
---------------------------------------------

The targeted recipient of the message is the parent process:

[source,newlisp]
---------------------------------------------
; parent process receiving message from child

(receive child-pid msg) → true
msg                     → "hello"
---------------------------------------------

When the `send` queue is full, `send` will return `nil` until enough
message content is read on the receiving side of the queue and the queue
is ready to accept new messages from `send` statements.

Using the link:#until[until] looping function, the message statements
can be repeated until they return a value not `nil`. This way,
non-blocking `send` and `receive` can be made blocking until they
succeed:

[source,newlisp]
------------------------------------------------------------
; blocking sender
(until (send pid msg)) ; true after message is queued up

; blocking receiver
(until (receive pid msg)) ; true after message could be read
------------------------------------------------------------

The sender statement blocks until the message could be deposited in the
recipients queue.

The `receive` statement blocks until a new message can be fetched from
the queue.

As the `until` statements in this example lack body expressions, the
last value of the evaluated conditional expression is the return value
of the `until` loop.

Blocking message exchange
^^^^^^^^^^^^^^^^^^^^^^^^^

The following code shows how a recipient can listen for incoming
messages, and in turn how a sender can retry to deposit a message into a
queue. The example shows 5 child processes constantly delivering status
data to a parent process which will display the data. After three data
sets have been read, the parent will abort all child processes and exit:

[source,newlisp]
-----------------------------------------------------------
#!/usr/bin/newlisp

; child process transmits random numbers
(define (child-process)
    (set 'ppid (sys-info -4)) ; get parent pid
    (while true
        (until (send ppid (rand 100))))
)

; parent starts 5  child processes, listens and displays
; the true flag is specified to enable send/receive

(dotimes (i 5) (spawn 'result (child-process) true))

(for (i 1 3)
    (dolist (cpid (sync)) ; iterate thru pending child PIDs
        (until (receive cpid msg))
        (print "pid:" cpid "->" (format "%-2d  " msg)))
    (println)
)

(abort) ; cancel child-processes
(exit)
-----------------------------------------------------------

Running above example produces the following output:

-------------------------------------------------------------------------
pid:53181->47  pid:53180->61  pid:53179->75  pid:53178->39  pid:53177->3
pid:53181->59  pid:53180->12  pid:53179->20  pid:53178->77  pid:53177->47
pid:53181->6   pid:53180->56  pid:53179->96  pid:53178->78  pid:53177->18
-------------------------------------------------------------------------

The `(sync)` expression returns a list of all child PIDs, and
`(until (receive cpid msg))` is used to force a wait until status
messages are recived for each of the child processes.

A timeout mechanism could be part of an `until` or `while` loop to stop
waiting after certain time has expired.

The examples show messages flowing from a child processes to a parent
process, in the same fashion messages could flow into the other
direction from parent to child processes. In that case the parent
process would use `(send)` to obtain a list of child processes with
place in their message queues.

Messages containing code for evaluation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The most powerful feature of the message functions is the ability to
send any newLISP expression, which then can be evaluated by the
recipient. The recipient uses link:#eval[eval] to evaluate the received
expression. Symbols contained in the expression are evaluated in the
receivers environment.

The following example shows how a parent process acts like a message
proxy. The parent receives messages from a child process A and routes
them to a second child process with ID B. In effect this implements
messages between child process peers. The implementation relies on the
fact that the recipient can evaluate expressions contained in messages
received. These expressions can be any valid newLISP statements:

[source,newlisp]
---------------------------------------------------------------------
#!/usr/bin/newlisp

; sender child process of the message
(set 'A (spawn 'result
    (begin
        (dotimes (i 3)
            (set 'ppid (sys-info -4))
            /* the statement in msg will be evaluated in the proxy */
            (set 'msg '(until (send B (string "greetings from " A))))
            (until (send ppid msg)))
        (until (send ppid '(begin
            (sleep 100) ; make sure all else is printed
            (println "parent exiting ...\n")
            (set 'finished true))))) true))

; receiver child process of the message
(set 'B (spawn 'result
    (begin
        (set 'ppid (sys-info -4))
        (while true
            (until (receive ppid msg))
            (println msg)
            (unless (= msg (string "greetings from " A))
                (println "ERROR in proxy message: " msg)))) true))

(until finished (if (receive A msg) (eval msg))) ; proxy loop

(abort)
(exit)
---------------------------------------------------------------------

Child process `A` sends three messages to `B`. As this cannot be done
directly `A` sends `send` statements to the parent for evaluation. The
statement:

[source,newlisp]
------------------------------------------------
(until (send pidB (string "greetings from " A)))
------------------------------------------------

will be evaluated in the environment of the parent process. Even so the
variables `A` and `B` are bound to `nil` in the sender process `A`, in
the parent process they will be bound to the correct process ID numbers.

After sending the three messages, the statement:

[source,newlisp]
--------------------
(set 'finished true)
--------------------

is sent to the parent process. Once evaluated, it will cause the `until`
loop to finish.

For more details on `send` and `receive` and more examples see the
http://www.newlisp.org/CodePatterns.html[Code Patterns] document.

function::sequence[]

*syntax:* (sequence _num-start_ _num-end_ [_num-step_])

Generates a sequence of numbers from _num-start_ to _num-end_ with an
optional step size of _num-step_. When _num-step_ is omitted, the value
`1` (one) is assumed. The generated numbers are of type integer (when no
optional step size is specified) or floating point (when the optional
step size is present).

[source,newlisp]
-------------------------------------------------
(sequence 10 5)     → (10 9 8 7 6 5)
(sequence 0 1 0.2)  → (0 0.2 0.4 0.6 0.8 1)
(sequence 2 0 0.3)  → (2 1.7 1.4 1.1 0.8 0.5 0.2)
-------------------------------------------------

Note that the step size must be a positive number, even if sequencing
from a higher to a lower number.

Use the link:#series[series] function to generate geometric sequences.

function::series[]

*syntax:* (series _num-start_ _num-factor_ _num-count_) +
*syntax:* (series _exp-start_ _func_ _num-count_)

In the first syntax, `series` creates a geometric sequence with
_num-count_ elements starting with the element in _num-start_. Each
subsequent element is multiplied by _num-factor_. The generated numbers
are always floating point numbers.

When _num-count_ is less than `1`, then `series` returns an empty list.

[source,newlisp]
------------------------------------------------------
(series 2 2 5)     → (2 4 8 16 32)
(series 1 1.2 6)   → (1 1.2 1.44 1.728 2.0736 2.48832)
(series 10 0.9 4)  → (10 9 8.1 7.29)
(series 0 0 10)    → (0 0 0 0 0 0 0 0 0 0)
(series 99 1 5)    → (99 99 99 99 99)
------------------------------------------------------

In the second syntax, `series` uses a function specified in _func_ to
transform the previous expression in to the next expression:

[source,newlisp]
---------------------------------------------------------------------
; embed the function Phi: f(x) = 1 / (1 + x)
; see also http://en.wikipedia.org/wiki/Golden_ratio

(series 1 (fn (x) (div (add 1 x))) 20)  →

(1 0.5 0.6666666 0.6 0.625 0.6153846 0.619047 0.6176470 0.6181818
 0.6179775 0.6180555 0.6180257 0.6180371 0.6180327 0.6180344
 0.6180338 0.6180340 0.6180339 0.6180339 0.6180339)

; pre-define the function

(define (oscillate x)
  (if (< x)
    (+ (- x) 1)
    (- (+ x 1)))
)

(series 1 oscillate 20)  →

(1 -2 3 -4 5 -6 7 -8 9 -10 11 -12 13 -14 15 -16 17 -18 19 -20)

; any data type is accepted as a start expression

(series "a" (fn (c) (char (inc (char c)))) 5) → ("a" "b" "c" "d" "e")

; dependency of the two previous values in this fibonacci generator

(let (x 1) (series x (fn (y) (+ x (swap y x))) 10))  →

(1 2 3 5 8 13 21 34 55 89)
---------------------------------------------------------------------

The first example shows a series converging to the _golden ratio, φ_
(for any starting value). The second example shows how _func_ can be
defined previously for better readability of the `series` statement.

The `series` function also updates the internal list `$idx` index value,
which can be used inside _func_.

Use the link:#sequence[sequence] function to generate arithmetic
sequences.

function::set[!]

*syntax:* (set _sym-1_ _exp-1_ [_sym-2_ _exp-2_ ... ])

Evaluates both arguments and then assigns the result of _exp_ to the
symbol found in _sym_. The `set` expression returns the result of the
assignment. The assignment is performed by copying the contents of the
right side into the symbol. The old contents of the symbol are deleted.
An error message results when trying to change the contents of the
symbols `nil`, `true`, or a context symbol. `set` can take multiple
argument pairs.

[source,newlisp]
------------------------------------------------------
(set 'x 123)     → 123
(set 'x 'y)      → y
(set x "hello")  → "hello"

y  → "hello"

(set 'alist '(1 2 3))  → (1 2 3)

(set 'x 1 'y "hello")  → "hello"  ; multiple arguments

x  → 1
y  → "hello"
------------------------------------------------------

The symbol for assignment could be the result from another newLISP
expression:

[source,newlisp]
------------------------------
(set 'lst '(x y z))  → (x y z)

(set (first lst) 123)  → 123

x  → 123
------------------------------

Symbols can be set to lambda or lambda-macro expressions. This operation
is equivalent to using link:#define[define] or
link:#define-macro[define-macro].

[source,newlisp]
----------------------------------
(set 'double (lambda (x) (+ x x)))
→ (lambda (x) (+ x x))
----------------------------------

is equivalent to:

[source,newlisp]
---------------------------
(define (double x) (+ x x))
→ (lambda (x) (+ x x))
---------------------------

is equivalent to:

[source,newlisp]
------------------------------------
(define double (lambda (x) (+ x x)))
→ (lambda (x) (+ x x))
------------------------------------

Use the link:#constant[constant] function (which works like `set`) to
protect the symbol from subsequent alteration. Using the
link:#setq[setq] or link:#setf[setf] function eliminates the need to
quote the variable symbol.

function::set-locale[]

*syntax:* (set-locale [_str-locale_ [_int-category_]])

Reports or switches to a different locale on your operating system or
platform. When used without arguments, _set-locale_ reports the current
locale being used. When _str-locale_ is specified, _set-locale_ switches
to the locale with all category options turned on (`LC_ALL`). Placing an
empty string in _str-locale_ switches to the default locale used on the
current platform.

`set-locale` returns either the current locale string and decimal point
string in a list or `nil` if the requested change could not be
performed.

[source,newlisp]
--------------------------------------------------------
; report current locale

(set-locale)

; set default locale of your platform and country
; return value shown when executing on German MS-Windows

(set-locale "")    → ("German_Germany.1252" ",")
(add 1,234 1,234)  → 2,468
--------------------------------------------------------

By default, newLISP – if not enabled for UTF-8 – starts up with the
POSIX C default locale. This guarantees that newLISP's behavior will be
identical on any platform locale. On UTF-8 enabled versions of newLISP
the locale of the current platform is chosen.

[source,newlisp]
----------------------------------
; after non-UTF-8 newLISP start up

(set-locale)  → ("C" ".")
----------------------------------

In _int-category_, integer numbers may be specified as _category
options_ for fine-tuning certain aspects of the locale, such as number
display, date display, and so forth. The numbers used vary from
system-to-system. The options valid on your platform can be found in the
C include file `locale.h`. This file defines constants like
`LC_ALL, LC_NUMERIC,` and `LC_MONETARY`. When `set-locale` is used
without the option number, it assumes the `LC_ALL` option, which turns
on all options for that locale.

Note that the locale also controls the decimal separator in numbers. The
default C locale uses the decimal dot, but most others use a decimal
comma.

Note that using `set-locale` does not change the behavior of regular
expressions in newLISP. To localize the behavior of PCRE (Perl
Compatible Regular Expressions), newLISP must be compiled with different
character tables. See the file, LOCALIZATION, in the newLISP source
distribution for details.

See also the chapter link:#switching[Switching the locale].

function::set-ref[!]

*syntax:* (set-ref _exp-key_ _list_ _exp-replacement_ [_func-compare_])

Searches for _exp-key_ in _list_ and replaces the found element with
_exp-replacement_. The _list_ can be nested. The system variables `$it`
contains the expression found and can be used in _exp-replacement_. The
function returns the new modified _list_.

[source,newlisp]
--------------------------------------------------------------------------
(set 'data '(fruits (apples 123 44) (oranges 1 5 3)))

(set-ref 'apples data 'Apples)  → (fruits (Apples 123 44) (oranges 1 5 3))

data → (fruits (Apples 123 44) (oranges 1 5 3)))
--------------------------------------------------------------------------

`data` could be the context identifier of a default function for passing
lists by reference:

[source,newlisp]
-------------------------------------------------------------------------
(set 'db:db '(fruits (apples 123 44) (oranges 1 5 3)))

(define (update ct key value)
    (set-ref key ct value))

(update db 'apples 'Apples)    → (fruits (Apples 123 44) (oranges 1 5 3))
(update db 'oranges 'Oranges)  → (fruits (Apples 123 44) (Oranges 1 5 3))

db:db → (fruits (Apples 123 44) (Oranges 1 5 3))
-------------------------------------------------------------------------

For examples on how to use _func-compare_ see
link:#set-ref-all[set-ref-all]

For changing all occurrences of an element in a list use
link:#set-ref-all[set-ref-all].

function::set-ref-all[!]

*syntax:* (set-ref-all _exp-key_ _list_ _exp-replacement_ [_func-compare_])

Searches for _exp-key_ in _list_ and replaces each instance of the found
element with _exp-replacement_. The _list_ can be nested. The system
variable `$it` contains the expression found and can be used in
_exp-replacement_. The function returns the new modified _list_.

[source,newlisp]
------------------------------------------------------------------------------------------
(set 'data '((monday (apples 20 30) (oranges 2 4 9)) (tuesday (apples 5) (oranges 32 1))))

(set-ref-all 'apples data "Apples")
 → ((monday ("Apples" 20 30) (oranges 2 4 9)) (tuesday ("Apples" 5) (oranges 32 1)))
------------------------------------------------------------------------------------------

Using the default functor in the `(list key)` pattern allows the list to
be passed by reference to a user-defined function containing a
`set-ref-all` statement. This would result in less memory usage and
higher speeds in when doing replacements in large lists:

[source,newlisp]
-------------------------------------------------------------------------------------------
(set 'db:db '((monday (apples 20 30) (oranges 2 4 9)) (tuesday (apples 5) (oranges 32 1))))

(define (foo ctx)
    (set-ref-all 'apples ctx "Apples")
)

(foo db)
 → ((monday ("Apples" 20 30) (oranges 2 4 9)) (tuesday ("Apples" 5) (oranges 32 1)))
-------------------------------------------------------------------------------------------

When evaluating `(foo db)`, the list in `db:db` will be passed by
reference and `set-ref-all` will make the changes on the original, not
on a copy of `db:db`.

Like with link:#find[find], link:#replace[replace], link:#ref[ref] and
link:#ref-all[ref-all], complex searches can be expressed using
link:#match[match] or link:#unify[unify] in _func-compare_:

[source,newlisp]
------------------------------------------------------------------------------------------
(set 'data '((monday (apples 20 30) (oranges 2 4 9)) (tuesday (apples 5) (oranges 32 1))))

(set-ref-all '(oranges *) data (list (first $it) (apply + (rest $it))) match)
    → ( ... (oranges 15) ... (oranges 33) ... )
------------------------------------------------------------------------------------------

The example sums all numbers found in records starting with the symbol
`oranges`. The found items appear in `$it`

See also link:#set-ref[set-ref] which replaces only the first element
found.

function::setq,setf[!]

*syntax:* (setq _place-1_ _exp-1_ [_place-2_ _exp-2_ ... ])

`setq` and `setf` work alike in newLISP and set the contents of a
symbol, list, array or string or of a list, array or string place
reference. Like link:#set[set], `setq` and `setf` can take multiple
argument pairs. Although both `setq` and `setf` point to the same
built-in function internally, throughout this manual `setq` is used when
setting a symbol reference and `setf` is used when setting list or array
references.

[source,newlisp]
----------------------------------------------------------
(setq x 123)  → 123

; multiple arguments

(setq x 1 y 2 z 3)  → 3

x  → 1
y  → 2
z  → 3

; with nth or implicit indices
(setq L '(a b (c d) e f g))

(setf (L 1) 'B)      → B
; or the same
(setf (nth 1 L) 'B)
L                    → (a B (c d) e f g)

(setf (L 2 0) 'C)    → C
L                    → (a B (C d) e f g)

(setf (L 2) 'X)
L                    → (A B X e f g)

; with assoc
(setq L '((a 1) (b 2)))
(setf (assoc 'b L) '(b 3)) → (b 3)
L                          → ((a 1) (b 3))

; with lookup
(setf (lookup 'b L) 30) → 30
L                       → ((a 1) (b 30))

; several list accessors can be nested
(setq L '((a 1) (b 2)))

(push 'b (setf (assoc 'b l) '(b 4))) 'b) → b
L                                        →((a 1) (b b 4)))

; on strings
(set 's "NewISP")

(setf (s 0) "n") → "n"
s → "newISP"

(setf (s 3) "LI") → "LI"
s → "newLISP"
----------------------------------------------------------

Often the new value set is dependent on the old value. `setf` can use
the anaphoric system variable `$it` to refer to the old value inside the
`setf` expression:

[source,newlisp]
---------------------------------------------------
(setq L '((apples 4) (oranges 1)))

(setf (L 1 1) (+ $it 1)) → 2

L                        → ((apples 4) (oranges 2))

(set 's "NewLISP")

(setf (s 0) (lower-case $it)) → "n")

s → "newLISP"
---------------------------------------------------

function::sgn[]

*syntax:* (sgn _num_) +
*syntax:* (sgn _num_ _exp-1_ [_exp-2_ [_exp-3_]])

In the first syntax, the `sgn` function is a logical function that
extracts the sign of a real number according to the following rules:

*_x > `0` : sgn(x) = 1 +
x < `0` : sgn(x) = -1 +
x = `0` : sgn(x) = `0`_*

[source,newlisp]
----------------
(sgn -3.5)  → -1
(sgn 0)     → 0
(sgn 123)   → 1
----------------

In the second syntax, the result of evaluating one of the optional
expressions _exp-1_, _exp-2_, or _exp-3_ is returned, instead of `-1`,
`0`, or `1`. If _exp-n_ is missing for the case triggered, then `nil` is
returned.

[source,newlisp]
-----------------------------------------------------------------
(sgn x -1 0 1)         ; works like (sgn x)
(sgn x -1 1 1)         ; -1 for negative x all others 1
(sgn x nil true true)  ; nil for negative else true
(sgn x (abs x) 0)      ; (abs x) for x < 0, 0 for x = 0, else nil
-----------------------------------------------------------------

Any expression or constant can be used for _exp-1_, _exp-2_, or _exp-3_.

function::share[]

*syntax:* (share) +
*syntax:* (share _int-address-or-handle_) +
*syntax:* (share _int-address-or-handle_ _exp-value_) +
*syntax:* (share _nil_ _int-address_)

Accesses shared memory for communicating between several newLISP
processes. When called without arguments, `share` requests a page of
shared memory from the operating system. This returns a memory address
on Linux/Unix and a handle on Win32, which can then be assigned to a
variable for later reference. This function is not available on OS/2.

To set the contents of shared memory, use the third syntax of `share`.
Supply a shared memory address on Linux/Unix or a handle on Win32 in
_int-address-or-handle_, along with an integer, float, string expression
or any other expression (since v.10.1.0) supplied in _exp-value_. Using
this syntax, the value supplied in _exp-value_ is also the return value.

To access the contents of shared memory, use the second syntax of
`share`, supplying only the shared memory address or handle. The return
value will be any constant or expression (since v.10.1.0) written
previously into the memory. If the memory has not been previously set to
a value, `nil` will be returned.

Only available on Unix-like operating systems, the last syntax unmaps a
shared memory address. Note that using a shared address after unmapping
it will crash the system.

Memory can be shared between parent and child processes, but not between
independent processes.

Since v.10.1.0 size of share objects can exceed the shared memory
pagesize of the operating system. For objects bigger than the pagesize,
newLISP internally uses files for sharing. This requires a `/tmp`
directory on Unix-like operating system and a `temp` directory in the
root of the current disk drive on Win32 systems. On Unix-like systems
this directory is present, on Win32 it may have to be created.

[source,newlisp]
--------------------------------------------------------
(set 'mem (share))

(share mem 123)  → 123
(share mem)      → 123

(share mem "hello world") → "hello world"
(share mem)               → "hello world"

(share mem true)  → true
(share mem)       → true

(share mem '(+ 1 2 3 4))  → (+ 1 2 3 4)
(share mem)               → (+ 1 2 3 4)

; expressions received can be evaluated (since v.10.1.0)
(eval (share mem))        → 10

(share nil mem)   → true  ; unmap only on Unix
--------------------------------------------------------

Expression read from shared memory and evaluated, will be evaluated in
the recipient's process environment.

Note that shared memory access between different processes should be
synchronized using a link:#semaphore[semaphore]. Simultaneous access to
shared memory can crash the running process.

For a more comprehensive example of using shared memory in a multi
process Linux/Unix application, see the file `example/prodcons.lsp` in
the newLISP source distribution.

function::signal[]

*syntax:* (signal _int-signal_ _sym-event-handler_ | _func-event-handler_) +
*syntax:* (signal _int-signal_ "ignore" | "default" | "reset") +
*syntax:* (signal _int-signal_)

Sets a user-defined handler in _sym-event-handler_ for a signal
specified in _int-signal_ or sets to a function expression in
_func-event-handler_.

A parameter following _int-signal_ is not evaluated.

If no signal handler is speified any of the string constants `"ignore"`,
`"default"` or `"reset"` can be specified in either lower or upper case
or simply using the the first letter of the option string. When signal
setup with any of these three options has been successfull `true` is
returned.

Using `"ignore"` will make newLISP ignore the signal. Using `"default"`
will set the handler to the default handler of the underlying platform
OS. The `"reset"` option will restore the handler to newLISP startup
state.

On startup, newLISP either specifies an empty newLISP handler or a
Ctrl-C handler for `SIGINT` and a `waitpipd(-1, 0, WNOHANG)` C-call for
`SIGCHLD`.

Different signals are available on different OS platforms and Linux/Unix
flavors. The numbers to specify in _int-signal_ also differ from
platform-to-platform. Valid values can normally be extracted from a file
found in `/usr/include/sys/signal.h` or `/usr/include/signal.h`.

Some signals make newLISP exit even after a user-defined handler has
been specified and executed (e.g., signal SIGKILL). This behavior may
also be different on different platforms.

[source,newlisp]
------------------------------------------------------------
(constant 'SIGINT 2)
(define (ctrlC-handler) (println "ctrl-C has been pressed"))

(signal SIGINT 'ctrlC-handler)

; now press ctrl-C
; the following line will appear
; this will only work in an interactive terminal window
; and will not work in the newLISP-GS editor

ctrl-C has been pressed

; reset tratment of signal 2 to startup conditions

(signal SIGINT "reset")
------------------------------------------------------------

On Win32, the above example would execute the handler before exiting
newLISP. On most Linux/Unix systems, newLISP would stay loaded and the
prompt would appear after hitting the [enter] key.

Instead of specifying a symbol containing the signal handler, a function
can be specified directly. The signal number is passed as a parameter:

[source,newlisp]
----------------------------------------------------------
(signal SIGINT exit)  → $signal-2

(signal SIGINT (fn (s) (println "signal " s " occurred")))
----------------------------------------------------------

Note that the signal SIGKILL (9 on most platforms) will always terminate
the application regardless of an existing signal handler.

The signal could have been sent from another shell on the same computer:

[source,sh]
-------------------
kill -s SIGINT 2035
-------------------

In this example, `2035` is the process ID of the running newLISP.

The signal could also have been sent from another newLISP application
using the function link:#destroy[destroy]:

[source,newlisp]
---------------------
(destroy 2035) → true
---------------------

If newLISP receives a signal while evaluating another function, it will
still accept the signal and the handler function will be executed:

[source,newlisp]
------------------------------------------------------------
(constant 'SIGINT 2)
(define (ctrlC-handler) (println "ctrl-C has been pressed"))

(signal SIGINT 'ctrlC-handler)
;; or
(signal SIGINT ctrlC-handler)

(while true (sleep 300) (println "busy"))

;; generates following output
busy
busy
busy
ctrl-C has been pressed
busy
busy
…
------------------------------------------------------------

Specifying only a signal number will return either the name of the
currently defined handler function or `nil`.

The user-defined signal handler can pass the signal number as a
parameter.

[source,newlisp]
--------------------------------------------------
(define (signal-handler sig)
    (println "received signal: " sig))

;; set all signals from 1 to 8 to the same handler
(for (s 1 8)
    (signal s 'signal-handler))
--------------------------------------------------

In this example, all signals from 1 to 8 are set to the same handler.

function::silent[]

*syntax:* (silent [_exp-1_ [_exp-2_ ... ]])

Evaluates one or more expressions in _exp-1_—. `silent` is similar to
link:#begin[begin], but it suppresses console output of the return value
and the following prompt. It is often used when communicating from a
remote application with newLISP (e.g., GUI front-ends or other
applications controlling newLISP), and the return value is of no
interest.

Silent mode is reset when returning to a prompt. This way, it can also
be used without arguments in a batch of expressions. When in interactive
mode, hit [enter] twice after a statement using `silent` to get the
prompt back.

[source,newlisp]
---------------------------------------------
(silent (my-func))  ; same as next

(silent) (my-func)  ; same effect as previous
---------------------------------------------

function::sin[]

*syntax:* (sin _num-radians_)

Calculates the sine function from _num-radians_ and returns the result.

[source,newlisp]
------------------------------------------
(sin 1)                     → 0.8414709838
(set 'pi (mul 2 (acos 0)))  → 3.141592654
(sin (div pi 2))            → 1
------------------------------------------

function::sinh[]

*syntax:* (sinh _num-radians_)

Calculates the hyperbolic sine of _num-radians_. The hyperbolic sine is
defined mathematically as: _(exp (x) - exp (-x)) / 2_. An overflow to
`inf` may occur if _num-radians_ is too large.

[source,newlisp]
------------------------------------------
(sinh 1)     → 1.175201194
(sinh 10)    → 11013.23287
(sinh 1000)  → inf
(sub (tanh 1) (div (sinh 1) (cosh 1))) → 0
------------------------------------------

function::sleep[]

*syntax:* (sleep _num-milliseconds_)

Gives up CPU time to other processes for the amount of milliseconds
specified in _num-milli-seconds_.

[source,newlisp]
----------------------------------------
(sleep 1000)  ; sleeps 1 second
(sleep 0.5)   ; sleeps 500 micro seconds
----------------------------------------

On some platforms, `sleep` is only available with a resolution of one
second. In this case, the parameter _int-milli-seconds_ will be rounded
to the nearest full second.

function::slice[]

*syntax:* (slice _list_ _int-index_ [_int-length_]) +
*syntax:* (slice _array_ _int-index_ [_int-length_]) +
*syntax:* (slice _str_ _int-index_ [_int-length_])

In the first form, `slice` copies a sublist from a _list_. The original
list is left unchanged. The sublist extracted starts at index
_int-index_ and has a length of _int-length_. If _int-length_ is
negative, `slice` will take the parameter as offset counting from the
end and copy up to that offset. If the parameter is omitted, `slice`
copies all of the elements to the end of the list.

See also link:#indexing[Indexing elements of strings and lists].

[source,newlisp]
---------------------------------------------------------
(slice '(a b c d e f) 3 2)   → (d e)
(slice '(a b c d e f) 2 -2)  → (c d)
(slice '(a b c d e f) 2)     → (c d e f)
(slice '(a b c d e f) -4 3)  → (c d e)

(set 'A (array 3 2 (sequence 1 6))) → ((1 2) (3 4) (5 6))
(slice A 1 2) → ((3 4) (5 6))
---------------------------------------------------------

In the second form, a part of the string in _str_ is extracted.
_int-index_ contains the start index and _int-length_ contains the
length of the substring. If _int-length_ is not specified, everything to
the end of the string is extracted. `slice` also works on string buffers
containing binary data like `0`'s (zeroes). It operates on byte
boundaries rather than character boundaries. See also
link:#indexing[Indexing elements of strings and lists].

Note that `slice` always works on single 8-bit byte boundaries for
offset and length numbers, even when running the UTF-8 enabled version
of newLISP.

[source,newlisp]
------------------------------------
(slice "Hello World" 6 2)  → "Wo"
(slice "Hello World" 0 5)  → "Hello"
(slice "Hello World" 6)    → "World"
(slice "newLISP" -4 2)     → "LI"
------------------------------------

Note that an _implicit slice_ is available for lists. See the chapter
link:#implicit_rest_slice[Implicit rest and slice].

Be aware that link:#slice[slice] always works on byte boundaries rather
than character boundaries in the UTF-8–enabled version of newLISP. As a
result, link:#slice[slice] can be used to manipulate binary content.

function::sort[!]

*syntax:* (sort _list_ [_func-compare_])

All members in _list_ are sorted in ascending order. Anything may be
sorted, regardless of the types. When members are themselves lists, each
list element is recursively compared. If two expressions of different
types are compared, the lower type is sorted before the higher type in
the following order:

[source,newlisp]
-------------------------------------------------------------
Atoms: nil, true, integer or float, string, symbol, primitive
Lists: quoted expression, list, lambda, lambda-macro
-------------------------------------------------------------

The sort is destructive, changing the order of the elements in the
original list. The return value of `sort` is a copy of the sorted list.

An optional comparison operator, user-defined function, or anonymous
function can be supplied. The functor or operator can be given with or
without a preceding quote.

[source,newlisp]
----------------------------------------------------
(sort '(v f r t h n m j))     → (f h j m n r t v)
(sort '((3 4) (2 1) (1 10)))  → ((1 10) (2 1) (3 4))
(sort '((3 4) "hi" 2.8 8 b))  → (2.8 8 "hi" b (3 4))

(set 's '(k a l s))
(sort s)  → (a k l s)

(sort '(v f r t h n m j) >) → (v t r n m j h f)

(sort s <)  → (a k l s)
(sort s >)  → (s l k a)
s           → (s l k a)

;; define a comparison function
(define (comp x y)
    (> (last x) (last y)))

(set 'db '((a 3) (g 2) (c 5)))

(sort db comp)  →  ((c 5) (a 3) (g 2))

;; use an anonymous function
(sort db (fn (x y) (> (last x) (last y))))
----------------------------------------------------

function::source[]

*syntax:* (source) +
*syntax:* (source _sym-1_ [_sym-2_ ... ])

Works almost identically to link:#save[save], except symbols and
contexts get serialized to a string instead of being written to a file.
Multiple variable symbols, definitions, and contexts can be specified.
If no argument is given, `source` serializes the entire newLISP
workspace. When context symbols are serialized, any symbols contained
within that context will be serialized, as well. Symbols containing
`nil` are not serialized. System symbols beginning with the `$` (dollar
sign) character are only serialized when mentioned explicitly.

Symbols not belonging to the current context are written out with their
context prefix.

[source,newlisp]
--------------------------------------------------------
(define (double x) (+ x x))

(source 'double)  → "(define (double x)\n  (+ x x))\n\n"
--------------------------------------------------------

As with link:#save[save], the formatting of line breaks and leading
spaces or tabs can be controlled using the
link:#pretty-print[pretty-print] function.

function::spawn[]

*syntax:* (spawn _sym_ _exp_ [true])

Launches the evaluation of _exp_ as a child process and immediately
returns. The symbol in _sym_ is quoted and receives the result of the
evaluation when the function link:#sync[sync] is executed. `spawn` is
used to start parallel evaluation of expressions in concurrent
processes. If newLISP is running on a multi-core CPU, the underlying
operating system will distribute spawned processes onto different cores,
thereby evaluating expressions in parallel and speeding up overall
processing.

The optional `true` parameter must be set if link:#send[send] or
link:#receive[receive] is used to communicated with the child process
spawned.

The function `spawn` is not available on Win32.

After successfully starting a child process, the `spawn` expression
returns the process id of the forked process. The following examples
shows how the calculation of a range of prime numbers can be split up in
four sub ranges to speed up the calculation of the whole range:

[source,newlisp]
----------------------------------------------------------
; calculate primes in a range
(define (primes from to)
  (local (plist)
      (for (i from to)
          (if (= 1 (length (factor i)))
              (push i plist -1)))
      plist))

; start child processes
(set 'start (time-of-day))

(spawn 'p1 (primes 1 1000000))
(spawn 'p2 (primes 1000001 2000000))
(spawn 'p3 (primes 2000001 3000000))
(spawn 'p4 (primes 3000001 4000000))

; wait for a maximum of 60 seconds for all tasks to finish
(sync 60000) ; returns true if all finished in time
; p1, p2, p3 and p4 now each contain a lists of primes

(println "time spawn: " (- (time-of-day) start))
(println "time simple: " (time  (primes 1 4000000)))

(exit)
----------------------------------------------------------

On a 1.83 Intel Core 2 Duo processor, the above example will finish
after about 13 seconds. Calculating all primes using
`(primes 1 4000000)` would take about 20 seconds.

The link:#sync[sync] function will wait for all child processes to
finish and receive the evaluation results in the symbols `p1` to `p4`.
When all results are collected, `sync` will stop waiting and return
`true`. When the time specified was insufficient , `sync` will return
`nil` and another `sync` statement could be given to further wait and
collect results. A short timeout time can be used to do other processing
during waiting:

[source,newlisp]
---------------------------------------------
(spawn 'p1 (primes 1 1000000))
(spawn 'p2 (primes 1000001 2000000))
(spawn 'p3 (primes 2000001 3000000))
(spawn 'p4 (primes 3000001 4000000))

; print a dot after each 2 seconds of waiting
(until (sync 2000) (println "."))
---------------------------------------------

`sync` when used without any parameters, will not wait but immediately
return a list of pending child processes. For the `primes` example, the
following `sync` expression could be used to watch the progress:

[source,newlisp]
------------------------------------------------------------------------
(spawn 'p1 (primes 1 1000000))
(spawn 'p2 (primes 1000001 2000000))
(spawn 'p3 (primes 2000001 3000000))
(spawn 'p4 (primes 3000001 4000000))

; show a list of pending process ids after each three-tenths of a second
(until (sync 300) (println (sync)))
------------------------------------------------------------------------

A parameter of `-1` tells `sync` to wait for a very long time (~ 1193
hours). A better solution would be to wait for a maximum time, then
link:#abort[abort] all pending child processes:

[source,newlisp]
------------------------------------------------
(spawn 'p1 (primes 1 1000000))
(spawn 'p2 (primes 1000001 2000000))
(spawn 'p3 (primes 2000001 3000000))
(spawn 'p4 (primes 3000001 4000000))

; wait for one minute, then abort and
; report unfinished PIDs

(if (not (sync 60000))
    (begin
        (println "aborting unfinished: " (sync))
        (abort))
    (println "all finished successfully")
)
------------------------------------------------

The three functions `spawn`, `sync` and `abort` are part of the
http://supertech.csail.mit.edu/cilk/[Cilk] API. The original
implementation also does sophisticated scheduling and allocation of
threaded tasks to multiple CPU cores. The newLISP implementation of the
Cilk API lets the operating system of the underlying platform handle
process management. Internally, the API is implemented using the Unix
libc functions `fork()`, `waitpid()` and `kill()`. Intercommunications
between processes and child processes is done using the link:#send[send]
and link:#receive[receive] functions.

`spawn` can be called recursively from spawned subtasks:

[source,newlisp]
------------------------------------
(define (fibo n)
  (local (f1 f2)
    (if(< n 2) 1
       (begin
          (spawn 'f1 (fibo (- n 1)))
          (spawn 'f2 (fibo (- n 2)))
          (sync 10000)
          (+ f1 f2)))))

(fibo 7)  → 21
------------------------------------

With `(fibo 7)` 41 processes will be generated. Although the above code
shows the working of the Cilk API in a recursive application, it would
not be practical, as the overhead required to spawn subtasks is much
higher than the time saved through parallelization.

Since version 10.1 a link:#send[send] and link:#receive[receive] message
functions are available for communications between parent and child
processes. Using these functions any data or expression of any size can
be transferred. Additionally messaged expressions can be evaluated in
the recipient's environment.

function::sqrt[]

*syntax:* (sqrt _num_)

Calculates the square root from the expression in _num_ and returns the
result.

[source,newlisp]
-----------------------
(sqrt 10)  → 3.16227766
(sqrt 25)  → 5
-----------------------

function::starts-with[]

*syntax:* (starts-with _str_ _str-key_ [_num-option_]) +
*syntax:* (starts-with _list_ [_exp_])

In the first version, `starts-with` checks if the string _str_ starts
with a key string in _str-key_ and returns `true` or `nil` depending on
the outcome.

If a regular expression number is specified in _num-option_, _str-key_
contains a regular expression pattern. See link:#regex[regex] for valid
_option_ numbers.

[source,newlisp]
---------------------------------------------------
(starts-with "this is useful" "this")        → true
(starts-with "this is useful" "THIS")        → nil

;; use regular expressions
(starts-with "this is useful" "THIS" 1)      → true
(starts-with "this is useful" "this|that" 0) → true
---------------------------------------------------

In the second version, `starts-with` checks to see if a list starts with
the list element in _exp_. `true` or `nil` is returned depending on
outcome.

[source,newlisp]
-----------------------------------------------
(starts-with '(1 2 3 4 5) 1)             → true
(starts-with '(a b c d e) 'b)            → nil
(starts-with '((+ 3 4) b c d) '(+ 3 4))  → true
-----------------------------------------------

See also the link:#ends-with[ends-with] function.

function::stats[]

*syntax:* (stats _list-vector_)

The functions calculates statistical values of central tendency and
dsitribution moments of values in _list-vector_. The following values
are returned by `stats` in a list:

[cols="1<,4<",width="30%",options="header",]
|==============================================
|name |description
|N |Number of values
|mean |Mean of values
|avdev |Average deviation from mean value
|sdev |Standard deviation (population estimate)
|var |Variance (population estimate)
|skew |Skew of distribution
|kurt |Kurtosis of distribution
|==============================================

[source,newlisp]
The following example uses the list output from the `stats` expression
as an argument for the link:#format[format] statement:

[source,newlisp]
-----------------------------------------------------
(set 'data '(90 100 130 150 180 200 220 300 350 400))

(println (format [text]
    N        = %5d
    mean     = %8.2f
    avdev    = %8.2f
    sdev     = %8.2f
    var      = %8.2f
    skew     = %8.2f
    kurt     = %8.2f
[/text] (stats data)))

; outputs the following

    N        =    10
    mean     =   212.00
    avdev    =    84.40
    sdev     =   106.12
    var      = 11262.22
    skew     =     0.49
    kurtosis =    -1.34
-----------------------------------------------------

function::string[]

*syntax:* (string _exp-1_ [_exp-2_ ... ])

Translates into a string anything that results from evaluating _exp-1_—.
If more than one expression is specified, the resulting strings are
concatenated.

[source,newlisp]
--------------------------------------
(string 'hello)          → "hello"
(string 1234)            → "1234"
(string '(+ 3 4))        → "(+ 3 4)"
(string (+ 3 4) 8)       → "78"
(string 'hello " " 123)  → "hello 123"
--------------------------------------

If a buffer passed to `string` contains `\000`, only the string up to
the first terminating zero will be copied:

[source,newlisp]
--------------------------------------------------
(set 'buff "ABC\000\000\000")  → "ABC\000\000\000"

(length buff)  → 6

(string buff)  → "ABC"

(length (string buff))  → 3
--------------------------------------------------

Use the link:#append[append] and link:#join[join] (allows the joining
string to be specified) functions to concatenate strings containing zero
bytes. Use the link:#source[source] function to convert a lambda
expression into its newLISP source string representation.

function::string?[]

*syntax:* (string? _exp_)

Evaluates _exp_ and tests to see if it is a string. Returns `true` or
`nil` depending on the result.

[source,newlisp]
---------------------
(set 'var "hello")
(string? var)  → true
---------------------

function::struct[]

*syntax:* (struct _symbol_ [_str-data-type_ ... ])

The `struct` function can be used to define aggregate data types for
usage with the extended syntax of link:#import[import], link:#pack[pack]
and link:#unpack[unpack]. This allows importing functions which take
C-language _struct_ data types or pointers to these aggregate data
types.

The following example illustrates the usage of `struct` together with
the C data functions `localtime` and `asctime`. The `localtime`
functions works similar to the built-in link:#now[now] function. The
`asctime` function takes the numerical data output by `localtime` and
formats these to readable text.

[source,c]
--------------------------------------------------------------------------------
/* The C function prototypes for the functions to import */

struct tm * localtime(const time_t *clock);

char * asctime(const struct tm *timeptr);

/* the tm struct aggregating different time related values */

struct tm {
    int tm_sec;      /* seconds after the minute [0-60] */
    int tm_min;      /* minutes after the hour [0-59] */
    int tm_hour;     /* hours since midnight [0-23] */
    int tm_mday;     /* day of the month [1-31] */
    int tm_mon;      /* months since January [0-11] */
    int tm_year;     /* years since 1900 */
    int tm_wday;     /* days since Sunday [0-6] */
    int tm_yday;     /* days since January 1 [0-365] */
    int tm_isdst;    /* Daylight Savings Time flag */
    long tm_gmtoff;  /* offset from CUT in seconds */   /*** not on Windows ***/
    char *tm_zone;   /* timezone abbreviation */        /*** not on Windows ***/
};
--------------------------------------------------------------------------------

Function import and definition of the structure data type in newLISP:

[source,newlisp]
---------------------------------------------------------------------------------
;; for pointers to structs always use void*
;; as a library use msvcrt.dll on Windows or libc.so on Unix.
;; The tm struct type is configured for Mac OSX and Linux.
;; On other OS the tm structure may be different

(import "libc.dylib" "asctime" "char*" "void*")
(import "libc.dylib" "localtime" "void*" "void*")

; definition of the struct
(struct 'tm "int" "int" "int" "int" "int" "int" "int" "int" "int" "long" "char*")

;; use import and struct

; todays date number (seconds after 1970 also called Unix epoch time)
(set 'today (date-value))  → 1324134913

;; the time value is passed by it's address
;; localtime retirns a pointer to a tm struct

(set 'ptr (localtime (address today))) → 2896219696

; unpack the the tm struct  (7:15:13 on the 17th etc.)
(unpack tm ptr) → (13 15 7 17 11 111 6 350 0 -28800 "PST")

; transform to readable form
(asctime ptr) → "Sat Dec 17 07:15:13 2011\n"

; all in one statement does actually not use struct, pointers are passed directly
(asctime (localtime (address today))) → "Sat Dec 17 07:15:13 2011"

; same as the built-in date function
(date today) → "Sat Dec 17 07:15:13 2011"
---------------------------------------------------------------------------------

Care must be taken to pass valid addresses to pointer parameters in
imported functions or when passing address pointers to
link:#unpack[unpack]. Invalid address pointers can crash newLISP or make
it unstable.

`struct` defininitions can be nested:

[source,newlisp]
------------------------------------------------------------------
; the pair aggregate type
(struct 'pair "char" "char") → pair

; nested struct type
(struct 'comp "pair" "int")  → comp

; pack data using the extended pack syntax
; not the insertion of structure alignment bytes after the pair
(pack comp (pack pair 1 2) 3) → "\001\002\000\000\003\000\000\000"

; unpack reverses the process
(unpack comp "\001\002\000\000\003\000\000\000") → ((1 2) 3)
------------------------------------------------------------------

Nested structures are unpacked recursively.

function::sub[]

*syntax:* (sub _num-1_ [_num-2_ ... ])

Successively subtracts the expressions in _num-1_, _num-2_—. `sub`
performs mixed-type arithmetic and handles integers or floating points,
but it will always return a floating point number. If only one argument
is supplied, its sign is reversed. Any floating point calculation with
`NaN` also returns `NaN`.

[source,newlisp]
-----------------------
(sub 10 8 0.25)  → 1.75
(sub 123)        → -123
-----------------------

function::swap[!]

*syntax:* (swap _place-1_ _place-2_)

The contents of the two places _place-1 and place-2_ are swapped. A
_place_ can be the contents of an unquoted symbol or any list or array
references expressed with link:#nth[nth], link:#first[first],
link:#lst[last] or implicit link:#indexing[indexing] or places
referenced by link:#assoc[assoc] or link:#lookup[lookup].

`swap` is a destructive operation that changes the contents of the
lists, arrays, or symbols involved.

[source,newlisp]
------------------------------------------------------
(set 'lst '(a b c d e f))

(swap (first lst) (last lst)) → a
lst                           → (f b c d e a)

(set 'lst-b '(x y z))

(swap (lst 0) (lst-b -1)) → f
lst                       → (z b c d e a)
lst-b                     → (x y f)

(set 'A (array 2 3 (sequence 1 6)) → ((1 2 3) (4 5 6))

(swap (A 0) (A 1)) → (1 2 3)
A                  → ((4 5 6) (1 2 3))

(set 'x 1 'y 2)

(swap x y)  → 1
x  → 2
y  → 1

(set 'lst '((a 1 2 3) (b 10 20 30)))
(swap (lookup 'a lst -1) (lookup 'b lst 1))
lst → ((a 1 2 10) (b 3 20 30))

(swap (assoc 'a lst) (assoc 'b lst))
lst →  ((b 3 20 30) (a 1 2 10))
------------------------------------------------------

Any two places can be swept in the same or different objects.

function::sym[]

*syntax:* (sym _string_ [_sym-context_ _nil-flag_]) +
*syntax:* (sym _number_ [_sym-context_ _nil-flag_]) +
*syntax:* (sym _symbol_ [_sym-context_ _nil-flag_])

Translates the first argument in _string_, _number_, or _symbol_ into a
symbol and returns it. If the optional context is not specified in
_sym-context_, the current context is used when doing symbol lookup or
creation. Symbols will be created if they do not already exist. When the
context does not exist and the context is specified by a quoted symbol,
the symbol also gets created. If the context specification is unquoted,
the context is the specified name or the context specification is a
variable containing the context.

`sym` can create symbols within the symbol table that are not legal
symbols in newLISP source code (e.g., numbers or names containing
special characters such as parentheses, colons, etc.). This makes `sym`
usable as a function for associative memory access, much like _hash
table_ access in other scripting languages.

As a third optional argument, `nil` can be specified to suppress symbol
creation if the symbol is not found. In this case, `sym` returns `nil`
if the symbol looked up does not exist. Using this last form, `sym` can
be used to check for the existence of a symbol.

[source,newlisp]
-------------------------------------------------------
(sym "some")           → some
(set (sym "var") 345)  → 345
var                    → 345
(sym "aSym" 'MyCTX)    → MyCTX:aSym
(sym "aSym" MyCTX)     → MyCTX:aSym  ; unquoted context

(sym "foo" MyCTX nil)  → nil  ; 'foo does not exist
(sym "foo" MyCTX)      → foo  ; 'foo is created
(sym "foo" MyCTX nil)  → foo  ; foo now exists
-------------------------------------------------------

Because the function `sym` returns the symbol looked up or created,
expressions with `sym` can be embedded directly in other expressions
that use symbols as arguments. The following example shows the use of
`sym` as a hash-like function for associative memory access, as well as
symbol configurations that are not legal newLISP symbols:

[source,newlisp]
---------------------------------------------------
;; using sym for simulating hash tables

(set (sym "John Doe" 'MyDB) 1.234)
(set (sym "(" 'MyDB) "parenthesis open")
(set (sym 12 'MyDB) "twelve")

(eval (sym "John Doe" 'MyDB))  → 1.234
(eval (sym "(" 'MyDB))         → "parenthesis open"
(eval (sym 12 'MyDB))          → "twelve"

;; delete a symbol from a symbol table or hash
(delete (sym "John Doe" 'MyDB))  → true
---------------------------------------------------

The last statement shows how a symbol can be eliminated using
link:#delete[delete].

The third syntax allows symbols to be used instead of strings for the
symbol name in the target context. In this case, `sym` will extract the
name from the symbol and use it as the name string for the symbol in the
target context:

[source,newlisp]
------------------------------------
(sym 'myVar 'FOO)  → FOO:myVar

(define-macro (def-context)
  (dolist (s (rest (args)))
    (sym s (first (args)))))

(def-context foo x y z)

(symbols foo)  → (foo:x foo:y foo:z)
------------------------------------

The `def-context` macro shows how this could be used to create a macro
that creates contexts and their variables in a dynamic fashion.

A syntax of the link:#context[context] function can also be used to
create, set and evaluate symbols.

function::symbol?[]

*syntax:* (symbol? _exp_)

Evaluates the _exp_ expression and returns `true` if the value is a
symbol; otherwise, it returns `nil`.

[source,newlisp]
--------------------------------------
(set 'x 'y)  → y

(symbol? x)  → true

(symbol? 123)  → nil

(symbol? (first '(var x y z)))  → true
--------------------------------------

The first statement sets the contents of `x` to the symbol `y`. The
second statement then checks the contents of `x`. The last example
checks the first element of a list.

function::symbols[]

*syntax:* (symbols [_context_])

Returns a sorted list of all symbols in the current context when called
without an argument. If a context symbol is specified, symbols defined
in that context are returned.

[source,newlisp]
--------------------------------------------------------
(symbols)       ; list of all symbols in current context
(symbols 'CTX)  ; list of symbols in context CTX
(symbols CTX)   ; omitting the quote
(set 'ct CTX)   ; assigning context to a variable
(symbols ct)    ; list of symbols in context CTX
--------------------------------------------------------

The quote can be omitted because contexts evaluate to themselves.

function::sync[]

*syntax:* (sync _int-timeout_ [_func-inlet_]) +
*syntax:* (sync)

When _int-timeout_ in milliseconds is specified, `sync` waits for child
processes launched with link:#spawn[spawn] to finish. Whenever a child
process finishes, `sync` assigns the evaluation result of the spawned
subtask to the symbol specified in the spawn statement. The `sync`
returns `true` if all child processes have been processed or `nil` if
the timeout value has been reached and more child processes are pending.

If `sync` additionally is given with an optional user-defined _inlet_
function in _func-inlet_, this function will be called with the child
process-id as argument whenever a spawned child process returns.
_func-inlet_ can contain either a lambda expression or a symbol which
defines a function.

Without any parameter, `sync` returns a list of pending child process
PIDs (process identifiers), for which results have not been processed
yet.

The function `sync` is not available on Win32.

[source,newlisp]
----------------------------------------------------------
; wait for 10 seconds and process finished child processes
(sync 10000)

; wait for the maximum time (~ 1193 hours)
(sync -1)

(define (report pid)
    (println "process: " pid " has returned"))

; call the report function, when a child returns
(sync 10000 report) ; wait for 10 seconds max

; return a list of pending child processes
(sync)         → (245 246 247 248)

; wait and do something else
(until (true? (sync 10 report) )
    (println (time-of-day)))
----------------------------------------------------------

When `sync` is given with a timeout parameter, it will block until
timeout or until all child processes have returned, whichever comes
earlier. When no parameter is specified or a function is specified,
`sync` returns immediately.

The function `sync` is part of the Cilk API for synchronizing child
processes and process parallelization. See the reference for the
function link:#spawn[spawn] for a full discussion of the Cilk API.

function::sys-error[]

*syntax:* (sys-error) +
*syntax:* (sys-error _int-error_) +
*syntax:* (sys-error `0`)

Reports the last error generated by the underlying OS which newLISP is
running on. The error reported may differ on the platforms newLISP has
been compiled for. Consult the platform's C library information. The
error is reported as a list of error number and error text.

If no error has occurred or the system error number has been reset,
`nil` is returned.

When _int-error_ is greater `0` (zero) a list of the number and the
error text is returned.

To reset the error specify `0` as the error number.

Whenever a function in newLISP within the system resources area returns
`nil`, `sys-error` can be checked for the underlying reason. For file
operations, `sys-error` may be set for nonexistent files or wrong
permissions when accessing the resource. Another cause of error could be
the exhaustion of certain system resources like file handles or
semaphores.

[source,newlisp]
---------------------------------------------------
;; trying to open a nonexistent file
(open "xyz" "r")  → nil

(sys-error)       → (2 "No such file or directory")

;; reset errno
(sys-error 0)     → (0 "Unknown error: 0")
(sys-error)       → nil
---------------------------------------------------

See also link:#last-error[last-error] and link:#net-error[net-error].

function::sys-info[]

*syntax:* (sys-info [_int-idx_])

Calling `sys-info` without _int-idx_ returns a list of internal resource
statistics. Ten integers report the following status:

[cols="1<,9<",width="50%",options="header",]
|=======================================================================
|offset |description
|0 |Number of Lisp cells

|1 |Maximum number of Lisp cells constant

|2 |Number of symbols

|3 |Evaluation/recursion level

|4 |Environment stack level

|5 |Maximum call stack constant

|6 |Pid of the parent process or 0

|7 |Pid of running newLISP process

|8 |Version number as an integer constant

|9 |Operating system constant: +
 linux=1, bsd=2, osx=3, solaris=4, win32=6, os/2=7, cygwin=8,
tru64unix=9, aix=10  +
 bit 11 will be set for ffilib (extended import/callback API) versions
(add 1024) +
 bit 10 will be set for IPv6 versions (add 512) +
 bit 9 will be set for 64-bit (changeable at runtime) versions (add
256) +
 bit 8 will be set for UTF-8 versions (add 128) +
 bit 7 will be added for library versions (add 64)
|=======================================================================

The numbers from `0` to `9` indicate the optional offset in the returned
list.

It is recommended to use offsets 0 to 5 to address up and including
"Maximum call stack constant" and to use negative offsets -1 to -4 to
access the last four entries in the system info list. Future new entries
will be inserted after offset 5. This way older source code does not
need to change.

When using _int-idx_, one element of the list will be returned.

[source,newlisp]
-------------------------------------------------------------
(sys-info)     → (401 268435456 376 1 0 2048 39220 10002 131)
(sys-info 3)   → 1
(sys-info -2)  → 10002
-------------------------------------------------------------

The number for the maximum of Lisp cells can be changed via the `-m`
command-line switch. For each megabyte of Lisp cell memory, 64k memory
cells can be allocated. The maximum call stack depth can be changed
using the `-s` command-line switch.

function::t-test[]

*syntax:* (t-test _list-vector-A_ _list-vecor-B_ [`true`])

The functions performs a t-test using the _Student's t_ statistic for
comparing the means values in _list-vector-A_ and _list-vecor-B_. If the
`true` flag is not used, both vectors in A and B can be of different
length and groups represented by A and B are not related.

When the optional flag is set to `true`, measurements were taken from
the same group twice, e.g. before and after a procedure.

The following results are returned in a list:

[cols="1<,4<",width="35%",options="header",]
|==============================================================
|name     |description
|mean-a   |Mean of group A
|mean-b   |Mean of group B
|sdev-a   |Standard deviation in group A
|sdev-b   |Standard deviation in group B
|t        |t between mean values
|df       |Degress of freedom
|p        |Two tailed probablity of t under the null hypothesis
|==============================================================

The first example studies the effect of different sleep length before a
test on the SCAT (Sam's Cognitive Ability Test):

[source,newlisp]
---------------------------------------
; SCAT (Sam's Cognitive Ability Test)
(set 'hours-sleep-8 '(5 7 5 3 5 3 3 9))
(set 'hours-sleep-4 '(8 1 4 6 6 4 1 2))

(t-test hours-sleep-8 hours-sleep-4)
 → (5 4 2.138 2.563 0.847 14 0.411)
---------------------------------------

The duration of sleeps before the SCAT does not have a significant
impact with a probability value of `0.411`.

In the second example, the same group of people get tested twice, before
and after a treatment with Prosac depression medication:

[source,newlisp]
-------------------------------------------------
; Effect of Prozac on a group of depressed people
(set 'mood-pre '(3 0 6 7 4 3 2 1 4))
(set 'mood-post '(5 1 5 7 10 9 7 11 8))

(t-test mood-pre mood-post true)
 → (3.333 7 2.236 3.041 -3.143 8 0.0137)
-------------------------------------------------

The effect of the Prosac treatment is moderately significant with a `p`
of `0.0137`.

function::tan[]

*syntax:* (tan _num-radians_)

Calculates the tangent function from _num-radians_ and returns the
result.

[source,newlisp]
-----------------------------------------
(tan 1)                     → 1.557407725
(set 'pi (mul 2 (asin 1)))  → 3.141592654
(tan (div pi 4))            → 1
-----------------------------------------

function::tanh[]

*syntax:* (tanh _num-radians_)

Calculates the hyperbolic tangent of _num-radians_. The hyperbolic
tangent is defined mathematically as: _sinh (x) / cosh (x)_.

[source,newlisp]
--------------------------------------------
(tanh 1)     → 0.761594156
(tanh 10)    → 0.9999999959
(tanh 1000)  → 1
(= (tanh 1) (div (sinh 1) (cosh 1)))  → true
--------------------------------------------

function::term[]

*syntax:* (term _symbol_)

Returns as a string, the term part of a _symbol_ without the context
prefix.

[source,newlisp]
-------------------------------
(set 'ACTX:var 123)
(set 'sm 'ACTX:var)
(string sm)     → "ACTX:var"
(term sm)      → "var"

(set 's 'foo:bar)
(= s (sym (term s) (prefix s)))
-------------------------------

See also link:#prefix[prefix] to extract the namespace or context prefix
from a symbol.

function::throw[]

*syntax:* (throw _exp_)

Works together with the link:#catch[catch] function. `throw` forces the
return of a previous `catch` statement and puts the _exp_ into the
result symbol of `catch`.

[source,newlisp]
----------------------------------------------
(define (throw-test)
    (dotimes (x 1000)
        (if (= x 500) (throw "interrupted"))))

(catch (throw-test) 'result)  → true

result  → "interrupted"

(catch (throw-test))  → "interrupted"
----------------------------------------------

The last example shows a shorter form of link:#catch[catch], which
returns the `throw` result directly.

`throw` is useful for breaking out of a loop or for early return from
user-defined functions or expression blocks. In the following example,
the `begin` block will return `X` if `(foo X)` is `true`; else `Y` will
be returned:

[source,newlisp]
----------------------------
(catch (begin
    …
    (if (foo X) (throw X) Y)
    …
))
----------------------------

`throw` will _not_ cause an error exception. Use
link:#throw-error[throw-error] to throw user error exceptions.

function::throw-error[]

*syntax:* (throw-error _exp_)

Causes a user-defined error exception with text provided by evaluating
_exp_.

[source,newlisp]
-----------------------------------------------------------
(define (foo x y)
    (if (= x 0) (throw-error "first argument cannot be 0"))
    (+ x y))

(foo 1 2)  → 3

(foo 0 2)  ; causes a user error exception
ERR: user error : first argument cannot be 0
called from user-defined function foo
-----------------------------------------------------------

The user error can be handled like any other error exception using
user-defined error handlers and the link:#error-event[error-event]
function, or the form of link:#catch[catch] that can capture error
exceptions.

function::time[]

*syntax:* (time _exp_ [_int-count_)

Evaluates the expression in _exp_ and returns the time spent on
evaluation in floating point milliseconds. Depending on the platform
decimals of milliseconds are shown or not shown.

[source,newlisp]
------------------------------------
(time (myprog x y z))  → 450.340

(time (myprog x y z) 10)  → 4420.021
------------------------------------

In first the example, 450 milliseconds elapsed while evaluating
`(myprog x y z)`. The second example returns the time for ten
evaluations of `(myprog x y z)`. See also link:#date[date],
link:#date-value[date-value], link:#time-of-day[time-of-day], and
link:#now[now].

function::time-of-day[]

*syntax:* (time-of-day)

Returns the time in milliseconds since the start of the current day.

See also the link:#date[date], link:#date-value[date-value],
link:#time[time], and link:#now[now] functions.

function::timer[]

*syntax:* (timer _sym-event-handler | func-event-handler_ _num-seconds_ [_int-option_]) +
*syntax:* (timer _sym-event-handler | func-event-handler_) +
*syntax:* (timer)

Starts a one-shot timer firing off the Unix signal `SIGALRM`,
`SIGVTALRM`, or `SIGPROF` after the time in seconds (specified in
_num-seconds_) has elapsed. When the timer fires, it calls the
user-defined function in _sym-_ or _func-event-handler_.

On Linux/Unix, an optional `0`, `1`, or `2` can be specified to control
how the timer counts. With default option `0`, real time is measured.
Option `1` measures the time the CPU spends processing in the process
owning the timer. Option `2` is a combination of both called _profiling
time_. See the Unix man page `setitimer()` for details.

The event handler can start the timer again to achieve a continuous flow
of events. Starting with version 8.5.9, seconds can be defined as
floating point numbers with a fractional part (e.g., `0.25` for 250
milliseconds).

Defining `0` (zero) as time shuts the running timer down and prevents it
from firing.

When called with _sym-_ or _func-event-handler_, `timer` returns the
elapsed time of the timer in progress. This can be used to program time
lines or schedules.

`timer` called without arguments returns the symbol of the current event
handler.

[source,newlisp]
----------------------------------------------------
(define (ticker)
    (println (date)) (timer 'ticker 1.0))

> (ticker)
Tue Apr 12 20:44:48 2005 ; first execution of ticker
→ ticker                ; return value from ticker

> Tue Apr 12 20:44:49 2005    ; first timer event
Tue Apr 12 20:44:50 2005 ; second timer event ...
Tue Apr 12 20:44:51 2005
Tue Apr 12 20:44:52 2005
----------------------------------------------------

The example shows an event handler, `ticker`, which starts the timer
again after each event.

Note that a timer cannot interrupt an ongoing built-in function. The
timer interrupt gets registered by newLISP, but a timer handler cannot
run until one expression is evaluated and the next one starts. To
interrupt an ongoing I/O operation with `timer`, use the following
pattern, which calls link:#net-select[net-select] to test if a socket is
ready for reading:

[source,newlisp]
--------------------------------------------
define (interrupt)
    (set 'timeout true))

(set 'listen (net-listen 30001))
(set 'socket (net-accept listen))

(timer 'interrupt 10)
;; or specifying the function directly
(timer (fn () (set 'timeout true)) 10)

(until (or timeout done)
    (if (net-select socket "read" 100000)
        (begin
            (net-receive socket buffer 1024)
            (set 'done true)))
)

(if timeout
    (println "timeout")
    (println buffer))

(exit)
--------------------------------------------

In this example, the `until` loop will run until something can be read
from `socket`, or until ten seconds have passed and the `timeout`
variable is set.

function::title-case[utf8]

*syntax:* (title-case _str_ _[bool]_)

Returns a copy of the string in _str_ with the first character converted
to uppercase. When the optional _bool_ parameter evaluates to any value
other than `nil`, the rest of the string is converted to lowercase.

[source,newlisp]
------------------------------------
(title-case "hello")       → "Hello"
(title-case "hELLO" true)  → "Hello"
(title-case "hELLO")       → "HELLO"
------------------------------------

See also the link:#lower-case[lower-case] and
link:#upper-case[upper-case] functions.

function::trace[]

*syntax:* (trace [_bool_])

Tracing is switched on when _bool_ evaluates to anything other than
`nil`. When no argument is supplied, `trace` evaluates to `true` or
`nil` depending on the current trace mode. If trace mode is switched on,
newLISP goes into debugging mode after entering the next user defined
function, displaying the function and highlighting the current
expression upon entry and exit.

Highlighting is done by bracketing the expression between two # (number
sign) characters. This can be changed to a different character using
link:#trace-highlight[trace-highlight]. Upon exit from the expression,
the result of its evaluation is also reported.

If an expression occurs more than once in a function, the first
occurrence of the executing function will always be highlighted
(bracketed).

newLISP execution stops with a prompt line at each entry and exit of an
expression.

[source,newlisp]
--------------------------------
[-> 2] s|tep n|ext c|ont q|uit >
--------------------------------

At the prompt, an `s`, `n`, `c`, or `q` can be entered to step into or
merely execute the next expression. Any expression can be entered at the
prompt for evaluation. Entering the name of a variable, for example,
would evaluate to its contents. In this way, a variable's contents can
be checked during debugging or set to different values.

[source,newlisp]
-----------------------------------------
;; switches newLISP into debugging mode
(trace true)  → true

;; the debugger will show each step
(my-func a b c)

;; switched newLISP out of debugging mode
(trace nil)  → nil
-----------------------------------------

To set break points where newLISP should interrupt normal execution and
go into debugging mode, put `(trace true)` statements into the newLISP
code where execution should switch on the debugger.

Use the link:#debug[debug] function as a shortcut for the above example.

function::trace-highlight[]

*syntax:* (trace-highlight _str-pre_ _str-post_ [_str-header_ _str-footer_])

Sets the characters or string of characters used to enclose expressions
during link:#trace[trace]. By default, the # (number sign) is used to
enclose the expression highlighted in link:#trace[trace] mode. This can
be changed to different characters or strings of up to seven characters.
If the console window accepts terminal control characters, this can be
used to display the expression in a different color, bold, reverse, and
so forth.

Two more strings can optionally be specified for _str-header and
str-footer_, which control the separator and prompt. A maximum of 15
characters is allowed for the header and 31 for the footer.

[source,newlisp]
-------------------------------------------------------
;; active expressions are enclosed in >> and <<

(trace-highlight ">>" "<<")

;; 'bright' color on a VT100 or similar terminal window

(trace-highlight "\027[1m" "\027[0m")
-------------------------------------------------------

The first example replaces the default `#` (number sign) with a `>>` and
`<<`. The second example works on most Linux shells. It may not,
however, work in console windows under Win32 or CYGWIN, depending on the
configuration of the terminal.

function::transpose[]

*syntax:* (transpose _matrix_)

Transposes a _matrix_ by reversing the rows and columns. Any kind of
list-matrix can be transposed. Matrices are made rectangular by filling
in `nil` for missing elements, omitting elements where appropriate, or
expanding atoms in rows into lists. Matrix dimensions are calculated
using the number of rows in the original matrix for columns and the
number of elements in the first row as number of rows for the transposed
matrix.

The matrix to transpose can contain any data-type.

The dimensions of a matrix are defined by the number of rows and the
number of elements in the first row. A matrix can either be a nested
list or an link:#array[array].

[source,newlisp]
----------------------------------------------------------
(set 'A '((1 2 3) (4 5 6)))
(transpose A)                      → ((1 4) (2 5) (3 6))
(transpose (list (sequence 1 5)))  → ((1) (2) (3) (4) (5))

; any data type is allowed in the matrix
(transpose '((a b) (c d) (e f)))   → ((a c e) (b d f))

; arrays can be transposed too
(set 'A (array 2 3 (sequence 1 6)))
(set 'M (transpose A))
M → ((1 4) (2 5) (3 6))
----------------------------------------------------------

The number of columns in a matrix is defined by the number of elements
in the first row of the matrix. If other rows have fewer elements,
`transpose` will assume `nil` for those missing elements. Superfluous
elements in a row will be ignored.

[source,newlisp]
--------------------------------------------
(set 'A '((1 2 3) (4 5) (7 8 9)))

(transpose A)  → ((1 4 7) (2 5 8) (3 nil 9))
--------------------------------------------

If a row is any other data type besides a list, the transposition treats
it like an entire row of elements of that data type:

[source,newlisp]
------------------------------------------
(set 'A '((1 2 3) X (7 8 9)))

(transpose A)  → ((1 X 7) (2 X 8) (3 X 9))
------------------------------------------

All operations shown here on lists can also be performed on arrays.

See also the matrix operations link:#det[det], link:#invert[invert],
link:#mat[mat] and link:#multiply[multiply].

function::trim[utf8]

*syntax:* (trim _str_ [_str-char_]) +
*syntax:* (trim _str_ _str-left-char_ _str-right-char_)

The first syntax trims the string _str_ from both sides, stripping the
leading and trailing characters as given in _str-char_. If _str-char_
contains no character, the space character is assumed. `trim` returns
the new string.

The second syntax can either trim different characters from both sides
or trim only one side if an empty string is specified for the other.

[source,newlisp]
------------------------------------------
(trim "   hello  ")              → "hello"
(trim "----hello-----" "-")      → "hello"
(trim "00012340" "0" "")         → "12340"
(trim "1234000" "" "0")          → "1234"
(trim "----hello=====" "-" "=")  → "hello"
------------------------------------------

function::true?[]

*syntax:* (true? _exp_)

If the expression in _exp_ evaluates to anything other than `nil` or the
empty list `()`, `true?` returns `true`; otherwise, it returns `nil`.

[source,newlisp]
--------------------------------------
(map true? '(x 1 "hi" (a b c) nil ()))
→ (true true true true nil nil)
(true? nil)  → nil
(true? '())  → nil
--------------------------------------

`true?` behaves like link:#if[if] and rejects the empty list `()`.

function::unicode[]

*syntax:* (unicode _str-utf8_)

Converts ASCII/UTF-8 character strings in _str_ to UCS-4–encoded Unicode
of 4-byte integers per character. The string is terminated with a 4-byte
integer `0`. This function is only available on UTF-8–enabled versions
of newLISP.

[source,newlisp]
-----------------------------------------------------------
(unicode "new")
→ "n\000\000\000e\000\000\000w\000\000\000\000\000\000\000"

(utf8 (unicode "new"))  → "new"
-----------------------------------------------------------

On _big endian_ CPU architectures, the byte order will be reversed from
high to low. The `unicode` and link:#utf8[utf8] functions are the
inverse of each other. These functions are only necessary if UCS-4
Unicode is in use. Most systems use UTF-8 encoding only.

function::unify[]

*syntax:* (unify _exp-1_ _exp-2_ [_list-env_])

Evaluates and matches _exp-1_ and _exp-2_. Expressions match if they are
equal or if one of the expressions is an unbound variable (which would
then be bound to the other expression). If expressions are lists, they
are matched by comparing subexpressions. Unbound variables start with an
uppercase character to distinguish them from symbols. `unify` returns
`nil` when the unification process fails, or it returns a list of
variable associations on success. When no variables were bound, but the
match is still successful, `unify` returns an empty list. newLISP uses a
modified _J. Alan Robinson_ unification algorithm with correctly applied
_occurs check_. See also _Peter Norvig_'s paper about a common
http://norvig.com/unify-bug.pdf[unifcation algorithm bug], which is not
present in this implementation.

Since version 10.4.0 the underscore symbol `_` (ASCII 95) matches any
atom, list or unbound variable and never binds.

Like link:#match[match], `unify` is frequently employed as a parameter
functor in link:#find[find], link:#ref[ref], link:#ref-all[ref-all] and
link:#replace[replace].

[source,newlisp]
---------------------------------------------------------------------------------------
(unify 'A 'A)  → ()  ; tautology

(unify 'A 123)  → ((A 123))  ; A bound to 123

(unify '(A B) '(x y))  → ((A x) (B y))  ; A bound to x, B bound to y

(unify '(A B) '(B abc))  → ((A abc) (B abc))  ; B is alias for A

(unify 'abc 'xyz)  → nil  ; fails because symbols are different

(unify '(A A) '(123 456))  → nil  ; fails because A cannot be bound to different values

(unify '(f A) '(f B))  → ((A B))  ; A and B are aliases

(unify '(f A) '(g B))  → nil  ; fails because heads of terms are different

(unify '(f A) '(f A B))  → nil  ; fails because terms are of different arity

(unify '(f (g A)) '(f B))  → ((B (g A)))  ; B bound to (g A)

(unify '(f (g A) A) '(f B xyz))  → ((B (g xyz)) (A xyz))  ; B bound to (g xyz) A to xyz

(unify '(f A) 'A)  → nil  ; fails because of infinite unification (f(f(f …)))

(unify '(A xyz A) '(abc X X))  →  nil ; indirect alias A to X doesn't match bound terms

(unify '(p X Y a) '(p Y X X))  → '((Y a) (X a)))  ; X alias Y and binding to 'a

(unify '(q (p X Y) (p Y X)) '(q Z Z))  → ((Y X) (Z (p X X)))  ; indirect alias

(unify '(A b _) '(x G z)) → ((A x) (G b)) ; _ matches atom z

(unify '(A b c _) '(x G _ z)) → ((A x) (G b)) ; _ never binds, matches c and z

(unify '(A b _) '(x G (x y z))) → ((A x) (G b)) ; _ matches list (x y z)

;; some examples taken from http://en.wikipedia.org/wiki/Unification
---------------------------------------------------------------------------------------

`unify` can take an optional binding or association list in _list-env_.
This is useful when chaining `unify` expressions and the results of
previous `unify` bindings must be included:

[source,newlisp]
------------------------------------
(unify '(f X) '(f 123))  → ((X 123))

(unify '(A B) '(X A) '((X 123)))
→ ((X 123) (A 123) (B 123))
------------------------------------

In the previous example, `X` was bound to `123` earlier and is included
in the second statement to pre-bind `X`.

Use `unify` with `expand`
^^^^^^^^^^^^^^^^^^^^^^^^^

Note that variables are not actually bound as a newLISP assignment.
Rather, an association list is returned showing the logical binding. A
special syntax of link:#expand[expand] can be used to actually replace
bound variables with their terms:

[source,newlisp]
-----------------------------------------------------
(set 'bindings (unify '(f (g A) A) '(f B xyz)))
→ ((B (g xyz)) (A xyz))

(expand '(f (g A) A) bindings)  → (f (g xyz) xyz)

; or in one statement
(expand '(f (g A) A) (unify '(f (g A) A) '(f B xyz)))
→ (f (g xyz) xyz)
-----------------------------------------------------

Use `unify` with `bind` for de-structuring
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The function link:#bind[bind] can be used to set unified variables:

[source,newlisp]
--------------------------------------
(bind (unify '(f (g A) A) '(f B xyz)))

A → xyz
B → (g xyz)
--------------------------------------

This can be used for de-structuring:

[source,newlisp]
------------------------------------------------
(set 'structure '((one "two") 3 (four (x y z))))
(set 'pattern '((A B) C (D E)))
(bind (unify pattern structure))

A → one
B → "two"
C → 3
D → four
E → (x y z)
------------------------------------------------

`unify` returns an association list and `bind` binds the associations.

Model propositional logic with `unify`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following example shows how propositional logic can be modeled using
`unify` and link:#expand[expand]:

[source,newlisp]
---------------------------------------------------------------
; if somebody is human, he is mortal -> (X human) :- (X mortal)
; socrates is human -> (socrates human)
; is socrates mortal? -> ?  (socrates mortal)

(expand '(X mortal)
         (unify '(X human) '(socrates human)))
→ (socrates mortal)
---------------------------------------------------------------

The following is a more complex example showing a small, working PROLOG
(Programming in Logic) implementation.

[source,newlisp]
--------------------------------------------------------------
;; a small PROLOG implementation

(set 'facts '(
    (socrates philosopher)
    (socrates greek)
    (socrates human)
    (einstein german)
    (einstein (studied physics))
    (einstein human)
))

(set 'rules '(
    ((X mortal) <- (X human))
    ((X (knows physics)) <- (X physicist))
    ((X physicist) <- (X (studied physics)))
))

(define (query trm)
    (or  (if (find trm facts) true) (catch (prove-rule trm))))

(define (prove-rule trm)
    (dolist (r rules)
        (if (list? (set 'e (unify trm (first r))))
            (if (query (expand (last r) e))
                (throw true))))
    nil
)

; try it

> (query '(socrates human))
true
> (query '(socrates (knows physics)))
nil
> (query '(einstein (knows physics)))
true
--------------------------------------------------------------

The program handles a database of `facts` and a database of simple _A is
a fact if B is a fact_ `rules`. A fact is proven true if it either can
be found in the `facts` database or if it can be proven using a rule.
Rules can be nested: for example, to prove that somebody
`(knows physics)`, it must be proved true that somebody is a
`physicist`. But somebody is only a physicist if that person
`studied physics`. The `<-` symbol separating the left and right terms
of the rules is not required and is only added to make the rules
database more readable.

This implementation does not handle multiple terms in the right premise
part of the rules, but it does handle backtracking of the `rules`
database to try out different matches. It does not handle backtracking
in multiple premises of the rule. For example, if in the following rule
`A if B and C and D`, the premises `B` and `C` succeed and `D` fails, a
backtracking mechanism might need to go back and reunify the `B` or `A`
terms with different facts or rules to make `D` succeed.

The above algorithm could be written differently by omitting
link:#expand[expand] from the definition of `prove-rule` and by passing
the environment, `e`, as an argument to the `unify` and `query`
functions.

A _learning_ of proven facts can be implemented by appending them to the
`facts` database once they are proven. This would speed up subsequent
queries.

Larger PROLOG implementations also allow the evaluation of terms in
rules. This makes it possible to implement functions for doing other
work while processing rule terms. `prove-rule` could accomplish this
testing for the symbol `eval` in each rule term.

function::union[]

*syntax:* (union _list-1_ _list-2_ [_list-3_ ... ])

`union` returns a unique collection list of distinct elements found in
two or more lists.

[source,newlisp]
-----------------------------------------------------
(union '(1 3 1 4 4 3) '(2 1 5 6 4))  →  (1 3 4 2 5 6)
-----------------------------------------------------

Like the other set functions link:#difference[difference],
link:#interset[intersect] and link:#unique[unique], `union` maintains
the order of elements as found in the original lists.

function::unique[]

*syntax:* (unique _list_)

Returns a unique version of _list_ with all duplicates removed.

[source,newlisp]
--------------------------------------------
(unique '(2 3 4 4 6 7 8 7))  → (2 3 4 6 7 8)
--------------------------------------------

Note that the list does not need to be sorted, but a sorted list makes
`unique` perform faster.

Other _set_ functions are link:#difference[difference],
link:#intersect[intersect] and link:#union[union].

function::unless[]

*syntax:* (unless _exp-condition_ _body_)

The statements in _body_ are only evaluated if _exp-condition_ evaluates
to `nil` or the empty list `()`. The result of the last expression in
_body_ is returned or `nil` or the empty list `()` if _body_ was not
executed.

Because `unless` does not have an _else_ condition as in link:#if[if],
the statements in _body_ need not to be grouped with link:#begin[begin]:

[source,newlisp]
----------------------------------------
(unless (starts-with (read-line) "quit")
    (process (current-line))
    ...
    (finish)
)
----------------------------------------

See also the function link:#when[when].

function::unpack[]

*syntax:* (unpack _str-format_ _str-addr-packed_) +
*syntax:* (unpack _str-format_ _num-addr-packed_) +
*syntax:* (unpack _struct_ _num-addr-packed_) +
*syntax:* (unpack _struct_ _str-addr-packed_)

When the first parameter is a string, `unpack` unpacks a binary
structure in _str-addr-packed_ or pointed to by _num-addr-packed_ into
newLISP variables using the format in _str-format_. `unpack` is the
reverse operation of `pack`. Using _num-addr-packed_ facilitates the
unpacking of structures returned from imported, shared library
functions.

If the number specified in _num-addr-packed_ is not a valid memory
address, a system bus error or segfault can occur and crash newLISP or
leave it in an unstable state.

When the first parameter is the symbol of a link:#struct[struct]
definition, `unpack` uses the format as specified in _struct_. While
`unpack` with _str-format_ literally unpacks as specified, `unpack` with
_struct_ will skip structure aligning pad-bytes depending on data type,
order of elements and CPU architecture. Refer to the description of the
link:#struct[struct] function for more detail.

The following characters may define a format:

[cols="1<,4<",width="25%",options="header",]
|==================================================
|format |description
|`c ` |a signed 8-bit number
|`b ` |an unsigned 8-bit number
|`d ` |a signed 16-bit short number
|`u ` |an unsigned 16-bit short number
|`ld` |a signed 32-bit long number
|`lu` |an unsigned 32-bit long number
|`Ld` |a signed 64-bit long number
|`Lu` |an unsigned 64-bit long number
|`f ` |a float in 32-bit representation
|`lf` |a double float in 64-bit representation
|`sn` |a string of _n_ null padded ASCII characters
|`nn` |_n_ null characters
|`>` |switches to big endian byte order
|`<` |switches to little endian byte order
|==================================================

[source,newlisp]
------------------------------------------------------------
(pack "c c c" 65 66 67)  → "ABC"
(unpack "c c c" "ABC")   → (65 66 67)

(set 's (pack "c d u" 10 12345 56789))
(unpack "c d u" s)  → (10 12345 56789)

(set 's (pack "s10 f" "result" 1.23))
(unpack "s10 f" s)  → ("result\000\000\000\000" 1.230000019)

(set 's (pack "s3 lf" "result" 1.23))
(unpack "s3 f" s)  → ("res" 1.23)

(set 's (pack "c n7 c" 11 22))
(unpack "c n7 c" s)  → (11 22))
------------------------------------------------------------

The `>` and `<` specifiers can be used to switch between _little endian_
and _big endian_ byte order when packing or unpacking:

[source,newlisp]
-----------------------------------------------
;; on a little endian system (e.g., Intel CPUs)
(set 'buff (pack "d" 1))  → "\001\000"

(unpack "d" buff)   → (1)
(unpack ">d" buff)  → (256)
-----------------------------------------------

Switching the byte order will affect all number formats with 16-, 32-,
or 64-bit sizes.

The `pack` and `unpack` format need not be the same, as in the following
example:

[source,newlisp]
--------------------------------
(set 's (pack "s3" "ABC"))
(unpack "c c c" s)  → (65 66 67)
--------------------------------

The examples show spaces between the format specifiers. Although not
required, they can improve readability.

If the buffer's size at a memory address is smaller than the formatting
string specifies, some formatting characters may be left unused.

See also the link:#address[address], link:#get-int[get-int],
link:#get-long[get-long], link:#get-char[get-char],
link:#get-string[get-string], and link:#pack[pack] functions.

function::until[]

*syntax:* (until _exp-condition_ [_body_])

Evaluates the condition in _exp-condition_. If the result is `nil` or
the empty list `()`, the expressions in _body_ are evaluated. Evaluation
is repeated until the exp-condition results in a value other than `nil`
or the empty list. The result of the last expression evaluated in _body_
is the return value of the `until` expression. If _body_ is empty, the
result of last _exp-condition_ is returned. `until` works like
(link:#while[while] (link:#not[not] …)).

`until` also updates the system iterator symbol `$idx`.

[source,newlisp]
---------------------------------------------
(device (open "somefile.txt" "read"))
(set 'line-count 0)
(until (not (read-line)) (inc line-count))
(close (device))
(print "the file has " line-count " lines\n")
---------------------------------------------

Use the link:#do-until[do-until] function to test the condition _after_
evaluation of the body expressions.

function::upper-case[utf8]

*syntax:* (upper-case _str_)

Returns a copy of the string in _str_ converted to uppercase.
International characters are converted correctly.

[source,newlisp]
-------------------------------------------
(upper-case "hello world")  → "HELLO WORLD"
-------------------------------------------

See also the link:#lower-case[lower-case] and
link:#title-case[title-case] functions.

function::utf8[]

*syntax:* (utf8 _str-unicode_)

Converts a UCS-4, 4-byte, Unicode-encoded string (_str_) into UTF-8.
This function is only available on UTF-8–enabled versions of newLISP.

[source,newlisp]
-----------------------------------------------------------
(unicode "new")
→ "n\000\000\000e\000\000\000w\000\000\000\000\000\000\000"

(utf8 (unicode "new"))  → "new"
-----------------------------------------------------------

The `utf8` function can also be used to test for the presence of
UTF-8–enabled newLISP:

[source,newlisp]
--------------------------------------------------------------
(if utf8 (do-utf8-version-of-code) (do-ascii-version-of-code))
--------------------------------------------------------------

On _big endian_ CPU architectures, the byte order will be reversed from
highest to lowest. The `utf8` and link:#unicode[unicode] functions are
the inverse of each other. These functions are only necessary if UCS-4
Unicode is in use. Most systems use UTF-8 Unicode encoding only.

function::utf8len[]

*syntax:* (utf8len _str_)

Returns the number of characters in a UTF-8–encoded string. UTF-8
characters can be encoded in more than one 8-bit byte. `utf8len` returns
the number of UTF-8 characters in a string. This function is only
available on UTF-8–enabled versions of newLISP.

[source,newlisp]
---------------------------------
(utf8len "我能吞下玻璃而不伤身体。")    → 12
(length "我能吞下玻璃而不伤身体。")      → 36
---------------------------------

See also the link:#unicode[unicode] and link:#utf8[utf8] functions.
Above Chinese text from http://www.columbia.edu/kermit/utf8.html[UTF-8
Sampler].

function::uuid[]

*syntax:* (uuid [_str-node_])

Constructs and returns a UUID (Universally Unique IDentifier). Without a
node spec in _str-node_, a type 4 UUID random generated byte number is
returned. When the optional _str-node_ parameter is used, a type 1 UUID
is returned. The string in _str-node_ specifies a valid MAC (Media
Access Code) from a network adapter installed on the node or a random
node ID. When a random node ID is specified, the least significant bit
of the first node byte should be set to 1 to avoid clashes with real MAC
identifiers. UUIDs of type 1 with node ID are generated from a timestamp
and other data. See http://www.ietf.org/rfc/rfc4122.txt[RFC 4122] for
details on UUID generation.

[source,newlisp]
-------------------------------------------------------
;; type 4 UUID for any system

(uuid)  → "493AAD61-266F-48A9-B99A-33941BEE3607"

;; type 1 UUID preferred for distributed systems

;; configure node ID for ether 00:14:51:0a:e0:bc
(set 'id (pack "cccccc" 0x00 0x14 0x51 0x0a 0xe0 0xbc))

(uuid  id)  → "0749161C-2EC2-11DB-BBB2-0014510AE0BC"
-------------------------------------------------------

Each invocation of the `uuid` function will yield a new unique UUID. The
UUIDs are generated without system-wide shared stable store (see RFC
4122). If the system generating the UUIDs is distributed over several
nodes, then type 1 generation should be used with a different node ID on
each node. For several processes on the same node, valid UUIDs are
guaranteed even if requested at the same time. This is because the
process ID of the generating newLISP process is part of the seed for the
random number generator. When type 4 IDs are used on a distributed
system, two identical UUID's are still highly unlikely and impossible
for type 1 IDs if real MAC addresses are used.

function::wait-pid[]

*syntax:* (wait-pid _int-pid_ [_int-options_ | `nil`])

Waits for a child process specified in _int-pid_ to end. The child
process was previously started with link:#process[process] or
link:#fork[fork]. When the child process specified in _int-pid_ ends, a
list of pid and status value is returned. The status value describes the
reason for termination of the child process. The interpretation of the
returned status value differs between Linux and other flavors of Unix.
Consult the Linux/Unix man pages for the `waitpid` command (without the
hyphen used in newLISP) for further information.

When `-1` is specified for _int-pid_, pid and status information of any
child process started by the parent are returned. When `0` is specified,
`wait-pid` only watches child processes in the same process group as the
calling process. Any other negative value for _int-pid_ reports child
processes in the same process group as specified with a negative sign in
_int-pid_.

An option can be specified in _int-option_. See Linux/Unix documentation
for details on integer values for _int-options_. As an alternative,
`nil` can be specified. This option causes `wait-pid` to be
non-blocking, returning right away with a `0` in the pid of the list
returned. This option used together with an _int-pid_ parameter of `-1`
can be used to continuously loop and act on returned child processes.

This function is only available on Mac OS X, Linux and other Unix-like
operating systems.

[source,newlisp]
------------------------------------------------------------------
(set 'pid (fork (my-process))) → 8596

(set 'ret (wait-pid pid))  → (8596 0) ; child has exited

(println "process: " pid " has finished with status: " (last ret))
------------------------------------------------------------------

The process `my-process` is started, then the main program blocks in the
`wait-pid` call until `my-process` has finished.

function::when[]

*syntax:* (when _exp-condition_ _body_)

The statements in _body_ are only evaluated if _exp-condition_ evaluates
to anything not `nil` and not the empty list `()`. The result of the
last expression in _body_ is returned or `nil` or the empty list `()` if
_body_ was not executed.

Because `when` does not have an _else_ condition as in link:#if[if], the
statements in _body_ need not to be grouped with link:#begin[begin]:

[source,newlisp]
------------------------------------------
(when (read-line)
    (set 'result (analyze (current-line)))
    (report result)
    (finish)
)
------------------------------------------

See also the function link:#unless[unless] working like
`(when (not ...) ...)`.

function::while[]

*syntax:* (while _exp-condition_ _body_)

Evaluates the condition in _exp-condition_. If the result is not `nil`
or the empty list `()`, the expressions in _body_ are evaluated.
Evaluation is repeated until an _exp-condition_ results in `nil` or the
empty list `()`. The result of the body's last evaluated expression is
the return value of the `while` expression.

`while` also updates the system iterator symbol `$idx`.

[source,newlisp]
---------------------------------------------
(device (open "somefile.txt" "read"))
(set 'line-count 0)
(while (read-line) (inc line-count))
(close (device))
(print "the file has " line-count " lines\n")
---------------------------------------------

Use the link:#do-while[do-while] function to evaluate the condition
_after_ evaluating the body of expressions.

function::write[!]

*syntax:* (write _int-file_ _str-buffer_ [_int-size_]) +
*syntax:* (write _str_ _str-buffer_ [_int-size_])

The function `write` writes _int-size_ bytes from a buffer in
_str-buffer_ to a file specified in _int-file_, previously obtained from
a file `open` operation. If _int-size_ is not specified, all data in
_sym-buffer_ or _str-buffer_ is written. `write` returns the number of
bytes written or `nil` on failure.

`write` is a shorter writing of `write-buffer`. The longer form still
works but is deprecated and should be avoided in new code.

[source,newlisp]
-----------------------------------------
(set 'handle (open "myfile.ext" "write"))
(write handle data 100)
(write handle "a quick message\n")
-----------------------------------------

The code in the example writes 100 bytes to the file `myfile.ext` from
the contents in `data`.

In the second syntax, `write` can be used for destructive string
appending:

[source,newlisp]
-------------------------
(set 'str "")
(write str "hello world")

str   → "hello world"
-------------------------

See also the link:#read[read] function.

function::write-char[]

*syntax:* (write-char _int-file_ _int-byte1_ [_int-byte2_ ... ])

Writes a byte specified in _int-byte_ to a file specified by the file
handle in _int-file_. The file handle is obtained from a previous `open`
operation. Each `write-char` advances the file pointer by one 8-bit
byte.

`write-char` returns the number of bytes written.

[source,newlisp]
------------------------------------------
(define (slow-file-copy from-file to-file)
    (set 'in-file (open from-file "read"))
    (set 'out-file (open to-file "write"))
    (while (set 'chr (read-char in-file))
        (write-char out-file chr))
     (close in-file)
    (close out-file)
    "finished")
------------------------------------------

Use the link:#print[print] and link:#device[device] functions to write
larger portions of data at a time. Note that newLISP already supplies a
faster built-in function called link:#copy-file[copy-file].

See also the link:#read-char[read-char] function.

function::write-file[]

*syntax:* (write-file _str-file-name_ _str-buffer_)

Writes a file in _str-file-name_ with contents in _str-buffer_ in one
swoop and returns the number of bytes written.

On failure the function returns `nil`. For error information, use
link:#sys-error[sys-error] when used on files. When used on URLs
link:#net-error[net-error] gives more error information.

[source,newlisp]
-------------------------------------------------------
(write-file "myfile.enc"
    (encrypt (read-file "/home/lisp/myFile") "secret"))
-------------------------------------------------------

The file `myfile` is read, link:#encrypt[encrypted] using the password
`secret`, and written back into the new file `myfile.enc` in the current
directory.

`write-file` can take an `http://` or `file://` URL in _str-file-name_.
When the prefix `http://` is used, `write-file` works exactly like
link:#put-url[put-url] and can take the same additional parameters:

[source,newlisp]
----------------------------------------------------------------
(write-file "http://asite.com/message.txt" "This is a message" )
----------------------------------------------------------------

The file `message.txt` is created and written at a remote location,
`http://asite.com`, with the contents of _str-buffer_. In this mode,
`write-file` can also be used to transfer files to remote newLISP server
nodes.

See also the link:#append-file[append-file] and
link:#read-file[read-file] functions.

function::write-line[!]

*syntax:* (write-line [_int-file_ [_str_]]) +
*syntax:* (write-line _str-out_ [_str_]])

The string in _str_ and the line termination character(s) are written to
the device specified in _int-file_. When the string argument is omitted
`write-line` writes the contents of the last link:#read-line[read-line]
to _int-file_ If the first argument is omitted too then it writes to to
standard out (STDOUT) or to whatever device is set by
link:#device[device].

In the second syntax lines are appended to a string in _str-out_.

`write-line` returns the number of bytes written.

[source,newlisp]
---------------------------------------
(set 'out-file (open "myfile" "write"))
(write-line out-file "hello there")
(close out-file)

(set 'myFile (open "init.lsp" "read")
(while (read-line myFile) (write-line))

(set 'str "")
(write-line str "hello")
(write-line str "world")

str  →  "hello\nworld\n"
---------------------------------------

The first example opens/creates a file, writes a line to it, and closes
the file. The second example shows the usage of `write-line` without
arguments. The contents of `init.lsp` are written to the console screen.

See also the function link:#write[write] for writing to a device without
the line-terminating character.

function::xfer-event[]

*syntax:* (xfer-event _sym-event-handler_ | _func-event-handler_)

Registers a function in symbol _sym-event-handler_ or in lambda function
_func-event-handler_ to monitor HTTP byte transfers initiated by
link:#get-url[get-url], link:#post-url[post-url] or
link:#put-url[put-url] or initiated by file functions which can take
URLs like link:#load[load], link:#save[save],
link:#read-file[read-file], link:#write-file[write-file] and
link:#append-file[append-file].

E.g. whenever a block of data requested with link:#get-url[get-url]
arrives the function in _sym_ or _func_ will be called with the number
of bytes transferred. Likewise when sending data with
link:#post-url[post-url] or any of the other data sending functions,
_sym_ or _func_ will be called with the number of bytes transferred for
each block of data transferred.

[source,newlisp]
---------------------------------------
(xfer-event (fn (n) (println "->" n)))
(length (get-url "http://newlisp.org"))

->73
->799
->1452
->351
->1093
->352
->211
->885
->564
->884
->561
->75
->812
->638
->1452
->801
->5
->927
11935
---------------------------------------

The computer output is shown in bold. Whenever a block of data is
received its byte size is printed. Instead of defining the handler
function directory with a lambda function in _func_, a symbol containing
a function definition could have been used:

[source,newlisp]
------------------------------------
(define (report n) (println "->" n))
(xfer-event 'report)
------------------------------------

This can be used to monitor the progress of longer lasting byte
transfers in HTTP uploads or downloads.

function::xml-error[]

*syntax:* (xml-error)

Returns a list of error information from the last
link:#xml-parse[xml-parse] operation; otherwise, returns `nil` if no
error occurred. The first element contains text describing the error,
and the second element is a number indicating the last scan position in
the source XML text, starting at `0` (zero).

[source,newlisp]
---------------------------------------------
(xml-parse "<atag>hello</atag><fin")  → nil

(xml-error)  → ("expected closing tag: >" 18)
---------------------------------------------

function::xml-parse[]

*syntax:* (xml-parse _string-xml_ [_int-options_ [_sym-context_ [_func-callback_]]])

Parses a string containing XML 1.0 compliant, _well-formed_ XML.
`xml-parse` does not perform DTD validation. It skips DTDs (Document
Type Declarations) and processing instructions. Nodes of type ELEMENT,
TEXT, CDATA, and COMMENT are parsed, and a newLISP list structure is
returned. When an element node does not have attributes or child nodes,
it instead contains an empty list. Attributes are returned as
association lists, which can be accessed using link:#assoc[assoc]. When
`xml-parse` fails due to malformed XML, `nil` is returned and
link:#xml-error[xml-error] can be used to access error information.

[source,newlisp]
-------------------------------------------------------------
(set 'xml
  "<person name='John Doe' tel='555-1212'>nice guy</person>")

(xml-parse xml)
→ (("ELEMENT" "person"
    (("name" "John Doe")
     ("tel" "555-1212"))
    (("TEXT" "nice guy"))))
-------------------------------------------------------------

Modifying the translation process
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Optionally, the _int-options_ parameter can be specified to suppress
whitespace, empty attribute lists, and comments. It can also be used to
transform tags from strings into symbols. Another function,
link:#xml-type-tags[xml-type-tags], serves for translating the XML tags.
The following option numbers can be used:

[cols="1<,4<",width="30%",options="header",]
|==============================================
|option |description
|1 |suppress whitespace text tags
|2 |suppress empty attribute lists
|4 |suppress comment tags
|8 |translate string tags into symbols
|16 |add SXML (S-expression XML) attribute tags
|==============================================

Options can be combined by adding the numbers (e.g., `3` would combine
the options for suppressing whitespace text tags/info and empty
attribute lists).

The following examples show how the different options can be used:

.XML source:

[source,xml]
-----------------------------------
<?xml version="1.0" ?>
<DATABASE name="example.xml">
<!--This is a database of fruits-->
    <FRUIT>
        <NAME>apple</NAME>
        <COLOR>red</COLOR>
        <PRICE>0.80</PRICE>
    </FRUIT>

    <FRUIT>
        <NAME>orange</NAME>
        <COLOR>orange</COLOR>
        <PRICE>1.00</PRICE>
    </FRUIT>

    <FRUIT>
       <NAME>banana</NAME>
       <COLOR>yellow</COLOR>
       <PRICE>0.60</PRICE>
    </FRUIT>
</DATABASE>
-----------------------------------

.Parsing without any options:

[source,newlisp]
--------------------------------------------------------------------
(xml-parse (read-file "example.xml"))
→ (("ELEMENT" "DATABASE" (("name" "example.xml")) (("TEXT" "\r\n\t")
    ("COMMENT" "This is a database of fruits")
    ("TEXT" "\r\n\t")
    ("ELEMENT" "FRUIT" () (("TEXT" "\r\n\t\t") ("ELEMENT" "NAME" ()
       (("TEXT" "apple")))
      ("TEXT" "\r\n\t\t")
      ("ELEMENT" "COLOR" () (("TEXT" "red")))
      ("TEXT" "\r\n\t\t")
      ("ELEMENT" "PRICE" () (("TEXT" "0.80")))
      ("TEXT" "\r\n\t")))
    ("TEXT" "\r\n\r\n\t")
    ("ELEMENT" "FRUIT" () (("TEXT" "\r\n\t\t") ("ELEMENT" "NAME" ()
       (("TEXT" "orange")))
      ("TEXT" "\r\n\t\t")
      ("ELEMENT" "COLOR" () (("TEXT" "orange")))
      ("TEXT" "\r\n\t\t")
      ("ELEMENT" "PRICE" () (("TEXT" "1.00")))
      ("TEXT" "\r\n\t")))
    ("TEXT" "\r\n\r\n\t")
    ("ELEMENT" "FRUIT" () (("TEXT" "\r\n\t\t") ("ELEMENT" "NAME" ()
       (("TEXT" "banana")))
      ("TEXT" "\r\n\t\t")
      ("ELEMENT" "COLOR" () (("TEXT" "yellow")))
      ("TEXT" "\r\n\t\t")
      ("ELEMENT" "PRICE" () (("TEXT" "0.60")))
      ("TEXT" "\r\n\t")))
    ("TEXT" "\r\n"))))
--------------------------------------------------------------------

The `TEXT` elements containing only whitespace make the output very
confusing. As the database in `example.xml` only contains data, we can
suppress whitespace, empty attribute lists and comments with option
`(+ 1 2 4)`:

.Filtering whitespace TEXT, COMMENT tags, and empty attribute lists:

[source,newlisp]
---------------------------------------------------
(xml-parse (read-file "example.xml") (+ 1 2 4))
→ (("ELEMENT" "DATABASE" (("name" "example.xml")) (
     ("ELEMENT" "FRUIT" (
       ("ELEMENT" "NAME" (("TEXT" "apple")))
       ("ELEMENT" "COLOR" (("TEXT" "red")))
       ("ELEMENT" "PRICE" (("TEXT" "0.80")))))
     ("ELEMENT" "FRUIT" (
       ("ELEMENT" "NAME" (("TEXT" "orange")))
       ("ELEMENT" "COLOR" (("TEXT" "orange")))
       ("ELEMENT" "PRICE" (("TEXT" "1.00")))))
     ("ELEMENT" "FRUIT" (
       ("ELEMENT" "NAME" (("TEXT" "banana")))
       ("ELEMENT" "COLOR" (("TEXT" "yellow")))
       ("ELEMENT" "PRICE" (("TEXT" "0.60"))))))))
---------------------------------------------------

The resulting output looks much more readable, but it can still be
improved by using symbols instead of strings for the tags "FRUIT",
"NAME", "COLOR", and "PRICE", as well as by suppressing the XML type
tags "ELEMENT" and "TEXT" completely using the
link:#xml-type-tags[xml-type-tags] directive.

.Suppressing XML type tags with link:#xml-type-tags[xml-type-tags] and translating string tags into symbol tags:

[source,newlisp]
------------------------------------------------------------------
;; suppress all XML type tags for TEXT and ELEMENT
;; instead of "CDATA", use cdata and instead of "COMMENT", use !--

(xml-type-tags nil 'cdata '!-- nil)

;; turn on all options for suppressing whitespace and empty
;; attributes, translate tags to symbols

(xml-parse (read-file "example.xml") (+ 1 2 8))
→ ((DATABASE (("name" "example.xml"))
     (!-- "This is a database of fruits")
     (FRUIT (NAME "apple") (COLOR "red") (PRICE "0.80"))
     (FRUIT (NAME "orange") (COLOR "orange") (PRICE "1.00"))
     (FRUIT (NAME "banana") (COLOR "yellow") (PRICE "0.60"))))
------------------------------------------------------------------

When tags are translated into symbols by using option `8`, a context can
be specified in _sym-context_. If no context is specified, all symbols
will be created inside the current context.

[source,newlisp]
--------------------------------------------------------
(xml-type-tags nil nil nil nil)
(xml-parse "<msg>Hello World</msg>" (+ 1 2 4 8 16) 'CTX)
→ ((CTX:msg "Hello World"))
--------------------------------------------------------

Specifying `nil` for the XML type tags TEXT and ELEMENT makes them
disappear. At the same time, parentheses of the child node list are
removed so that child nodes now appear as members of the list, starting
with the tag symbol translated from the string tags "FRUIT", "NAME",
etcetera.

.Parsing into SXML (S-expressions XML) format:

Using link:#xml-type-tags[xml-type-tags] to suppress all XML-type
tags—along with the option numbers `1`, `2`, `4`, `8`, and `16`—SXML
formatted output can be generated:

[source,newlisp]
-------------------------------------------------------------
(xml-type-tags nil nil nil nil)
(xml-parse (read-file "example.xml") (+ 1 2 4 8 16))
→ ((DATABASE (@ (name "example.xml"))
    (FRUIT (NAME "apple") (COLOR "red") (PRICE "0.80"))
    (FRUIT (NAME "orange") (COLOR "orange") (PRICE "1.00"))
    (FRUIT (NAME "banana") (COLOR "yellow") (PRICE "0.60"))))
-------------------------------------------------------------

Note that using option number `16` causes an `@` (at symbol) to be added
to attribute lists.

See also the link:#xml-type-tags[xml-type-tags] function for further
information on XML parsing.

.Parsing into a specified context:

When parsing XML expressions, XML tags are translated into newLISP
symbols. The _sym-context_ option specifies the target context for the
symbol creation:

[source,newlisp]
-----------------------------------------------------------------------------
(xml-type-tags nil nil nil nil)
(xml-parse (read-file "example.xml") (+ 1 2 4 8 16) 'CTX)
→((CTX:DATABASE (@ (CTX:name "example.xml"))
    (CTX:FRUIT (CTX:NAME "apple") (CTX:COLOR "red") (CTX:PRICE "0.80"))
    (CTX:FRUIT (CTX:NAME "orange") (CTX:COLOR "orange") (CTX:PRICE "1.00"))
    (CTX:FRUIT (CTX:NAME "banana") (CTX:COLOR "yellow") (CTX:PRICE "0.60"))))
-----------------------------------------------------------------------------

If the context does not exist, it will be created. If it exists, the
quote can be omitted or the context can be referred to by a variable.

.Using a call back function:

Normally, `xml-parse` will not return until all parsing has finished.
Using the _func-callback_ option, `xml-parse` will call back after each
tag closing with the generated S-expression and a start position and
length in the source XML:

[source,newlisp]
-----------------------------------------------------------------------------
;; demo callback feature
(define (xml-callback s-expr start size)
    (if (or (= (s-expr 0) 'NAME) (= (s-expr 0) 'COLOR) (= (s-expr 0) 'PRICE))
        (begin
            (print "parsed expression:" s-expr)
            (println ", source:" (start size example-xml))
        )
    )
)

(xml-type-tags nil 'cdata '!-- nil)
(xml-parse  (read-file "example.xml") (+ 1 2 8) MAIN xml-callback)
-----------------------------------------------------------------------------

The following output will be generated by the callback function
`xml-callback`:

[source,newlisp]
----------------------------------------------------------------
parsed expression:(NAME "apple"), source:<NAME>apple</NAME>
parsed expression:(COLOR "red"), source:<COLOR>red</COLOR>
parsed expression:(PRICE "0.80"), source:<PRICE>0.80</PRICE>
parsed expression:(NAME "orange"), source:<NAME>orange</NAME>
parsed expression:(COLOR "orange"), source:<COLOR>orange</COLOR>
parsed expression:(PRICE "1.00"), source:<PRICE>1.00</PRICE>
parsed expression:(NAME "banana"), source:<NAME>banana</NAME>
parsed expression:(COLOR "yellow"), source:<COLOR>yellow</COLOR>
parsed expression:(PRICE "0.60"), source:<PRICE>0.60</PRICE>
----------------------------------------------------------------

The example callback handler function filters the tags of interest and
processes them as they occur.

function::xml-type-tags[]

*syntax:* (xml-type-tags [_exp-text-tag_ _exp-cdata-tag_ _exp-comment-tag_ _exp-element-tags_])

Can suppress completely or replace the XML type tags "TEXT", "CDATA",
"COMMENT", and "ELEMENT" with something else specified in the
parameters.

Note that `xml-type-tags` only suppresses or translates the tags
themselves but does not suppress or modify the tagged information. The
latter would be done using option numbers in link:#xml-parse[xml-parse].

Using `xml-type-tags` without arguments returns the current type tags:

[source,newlisp]
-------------------------------------------------------
(xml-type-tags)  → ("TEXT" "CDATA" "COMMENT" "ELEMENT")

(xml-type-tags nil 'cdata '!-- nil)
-------------------------------------------------------

The first example just shows the currently used type tags. The second
example specifies suppression of the "TEXT" and "ELEMENT" tags and shows
`cdata` and `!--` instead of "CDATA" and "COMMENT".

function::zero?[]

*syntax:* (zero? _exp_)

Checks the evaluation of _exp_ to see if it equals `0` (zero).

[source,newlisp]
-------------------------------------------------
(set 'value 1.2)
(set 'var 0)
(zero? value)  → nil
(zero? var)    → true

(map zero? '(0 0.0 3.4 4))  → (true true nil nil)
-------------------------------------------------

`zero?` will return `nil` on data types other than numbers.

// vim: set tw=72 cms=//%s :
